<!-- ======================================================================
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
======================================================================= -->

<!-- ======================================================================
* Copyright: (C) 2013 Gregor Cramer
======================================================================= -->

<!-- ======================================================================
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
======================================================================= -->

HEAD

<style type="text/css">

  #tooltip1 {
    outline: none;
    cursor: help;
    margin-top: 0;
    margin-bottom: 0;
    position: relative;
  }
  #tooltip1 a {
    color: #000000;
  }
  #tooltip1 a:hover {
    color: #000000;
    background: #ffff00;
    text-decoration: none;
  }
  #tooltip1 a img {
    display: none;
  }
  #tooltip1 a:hover img {
    display: block;
    position: absolute;
    left: 10em;
    top: 2em;
    z-index: 99;
  }
  </style>

END

INDEX Positionsliste (CQL)
INDEX CQL Positionsliste

DEFINE <extension/> &ensp;<img src="../images/ft-scidb-tiny.png" />

TITLE CQL &ndash; Die Positionsliste

<p>
Das Symbol <img src="../images/ft-scidb-tiny.png" /> im Titel einer
Schlüsselwortdefinition kennzeichnet, daß dieses Schlüsselwort eine
Erweiterung ist, also nicht zum CQL-Standard gehört.
</p>

<p>
Die Schlüsselwörter <cql>position:castling</cql>, <cql>position:endgame</cql>
und <cql>position:inside</cql> sind von Chess Assistant 9 entlehnt worden. Die
Beschreibung dieser Schlüsselwörter entstammt dem Dokument
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>.
</p>

<p>
Einige der Schlüsselwörter können mit einem vorangehenden Ausrufungszeichen negiert
werden, dies ist dann eine Kurzschreibweise; z.B. ist
</p>

<verb>
(position <cql>!position:check</cql>)
</verb>

<p>
eine Kurzschreibweise für
</p>

<verb>
(position <cql>position:not</cql> (position <cql>position:check</cql>))
</verb>

<p>
Die Schlüsselwörter <cql>:nocheck</cql> und <cql>:noenpassant</cql> werden
in <nobr>CQL-S</nobr> nicht mehr benötigt &ndash; hier werden stattdessen die
Ausdrücke <cql>!:check</cql> bzw. <cql>!:enpassant</cql> verwendet &ndash;
aber beim Importieren eines CQL-Skripts erkannt und entsprechend umgeformt.
</p>

<dir>
  <table style="white-space:nowrap">
    <tr><td>&#x2022;</td><td><a href="#index">Index</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#logical">Schlüsselwörter für die Kontrolllogik</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#simple">Einfache Schlüsselwörter</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#transform">Transformierende Schlüsselwörter</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#piece">Schlüsselwörte für die Figurenanalyse</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#move">Schlüsselwörter für die Zuganalyse</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#sequence">Schlüsselwörter für Sequenzen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#game">Schlüsselwörter für die Partieinformationen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#relation">Relationen zwischen den Positionen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#matching">Schlüsselwörter zur Zählung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#evaluation">Schlüsselwörter für die Stellungs- und Zugbeurteilung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#accumulator">Schlüsselwörter für Akkumulationen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#tagging">Schlüsselwörter für das Markieren</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#control">Schlüsselwörter für die Steuerung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#meaningless">Bedeutungslose Schlüsselwörter</a></td></tr>
  </table>
</dir>

<!-- ############################################################################## -->
<h2 id="index">Index</h2>
<!-- ############################################################################## -->

INCLUDE ../CQL-Position-List-Index.txt

<!-- ############################################################################## -->
<h2 id="logical">Schlüsselwörter für die Kontrolllogik</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:and">:and</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:cond">:cond</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:not">:not</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:or">:or</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:xor">:xor</a></td></tr>
</table>

<h3 id="position:and">:and&emsp;<n>(Und)</n></h3>

<p>
Erwartet eine Liste von Positionslisten, und filtert genau dann eine Position,
wenn jede von ihnen diese Position filtert. Die Argumente werden von links nach rechts ausgewertet.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <cql>position:wtm</cql>
  <cql>position:check</cql>
  <keyword>position:and</keyword> (
    (position &K;e2 &k;g2 <cql>position:shift</cql> <cql>position:flip</cql>)
    (position &N;e2)))
</verbatim>

<p>
Filtert Positionen in denen die Könige in direkter Opposition stehen, ein Springer auf
e2 platziert ist, und der weiße König steht im Schach.
</p>

<h3 id="position:cond">:cond<extension/>&emsp;<n>(Bedingte Auswertung)</n></h3>

<p>
Dieses Schlüsselwort wird in folgender allgemeinen Form angewandt:
</p>

<verbatim>
<keyword>position:cond</keyword> (
  (position &lt;Bedingung<sub>1</sub>&gt;) (position &lt;Ausdruck<sub>1</sub>&gt;)
  (position &lt;Bedingung<sub>2</sub>&gt;) (position &lt;Ausdruck<sub>2</sub>&gt;)
  ...
  (position &lt;Bedingung<sub>k</sub>&gt;) (position &lt;Ausdruck<sub>k</sub>&gt;))
</verbatim>

<p>
:cond erwartet eine beliebige Anzahl von Argumenten. Jedes Argument
<expr>&lt;Bedingung<sub>i</sub>&gt;</expr> wird eine <b>Klausel</b> genannt, und jedes Argument
<expr>&lt;Ausdruck<sub>i</sub>&gt;</expr> ist eine <b>Assoziation</b>. Es werden nacheinander alle
Klauseln von links nach rechts ausgewertet, bis eine der Klauseln eine Position filtern würde,
dann ist das Resultat des gesamtem Ausdrucks das Resultat der Auswertung der Klausel
und der zugehörigen Assoziation. Wenn keine Klausel filtert, dann kann diese Position nicht
aufgefunden werden.
</p>

<p>
Oftmals wird als letztes Paar ein Ausdruck der folgenden Form verwendet:
</p>

<verbatim>
(position) (position &lt;Ausdruck&gt;)
</verbatim>

<p>
Die leere Positionsliste filtert jede Position. Dieser letzte Fall kann verkürzt
ausgedrückt werden, indem das vorletzte Argument <expr>(position)</expr>
weggelassen wird, dann wird in jedem Fall das Resultat des letzten Ausdrucks
gewertet, wenn alle zuvorigen Klauseln nicht erfüllt werden.
</p>

<p>
Tatsächlich ist das Schlüsselwort <cql>:cond</cql> nicht redundant, denn
die folgende Umformumg mit <cql>:or</cql> ist nicht in allen Fällen äquivalent
(die Verwendung von <cql>position:cut</cql>, <cql>position:exclude</cql>
oder <cql>position:skip</cql> durchbricht die Äquivalenz):
</p>

<verbatim>
(position <cql>position:or</cql> (
  (position &lt;Bedingung<sub>1</sub>&gt; &lt;Ausdruck<sub>1</sub>&gt;)
  (position &lt;Bedingung<sub>2</sub>&gt; &lt;Ausdruck<sub>2</sub>&gt;)
  ...
  (position &lt;Bedingung<sub>k</sub>&gt; &lt;Ausdruck<sub>k</sub>&gt;)))
</verbatim>

<p>
Zudem wird der <cql>:cond</cql>-Ausdruck teilweise wesentlich effizienter ausgeführt
(beachte beispielsweise den Fall, das <expr>&lt;Bedingung<sub>1</sub>&gt;</expr> erfüllt
wird, aber nicht <expr>&lt;Ausdruck<sub>1</sub>&gt;</expr>, dann wird der
<cql>:or</cql>-Ausdruck mit der nächsten Liste fortgesetzt, während der
<cql>:cond</cql>-Ausdruck sofort das Resultat von
<expr>&lt;Ausdruck<sub>1</sub>&gt;</expr> liefert).
</p>

<p>
Jedoch ist mit der <cql>:or</cql>-Umformung ersichtlich, warum <cql>:cond</cql>
beim Filtern sowohl die Klausel als auch die Assoziation verwendet, um die
gefundene Position zu markieren (auch dies unterscheidet sich vom umgeformten
Ausdruck mit <cql>:or</cql>). Dazu ein simples Beispiel zur Erläuterung:
</p>

<verbatim>
(match
  (position <keyword>position:cond</keyword> (
    (position &P;e7) (position &p;e2))))
</verbatim>

<p>
Steht auf den Feldern e7 ein weißer Bauer, und ein schwarzer Bauer auf dem Feld e2,
dann werden in einer gefundenen Partie sowohl das Feld e7 als auch das Feld e2
markiert.
</p>

<p>
Für ein reelles Beispiel für die Anwendung von <cql>:cond</cql> siehe bei
<cql>position:exclude</cql>.
</p>

<h3 id="position:not">:not&emsp;<n>(Nicht)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es
parameterlos, oder es hat eine Positionsliste als Parameter.
Im ersten Fall filtert dieses Schlüsselwort, wenn die Positionsliste ohne dieses
Schlüsselwort nicht filtern würde. Im zweiten Fall: das Resultat des
Arguments wird negiert. Die erste Form ist konform mit dem CQL-Standard des
Schlüsselwortes <cql>:not</cql>, die zweite Form ist eine Erweiterung.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <comment>; wir suchen für beide Seiten</comment>
  <cql>position:flipcolor</cql>
  <comment>; die Mattposition muß alle folgenden Kriterien erfüllen</comment>
  <cql>position:and</cql> (
    <comment>; der König ist von Leerfeldern umgeben, wird einmal</comment>
    <comment>; attackiert, und ist matt</comment>
    (position
      <cql>position:attackcount</cql> &k; . 8
      <cql>position:attackcount</cql> &A; &k; 1
      <cql>position:mate</cql>
      <cql>position:btm</cql>)
    <comment>; überprüfe daß kein Nachbar des schwarzen Königs</comment>
    <comment>; mehr als einmal attackiert wird</comment>
    (position
      <keyword>position:not</keyword>
      <cql>position:attackcount</cql> &k; .e4 1
      <cql>position:attackcount</cql> &A; .e4 &gt;=2
      <cql>position:shift</cql>)))
</verbatim>

<p>
Dies findet alle Idealmatts: Studien in denen der König von Leerfeldern
umgeben ist und genau einmal angegriffen wird, so daß er auf einem
Nachbarsfeld ebenfalls genau einmal angegriffen wäre.
</p>

<p>
Die folgende Positionsliste
</p>

<verb>
(position &R;a3 <keyword>position:not</keyword>)
</verb>

<p>
ist äquivalent zu
</p>

<verb>
(position <keyword>position:not</keyword> (position &R;a3))
</verb>

<p>
und außerdem äquivalent zu
</p>

<verb>
(position [&a;&Q;&B;&N;&P;&K;.]a3)
</verb>

<p>
Hier ist die einfachere Schreibweise mit <cql>:not</cql> vorzuziehen.
</p>

<h3 id="position:or">:or&emsp;<n>(Oder)</n></h3>

<p>
Erwartet eine Liste von Positionslisten, und filter genau dann eine Position,
wenn mindestens eine von ihnen diese Position filtert. Die Argumente werden von
links nach rechts ausgewertet.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <keyword>position:or</keyword> (
    (position <cql>position:piececount</cql> &B;&L;? 2)
    (position <cql>position:piececount</cql> &b;&L;? 2)
    (position <cql>position:piececount</cql> &B;&D;? 2)
    (position <cql>position:piececount</cql> &b;&D;? 2)))
</verbatim>

<p>
Suche nach Partien, die Positionen mit zwei gleichfarbigen Läufern auf einer
Seite beinhalten.
</p>

<h3 id="position:xor">:xor&emsp;<n>(Exklusives Oder)</n></h3>

<p>
Erwartet eine Liste von Positionslisten und filtert nur dann eine
Position, wenn genau eine von ihnen diese Position filtert. Die Argumente
werden von links nach rechts ausgewertet.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position <keyword>position:xor</keyword> ((position &B;&D;?) (position &B;&L;?)))
</verbatim>

<p>
Findet Positionen auf, in denen Weiß entweder einen weißfeldrigen Läufer, oder
einen schwarzfeldrigen Läufer hat, aber nicht beides.
</p>

<!-- ############################################################################## -->
<h2 id="simple">Einfache Schlüsselwörter</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr>
    <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:kingonthehill">:kingonthehill</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:losing">:losing</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:mate">:mate</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:mustcapture">:mustcapture</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:catureforced">:catureforced</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:threechecks">:threechecks</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:fivefoldrepetition">:fen</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:threefoldrepetition">:threechecks</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:halfmoveclock">:halfmoveclock</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
  </tr>
    <td>      &#x2022;</td><td><a href="#position:insidevariation">:insidevariation</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:ispromotedpiece">:ispromotedpiece</a></td>
  </tr>
</table>

<h3 id="position:blackcannotwin">:blackcannotwin<extension/>&emsp;<n>(Schwarz kann nicht gewinnen)</n></h3>

<p>
Filtere nur dann wenn der schwarze Spieler keine Gewinnmöglichkeit mehr hat.
</p>

<p>
Normalerweise ist dies äquivalent zu folgender Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; nur schwarzer König</comment>
  (<cql>position:piececount</cql> &a; 1)
  <comment>; nur schwarzer König und schwarze Leichtfigur</comment>
  (<cql>position:piececount</cql> &a; 2 <cql>position:piececount</cql> &i; 1))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit <cql>:blackcannotwin</cql> nur dann, wenn Schwarz nur noch den König
besitzt, und in allen anderen Schachformen hat dieses Schlüsselwort keine
Bedeutung und ist immer erfolglos.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:blackcannotwin</keyword>)
</verb>

<p>
Filtere alle Positionen, in denen Schwarz (theoretisch) noch Gewinnmöglichkeiten hat.
</p>

<p>
Siehe auch: <cql>position:whitecannotwin</cql>.
</p>

<h3 id="position:btm">:btm&emsp;<n>(Schwarz am Zug)</n></h3>

<p>
Filtere nur wenn Schwarz am Zug ist.
</p>

<p>
Siehe auch: <cql>position:wtm</cql>.
</p>

<h3 id="position:check">:check&emsp;<n>(Schachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach. Dieses Schlüsselwort kann auch in
negierter Form &ndash; mit einem vorangestellten Ausrufungszeichen &ndash;
verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:check</keyword>)
</verb>

<p>
Keine Seite befindet sich im Schach.
</p>

<p>
In <nobr>CQL-S</nobr> ist optional ein nachfolgender Figurenbezeichner zugelassen (nicht
Standard-CQL). Nun filtert <keyword>position:check</keyword> nur dann, wenn das Schachgebot
mit dem Figurenbezeichner übereinstimmt. Beispiel:
</p>

<verb>
(position <keyword>position:check</keyword> [&Q;]?8)
</verb>

<p>
Eine weiße Dame auf der gegnerischen Grundreihe bietet Schach.
</p>

<p>
Siehe auch:
<cql>position:ischeck</cql>,
<cql>position:contactcheck</cql>,
<cql>position:doublecheck</cql>.
</p>

<h3 id="position:castling">:castling<extension/>&emsp;<n>(Rochade)</n></h3>

<p>
Dieses Schlüsselwort spezifiziert die Rochademöglichkeiten beider Seiten.
Es erwartet als Argument einen Figurenartbezeichner, wobei die Figurenarten
folgende Bedeutung haben:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">Weiß besitzt das Recht zur kurzen Rochade.</td>
    </tr>
    <tr>
      <td class="l"><expr>&Q;</expr></td>
      <td class="r">Weiß besitzt das Recht zur langen Rochade.</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Schwarz besitzt das Recht zur kurzen Rochade.</td>
    </tr>
    <tr>
      <td class="l"><expr>&q;</expr></td>
      <td class="r">Schwarz besitzt das Recht zur langen Rochade.</td>
    </tr>
  </table>
</dir>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:castling</keyword> &K;)
</verb>

<p>
Weiß hast das Recht zu kurzen Rochade.
</p>

<verb>
(position <keyword>position:castling</keyword> [&K;&Q;])
</verb>

<p>
Weiß has das Recht entweder für die kurze oder für die lange Rochade
(aber nicht für beide).
</p>

<verb>
(position <keyword>position:castling</keyword> &K; <keyword>position:castling</keyword> &Q;)
</verb>

<p>
Weiß hat das Recht für kurze und lange Rochade.
</p>

<p>
Siehe auch: <cql>position:iscastling</cql>,
</p>

<h3 id="position:contactcheck">:contactcheck<extension/>&emsp;<n>(Kontaktschachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach, und es ist ein Kontaktschachgebot
(kein Zwischensetzen einer Figur möglich, auch nicht theoretisch).
Dies beinhaltet Springerschachgebote sowie Doppelschachgebote.
</p>

<p>
Dies ist äquivalent zu:
</p>

<verbatim>
(position
  <cql>position:check</cql> <comment>; um Schlagschachpartien auszufiltern</comment>
  <cql>position:or</cql> (
    (position <cql>position:doublecheck</cql>)
    (position <cql>position:attackcount</cql> [&N;&P;] &k; 1 <cql>position:flipcolor</cql>)
    (position [&Q;&R;]d4 &k;[c4,e4,d3,d5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)
    (position [&Q;&B;]d4 &k;[c3,c5,e3,e5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)))
</verbatim>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:contactcheck</keyword>)
</verb>

<p>
Keine Seite befindet sich im Schach, oder aber es ist kein Kontaktschachgebot.
</p>

<p>
Es können mittels einem nachfolgenden Figurenbezeichner die schachbietenden Figuren
eingeschränkt werden. Beispiel:
</p>

<verb>
(position <keyword>position:contactcheck</keyword> &Q;)
</verb>

<p>
Eine weiße Dame steht benachbart zum gegnerischen König (ein Kontaktschachgebot).
</p>

<p>
Siehe auch:
<cql>position:iscontactcheck</cql>,
<cql>position:check</cql>,
<cql>position:doublecheck</cql>.
</p>

<h3 id="position:doublecheck">:doublecheck<extension/>&emsp;<n>(Doppelschachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach, und es ist ein Doppelschachgebot.
</p>

<p>
Tatsächlich ist dies eine Kurzschreibweise für:
</p>

<verbatim>
(position
  <cql>position:check</cql> <comment>; um Schlagschachpartien auszufiltern</comment>
  <cql>position:attackcount</cql> &A; &k; 2
  <cql>position:flipcolor</cql>)
</verbatim>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:doublecheck</keyword>)
</verb>

<p>
Filtere alle Positionen, in denen keine Seite ein Doppelschachgebot erhalten hat.
</p>

<p>
Es können mittels einem nachfolgenden Figurenbezeichner die schachbietenden Figuren
eingeschränkt werden. Beispiel:
</p>

<verb>
(position <keyword>position:doublecheck</keyword> [&R;&B;]
</verb>

<p>
Filtert alle Positionen, in denen eine weißer Läufer und ein weißer Turm zusammen
Schach bieten (wie in der "immergrünen" Partie).
</p>

<p>
Sollen auch die Felder der beiden Figuren spezifiziert werden, dann ist hier die
Verwendung von <cql>position:check</cql> angebracht:
</p>

<verbatim>
(position :and ((:check &R;d1) (:check &B;f5)))
</verbatim>

<p>
Siehe auch:
<cql>position:isdoublecheck</cql>,
<cql>position:check</cql>,
<cql>position:contactcheck</cql>.
</p>

<h3 id="position:endgame">:endgame<extension/>&emsp;<n>(Endspiel)</n></h3>

<p>
Die Position ist eine Endspielposition. Dieses Schlüsselwort ist äquivalent
zur folgenden Abfrage:
</p>

<verbatim>
  (position
    <cql>position:or</cql> (
      (position
        <cql>position:piececount</cql> [&Q;&q;] 0
        <cql>position:piececount</cql> [&R;&B;&N;] 0 3
        <cql>position:piececount</cql> [&r;&b;&n;] 0 3)
      (position
        <cql>position:piececount</cql> &Q; 1
        <cql>position:piececount</cql> &q; 1
        <cql>position:piececount</cql> [&R;&r;] 0
        <cql>position:piececount</cql> &I; 0 1
        <cql>position:piececount</cql> &i; 0 1)
      (position
        <cql>position:piececount</cql> &Q; 1
        <cql>position:piececount</cql> &R; 0
        <cql>position:piececount</cql> &I; 0 1
        <cql>position:piececount</cql> &q; 0
        <cql>position:power</cql> [&r;&b;&n;] 0 16
        <cql>position:flipcolor</cql>)))
</verbatim>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <cql>!position:endgame</cql>)
</verb>

<p>
Filtere alle Positionen, in denen keine Endspielstellung vorliegt.
</p>

<h3 id="position:fen">:fen<extension/></h3>

<p>
Die Position ist identisch zur beschriebenen Stellung im Argument. Dieses
Argument muß eine gültige <a href="FEN.html">FEN (Forsyth-Edwards-Notation)</a>
sein.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <keyword>position:fen</keyword> "rnbqkbnr/pppp1ppp/4p3/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2")
</verbatim>

<p>
Bezeichnet die Grundstellung des französischen Abspiels, die normalerweise
mit der Zugfolge 1.e4 e6 2.d4 d5 erreicht wird.
</p>

<p>
Siehe auch: <cql>position:line*</cql>.
</p>

<h3 id="position:fivefoldrepetition">:fivefoldrepetition<extension/>&emsp;<n>(Fünffache Stellungswiederholung)</n></h3>

<p>
Filtere die erste Position in der Hauptvariante, die zum fünften Mal in der
Partie wiederholt wurden, mit der gleichen Seite am Zug, und den gleichen
Rochade- und en-passant-Rechten. Diese Wiederholung muß nicht aufeinanderfolgen.
Dies stimmt mit der neuen FIDE-Regelung der
<a href="http://de.wikipedia.org/wiki/Stellungswiederholung">
Stellungswiederholung</a> überein.
</p>

<p>
Innerhalb von Untervarianten hat dieses Schlüsselwort keine Wirkung und ist
immer erfolglos.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:fivefoldrepetition</keyword>)
</verb>

<p>
Filtere nur Positionen, in denen keine fünffache Stellungswiederholung
aufgetreten ist. Soll keine Positionen mehr aufgefunden werden nachdem eine
fünffache Zugwiederholung stattgefunden hat, so wird dies mit
<cql>position:cut</cql> realisiert:
</p>

<verb>
(position <keyword>position:fivefoldrepetition</keyword> <cql>position:cut</cql>)
</verb>

<h3 id="position:gameisover">:gameisover<extension/></h3>

<p>
Dies ist eine Kurzschreibweise für:
</p>

<verbatim>
  <cql>position:or</cql> (
    (position <cql>position:mate</cql>)
    (position <cql>position:stalemate</cql>)
    (position <cql>position:losing</cql>)           <comment>; %::mc::VariantName(Antichess)%</comment>
    (position <cql>position:threechecks</cql>)      <comment>; %::mc::VariantName(ThreeCheck)%</comment>
    (position <cql>position:kingonthehill</cql>)    <comment>; %::mc::VariantName(KingOfTheHill)%</comment>
    (position <cql>!position:matingmaterial</cql>))
</verbatim>

<p>
Zu beachten ist das unerwartete Resultate erfolgen können, wenn die Suche
Untervarianten mit einschließt.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:gameisover</keyword>)
</verb>

<p>
Filtere alle Partien die in einer Stellung enden, die nicht mehr
weitergespielt werden kann.
</p>

<verb>
(position <keyword>!position:gameisover</keyword>)
</verb>

<p>
Filtert alle Positionen, die (aus Sicht der Schachregeln) noch weitergespielt
werden können.
</p>

<h3 id="position:halfmoveclock">:halfmoveclock<extension/>&emsp;<n>(Halbzugzähler)</n></h3>

<p>
Dieses Schlüsselwort filtert Positionen, in denen der Halbzugzähler innerhalb
der gegebenen <a href="CQL-Range-Specifiers.html">Bereichsangabe</a> liegt.
Innerhalb von Untervarianten hat dieses Schlüsselwort keine Wirkung und wird
immer erfüllt.
</p>

<p>
Halbzugzähler: Das ist die Anzahl der Halbzüge seit dem letzten Zug, in dem
ein Bauer zog oder eine Figur geschlagen wurde. Dieser Zähler entscheidet
auch, ob eine Seite ein Remis reklamieren kann aufgrund der 50-Züge-Regel.
</p>

<p>
Beispiel:
</p>

<verb>
(position <keyword>position:halfmoveclock</keyword> &lt;=30)
</verb>

<p>
Schließe alle Positionen aus, in denen in mehr als 30 Halbzügen (15 Züge
auf jeder Seite) kein Bauernzug erfolgte und auch kein Stein geschlagen
wurde.
</p>

<verb>
(position <keyword>position:halfmoveclock</keyword> 100 !<cql>position:terminal</cql>)
</verb>

<p>
Finde alle Positionen in denen die Seite am Zug aufgrund der 50-Züge-Regel Remis
hätte reklamieren könnte, es aber nicht tat.
</p>

<h3 id="position:initial">:initial&emsp;<n>(Startposition)</n></h3>

<p>
Dies ist die erste Position in der Partie (vor dem ersten Zug). Tatsächlich ist
dies nur eine andere Schreibweise für:
</p>

<verb>
<cql>position:halfmovenumber</cql> 0
</verb>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:initial</keyword>)
</verb>

<p>
Filtere alle Positionen außer der ersten Position in der Partie.
</p>

<p>
Siehe auch: <cql>position:halfmovenumber</cql>, <cql>position:terminal</cql>.
</p>

<h3 id="position:insidevariation">:insidevariation<extension/>&emsp;<n>(Innerhalb einer Untervariante)</n></h3>

<p>
Dieses Schlüsselwort filtert genau dann, wenn eine Position in einer Untervariante
aufgefunden wird. Dies kann niemals geschehen, wenn nicht mit <cql>position:variations</cql>
die Suche in Untervarianten zugelassen wird.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:insidevariation</keyword>)
</verb>

<p>
Diese Position wird nicht in einer Untervariante vorgefunden.
</p>

<p>
Siehe auch: <cql>position:variations</cql>.
</p>

<h3 id="position:kingonthehill">:kingonthehill<extension/>&emsp;<n>(König auf dem Hügel)</n></h3>

<p>
Dieses Schlüsselwort hat nur in der Schachform %::mc::VariantName(KingOfTheHill)% eine
Bedeutung und filtert alle Endstellungen, in denen ein König eines der Zentralfelder
<nobr>(d4,e4,d5,e5)</nobr> erreicht hat. In allen anderen Schachformen wird dieses Schlüsselwort
niemals erfüllt.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden.
</p>

<p>
Anmerkung: Der offizielle Name dieser Schachform (im Englischen) ist zwar King-of-the-Hill,
nach Ansicht des Autors sollte sie aber King-on-the-Hill benannt werden, denn das Spiel endet
sobald eben ein König den Hügel erreichte.
</p>

<h3 id="position:losing">:losing<extension/>&emsp;<n>(Verlust)</n></h3>

<p>
Filtere nur Endstellungen, in denen eine der Seiten alle Figuren verlor.
Dies ist nur in der Schachformen %::mc::VariantName(Antichess)% möglich.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:losing</keyword>)
</verb>

<p>
Filtere nur Stellungen, in denen keine der Seiten alle Figuren verlor.
</p>

<h3 id="position:mate">:mate&emsp;<n>(Schachmatt)</n></h3>

<p>
Filtere nur dann, wenn es eine Mattstellung ist.
</p>

<annotation>
Wenn nach Mattstellungen gesucht wird, dann sollte stets auch dieses
Schlüsselwort mitverwendet werden auch wenn es aufgrund anderer
Bedingungen überflüssig erscheint, denn es beschleunigt die Suche (nur
Endstellungen werden geprüft).
</annotation>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:mate</keyword>)
</verb>

<p>
Schließe alle Mattstellungen aus.
</p>

<p>
Ein weiteres Beispiel:
</p>

<verb>
(position <keyword>position:mate</keyword> <cql>position:movenumber</cql> 1 20)
</verb>

<p>
Filtere nur dann wenn eine Seite in den ersten 20 Zügen mattgesetzt wurde.
</p>

<p>
Siehe auch: <cql>position:ismate</cql>,
</p>

<h3 id="position:matingmaterial">:matingmaterial<extension/>&emsp;<n>(Mattmaterial)</n></h3>

<p>
Filtere Positionen, in denen einer der Spieler noch über Mattmaterial verfügt.
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit <cql>:matingmaterial</cql> nur dann, solange nicht nur noch Könige
auf dem Schachbrett sind, und in allen anderen Schachformen (außer
%::mc::VariantName(ThreeCheck)% und %::mc::VariantName(Normal)%)
hat dieses Schlüsselwort keine Bedeutung und ist immer erfolgreich.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:matingmaterial</keyword>)
</verb>

<p>
Filtere Positionen, in denen keiner der Spieler noch über Mattmaterial verfügt.
Normalerweise ist dies äquivalent zur folgenden Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; König gegen König</comment>
  (position <cql>position:piececount</cql> &U; 2)
  <comment>; König und Leichtfigur gegen König</comment>
  (position <cql>position:piececount</cql> &U; 3 <cql>position:piececount</cql> [&I;&i;] 1)
  <comment>; König and Läufer gegen König und Läufer,</comment>
  <comment>; beide Läufer entweder weiß- oder schwarzfeldrig</comment>
  (position <cql>position:piececount</cql> &U; 4 <cql>position:piececount</cql> [&B;&b;]&L;? 2)
  (position <cql>position:piececount</cql> &U; 4 <cql>position:piececount</cql> [&B;&b;]&D;? 2))
</verbatim>

<p>
Die negierte Form ist in allen anderen Schachformen als %::mc::VariantName(ThreeCheck)%
immer erfolglos.
</p>

<h3 id="position:mustcapture">:mustcapture<extension/>&emsp;<n>(Schlagzwang)</n></h3>

<p>
In dieser Stellung ist die Seite am Zug verpflichtet eine Figur zu schlagen
(was auch heißt, daß in dieser Stellung eine Figur geschlagen werden kann). Dieses
Schlüsselwort ist für die Schachform %::mc::VariantName(Antichess)% vorgesehen,
und wird in anderen Schachform niemals erfüllt.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:mustcapture</keyword>)
</verb>

<p>
In dieser Stellung ist die Seite am Zug nicht verpflichtet eine Figur zu schlagen
(was auch heißt, das keine geschlagen werden kann). Diese Bedingung wird für alle anderen
Schachformen (als %::mc::VariantName(Antichess)%) immer erfüllt.
</p>

<p>
Siehe auch: <cql>position:mustcapture</cql>,
</p>

<h3 id="position:nocheck">:nocheck&emsp;<n>(Kein Schachgebot)</n></h3>

<p>
Dieses Schlüsselwort ist veraltet und sollte nicht mehr verwendet werden, es wird
nur aus Kompatibilitätsgründen zu CQL unterstützt. Es hat die gleiche Bedeutung
wie <cql>!position:check</cql>.
</p>

<h3 id="position:stalemate">:stalemate&emsp;<n>(Patt)</n></h3>

<p>
Filtert nur Pattstellungen.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:stalemate</keyword>)
</verb>

<p>
Filtere nur Positionen in denen niemand patt ist.
</p>

<p>
Siehe auch: <cql>position:isstalemate</cql>,
</p>

<h3 id="position:terminal">:terminal<extension/>&emsp;<n>(Endstellung)</n></h3>

<p>
Dies ist die letzte Position in der Partie (nach dem letzten Zug). Tatsächlich ist
dies nur eine andere Schreibweise für:
</p>

<verb>
<cql>position:halfmovenumber</cql> end
</verb>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:terminal</keyword>)
</verb>

<p>
Dies ist nicht die letzte Position in der Partie.
</p>

<p>
Siehe auch: <cql>position:halfmovenumber</cql>,<cql>position:initial</cql>.
</p>

<h3 id="position:threefoldrepetition">:threefoldrepetition<extension/>&emsp;<n>(Dreifache Stellungswiederholung)</n></h3>

<p>
Filtere die erste Position in der Hauptvariante, die zum dritten Mal in der
Partie wiederholt wurden, mit der gleichen Seite am Zug, und den gleichen
Rochade- und en-passant-Rechten. Diese Wiederholung muß nicht aufeinanderfolgen.
Dies stimmt mit der alten FIDE-Regelung der
<a href="http://de.wikipedia.org/wiki/Stellungswiederholung">
Stellungswiederholung</a> überein.
</p>

<p>
Innerhalb von Untervarianten hat dieses Schlüsselwort keine Wirkung und ist
immer erfolglos.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:threefoldrepetition</keyword>)
</verb>

<p>
Filtere nur Positionen, in denen keine dreifache Stellungswiederholung
aufgetreten ist. Soll keine Positionen mehr aufgefunden werden nachdem eine
dreifache Zugwiederholung stattgefunden hat, so wird dies mit
<cql>position:cut</cql> realisiert:
</p>

<verb>
(position <keyword>position:threefoldrepetition</keyword> <cql>position:cut</cql>)
</verb>

<h3 id="position:threechecks">:threechecks<extension/>&emsp;<n>(Drittes Schach)</n></h3>

<p>
Dieses Schlüsselwort hat nur in der Schachform %::mc::VariantName(ThreeCheck)% eine
Bedutung und filtert alle Endstellungen, in denen einem König zum dritten Mal Schach
geboten wurde. In allen anderen Schachformen wird dieses Schlüsselwort niemals erfüllt.
Somit ist dieses Schlüsselwort nicht identisch zu
</p>

<verb>
<cql>position:checkcount</cql> 3 : &lt;=2 <cql>position:flipcolor</cql>
</verb>

<p>
denn obiger Ausdruck kann auch in anderen Schachformen erfüllt werden.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden.
</p>

<h3 id="position:variations">:variations&emsp;<n>(Varianten)</n></h3>

<p>
Ziehe die Untervarianten in die Suche mit ein. Ohne diese Angabe werden
die Untervarianten bei der Suche ausgelassen.
</p>

<h3 id="position:variationsonly">:variationsonly&emsp;<n>(Nur die Varianten)</n></h3>

<p>
Suche nur in den Untervarianten, nicht in der Hauptvariante.
</p>

<h3 id="position:whitecannotwin">:whitecannotwin<extension/>&emsp;<n>(Weiß kann nicht gewinnen)</n></h3>

<p>
Filtert nur dann wenn Weiß keine Gewinnmöglichkeit mehr hat.
</p>

<p>
Normalerweise ist dies äquivalent zur folgenden Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; nur weißer König</comment>
  (position <cql>position:piececount</cql> &A; 1)
  <comment>; nur weißer König und weiße Leichtfigur</comment>
  (position <cql>position:piececount</cql> &A; 2 <cql>position:piececount</cql> &I; 1))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit <cql>:whitecannotwin</cql> nur dann, wenn Weiß nur noch den König
besitzt, und in allen anderen Schachformen hat dieses Schlüsselwort keine
Bedeutung und ist immer erfolglos.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:whitecannotwin</keyword>)
</verb>

<p>
Filtere alle Positionen, in denen Weiß noch Gewinnmöglichkeiten hat
(wenn vielleicht auch nur theoretisch).
</p>

<p>
Siehe auch: <cql>position:blackcannotwin</cql>.
</p>

<h3 id="position:wtm">:wtm&emsp;<n>(Weiß am Zug)</n></h3>

<p>
Filtert nur wenn Weiß am Zug ist.
</p>

<!-- ############################################################################## -->
<h2 id="transform">Transformierende Schlüsselwörter</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:flip">:flip</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:inside">:inside</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shift">:shift</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td></tr>
</table>

<h3 id="position:flip">:flip&emsp;<n>(Spiegelung)</n></h3>

<p>
Dies ist identisch zu <cql>position:flipdihedral</cql> (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipcolor">:flipcolor&emsp;<n>(Farbwechsel)</n></h3>

<p>
Diese Farbwechseltransformation bewirkt zwei Transformationen: zum einen eine
Spiegelung an der vertikalen Halbierungslinie des Schachbretts
(<see/> <a href="CQL-Transformations.html">Transformationen</a>),
zum anderen einen Austausch der Farben; aus Weiß wird Schwarz, und aus Schwarz
wird Weiß. Diese Farbwechseltransformation wirkt sich nicht auf die Suchliste
<expr>(match</expr> <expr>...)</expr> aus (dafür gibt es
<cql>match:eithercolor</cql>). <cql>flipcolor</cql> darf nicht verwendet werden
wenn in der zugehörigen Suchliste <cql>match:eithercolor</cql> verwendet wird
(denn <cql>match:eithercolor</cql> bewirkt bereits eine Farbwechseltransformation
in den Positionslisten).
</p>

<h3 id="position:flipdiagonal">:flipdiagonal&emsp;<n>(Diagonale Spiegelung)</n></h3>

<p>
Die diagonale und gegendiagonale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipdihedral">:flipdihedral&emsp;<n>(Diedrische Transformation)</n></h3>

<p>
Die diedrische Transformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:fliphorizontal">:fliphorizontal&emsp;<n>(Horizontale Spiegelung)</n></h3>

<p>
Die horizontale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipvertical">:flipvertical&emsp;<n>(Vertikale Spiegelung)</n></h3>

<p>
Die vertikale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:inside">:inside<extension/>&emsp;<n>(Innerhalb)</n></h3>

<p>
Dieses Schlüsselwort filtert Translationen, bei denen die involvierten Figuren
innerhalb einer bestimmten Region auf dem Schachbrett verbleiben. Es werden
zwei Argumente erwartet, ein Figurenbezeichner und ein Felderbezeichner.
Jegliche Translation beinflußt nur das erste Argument. Eine Translation wird
von der <cql>:inside</cql>-Beschränkung gefiltert, wenn mindestens eine Figur,
die mit dem ersten Argument bezeichnet wird (wobei die Transformation mit
einbezogen ist), auf einem Feld steht, das vom zweiten Argument bezeichnet wird.
</p>

<p>
Die nachfolgenden Beispiele dienen nur zur Demonstration, zur
Trippelbauernsuche sollte das Schlüsselwort <cql>position:pawncount</cql>
eingesetzt werden.
</p>

<p>
Wir formulieren die folgende Abfrage um Trippelbauern aufzufinden:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Um Trippelbauern auf der Hauptdiagonalen (a1-h8) aufzufinden, erweitern
wir diese Abfrage:
</p>

<verbatim>
(position
  <keyword>position:inside</keyword> &P;[b2-7] [b2,c3,d4,e5,f6,g7]
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<h3 id="position:shift">:shift&emsp;<n>(Translation)</n></h3>

<p>
Die Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftdiagonal">:shiftdiagonal&emsp;<n>(Diagonale Translation)</n></h3>

<p>
Die hauptdiagonale und gegendiagonale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shifthorizontal">:shifthorizontal&emsp;<n>(Horizontale Translation)</n></h3>

<p>
Die horizontale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftmaindiagonal">:shiftmaindiagonal&emsp;<n>(Hauptdiagonale Translation)</n></h3>

<p>
Die hauptdiagonale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftoffdiagonal">:shiftoffdiagonal&emsp;<n>(Gegendiagonale Translation)</n></h3>

<p>
Die gegendiagonale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftvertical">:shiftvertical&emsp;<n>(Vertikale Translation)</n></h3>

<p>
Die vertikale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<!-- ############################################################################## -->
<h2 id="piece">Schlüsselwörter für die Figurenanalyse</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:goodbishop">:goodbishop</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:opposition">:opposition</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pawncount">:pawncount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pawncountdifference">:pawncountdifference</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:perpendicular">:perpendicular</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:piececount">:piececount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:piececountdifference">:piececountdifference</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:power">:power</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ray">:ray</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td></tr>
</table>

<h3 id="position:attackcount">:attackcount&emsp;<n>(Angriffszähler)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argumente zwei Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Der erste
ist der Figurenbezeichner der attackierenden Figuren, der zweite ist
der Figurenbezeichner der angegriffenen Figuren. Ein Angriff einer Figur
auf ein Feld liegt vor, wenn die bezeichnete Figur auf dieses Feld ziehen kann.
<cql>:attackcount</cql> zählt alle gültigen Züge (Angriffe), deren Ausgangsfeld
vom ersten Argument bezeichnet wird, und deren Zielfeld vom zweiten Argument
bezeichnet wird.
</p>

<p>
Das Schlüsselwort <cql>:attackcount</cql> filtert eine Position, wenn die
Gesamtzahl aller gültigen Angriffe in dieser Position innerhalb der gegebenen
Bereichsangabe liegt.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; &k; 2)
</verb>

<p>
Filtert jede Position mit einem Doppelangriff weißer Figuren auf den
schwarzen König (jedoch sollte für diese Abfrage
<cql>position:doublecheck</cql> in Verbindung mit <cql>position:btm</cql>
vorgezogen werden).
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; &k; 2 <cql>position:flipcolor</cql>)
</verb>

<p>
Filtert jede Position mit einem Doppelangriff auf einen König
(auch hier sollte <cql>position:doublecheck</cql> vorgezogen werden).
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; .h3 1)
</verb>

<p>
Filtert eine Position, in der genau eine weiße Figur auf das freie Feld h3
ziehen kann.
</p>

<verb>
(position <keyword>position:attackcount</keyword> [&R;&B;][a-c8] ??1 5 9)
</verb>

<p>
Filtert eine Position, in der die Anzahl der Möglichkeiten, daß ein weißer
Turm oder ein weißer Läufer auf den Feldern a8, b8, oder c8 auf ein Feld
der ersten Reihe ziehen kann, zwischen 5 und 9 liegt (inklusive).
</p>

<verb>
(position <keyword>position:attackcount</keyword> &n; [&K;&R;&Q;] &gt;=3)
</verb>

<p>
Filtert eine Position, in der es genau drei Möglichkeiten gibt, daß ein
schwarzer Springer den weißen König oder eine weiße Schwerfigur attackiert.
</p>

<verb>
(position <keyword>position:attackcount</keyword> [&K;&k;] ? 0)
</verb>

<p>
Beide Könige können in dieser Position nicht ziehen.
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; ??8 0)
</verb>

<p>
Keine weiße Figur kann in dieser Position auf die schwarze Grundreihe ziehen.
</p>

<verb>
(position <keyword>position:attackcount</keyword> &U; ? 1)
</verb>

<p>
In dieser Position gibt es nur einen möglichen Zug. Allerdings
sollte zu diesem Zweck <cql>position:forced</cql> verwendet werden.
</p>

<verb>
(position <keyword>position:attackcount</keyword> [&N;&n;][+] . 0)
</verb>

<p>
In dieser Position kann kein Springer eingesetzt werden
(%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%).
</p>

<h3 id="position:goodbishop">:goodbishop<extension/>&emsp;<n>(Guter Läufer?)</n></h3>

<p>
Filtert Positionen mit mindestens einem Läufer, der als <i>gut</i> bzw. als
<i>schlecht</i> eingestuft wurde. <cql>:goodbishop</cql> erwartet als Argumente
zuerst einen Figurenbezeichner, bei dem nur Läufer als Figuren erlaubt sind. Dann
folgen entweder zwei <a href="CQL-Range-Specifiers.html">Bereichsangaben</a>
oder zwei <a href="CQL-Percentage-Specifiers.html">prozentuale Angaben</a>.
Die erste Bereichsangabe ist die Anzahl bzw. der prozentuale Anteil
der gegnerischen Bauern, die von diesem Läufer angreifbar sind &ndash; wobei
sich die prozentuale Angabe auf die Anzahl der gegnerischen Bauern bezieht &ndash;
und die zweite Bereichsangabe ist die Anzahl bzw. der prozentuale Anteil der
eigenen Bauern, die den Läufer nicht blockieren &ndash; wobei sich hier die
prozentuale Angabe auf die Anzahl eigener Bauern bezieht. Alle Bereichsangaben
werden für jeden gefundenen Läufer einzeln geprüft. Die beiden Bereichsangaben
müssen durch das Trennzeichen <expr>:</expr> abgetrennt werden.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:goodbishop</keyword> &B;[&D;?] &gt;50% : &gt;50%)
</verb>

<p>
Weiß hat mindestens einen <i>guten</i> schwarzfeldrigen Läufer, denn mehr
als 50% der gegnerischen Bauern stehen auf einem schwarzen Feld (und sind
somit für ihn angreifbar), und mehr als 50% der eigenen Bauern stehen
auf einem weißen Feld (und blockieren somit nicht diesen Läufer).
</p>

<verb>
(position <keyword>position:goodbishop</keyword> &B; &gt;50% : &gt;50%)
</verb>

<p>
Weiß hat mindestens einen <i>guten</i> Läufer.
</p>

<verb>
(position <keyword>position:goodbishop</keyword> [&B;&b;] &lt;=30% : &lt;=20%)
</verb>

<p>
Eine der Parteien hat einen sehr <i>schlechten</i> Läufer.
</p>

<h3 id="position:opposition">:opposition<extension/>&emsp;<n>(Opposition)</n></h3>

<p>
Dieses Schlüsselwort filtert alle Positionen, in denen der König in Opposition
zum anderen König steht. Als optionales Argument kann ein Figurenartbezeichner
mitgegeben werden, wobei die Figurenarten folgende Bedeutung haben:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">Der weiße König steht in Opposition zum schwarzen König.</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Der schwarze König steht in Opposition zum weißen König.</td>
    </tr>
  </table>
</dir>

<p>
Ist keine Figurenart gegeben, dann wird berechnet, ob der König der Seite mit dem
Zugrecht in Opposition zum anderen König steht.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden, dann werden die Positionen gefiltert,
in denen der König nicht in Oppositin steht.
</p>

<p>
Die Anwendung dieses Schlüsselwortes ist nur in bestimmten Endspielsituationen
sinnvoll, um zu überprüfen, ob z.B. der König wieder in Opposition ist. Es wird
mit einer rein formalen Berechnung über den Abstand der Könige unter Einbeziehung
des Zugrechts über die Opposition entschieden. Andere Figuren auf dem Brett, selbst
Schachgebote, werden nicht in dieser Berechnung berücksichtigt. So würde das
folgende Beispiel sogar bereits die Grundstellung filtern:
</p>

<verb>
(position <keyword>position:opposition</keyword> &K;)
</verb>

<h3 id="position:pawncount">:pawncount<extension/>&emsp;<n>(Bauernzählung)</n></h3>

<p>
<cql>:pawncount</cql> dient zur Zählung von Bauernstrukturen, bzw. von
Bauerneigenschaften. Das erste Argument ist ein Figurenbezeichner, der nur
Bauern enthalten darf, gefolgt von einer bindestrich-separierten Aufzählung
von Eigenschaften, und als letztes Argument wird entweder eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> oder eine
<a href="CQL-Percentage-Specifiers.html">prozentuale Angabe</a>
erwartet. Die prozentuale Angabe bezieht sich immer auf die gesamte
Anzahl der Bauern auf dem Brett, die die Farbe der Bauern im
Figurenbezeichner besitzen. Dieses Schlüsselwort filtert genau dann,
wenn die Zählung von Bauernvorkommen mit allen der genannten Eigenschaften
innerhalb des gegebenen Bereichs liegt.
</p>

<p>
Die unterstützen Bauerneigenschaften bzw. Bauernstruktureigenschaften sind:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>single</expr></td>
      <td class="r">Einzelbauern: Zähle alle Bauern einer Farbe.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>single!</expr></td>
      <td class="r">Einzelbauern: Zähle alle Linien, auf denen nur ein Bauer
                    einer Farbe steht (ohne die gegnerische Farbe zu beachten).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>double</expr></td>
      <td class="r">Doppelbauern: Zähle alle Bauern einer Farbe auf einer Linie,
                    wenn sich mindestens zwei Bauern dieser Farbe auf dieser
                    Linie befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>double!</expr></td>
      <td class="r">Doppelbauern (exakt): Zähle zwei Bauern einer Farbe auf einer Linie,
                    wenn sich dort genau zwei Bauern dieser Farbe auf dieser
                    Linie befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple</expr></td>
      <td class="r">Trippelbauern: Zähle alle Bauern einer Farbe auf einer Linie,
                    wenn sich mindestens zwei Bauern dieser Farbe auf dieser
                    Linie befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple!</expr></td>
      <td class="r">Trippelbauern (exakt): Zähle drei Bauern einer Farbe auf einer Linie,
                    wenn sich dort genau drei Bauern dieser Farbe auf dieser
                    Linie befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple(n)</expr></td>
      <td class="r">Zähle alle Bauern einer Farbe auf einer Linie,
                    wenn sich mindestens n Bauern dieser Farbe auf dieser
                    Linie befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple!(n)</expr></td>
      <td class="r">Zähle n Bauern einer Farbe auf einer Linie,
                    wenn sich dort genau n Bauern dieser Farbe auf dieser
                    Linie befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>uno</expr></td>
      <td class="r">Einzelbauern: Zähle alle Bauern einer Farbe.
                    (dies ist äquivalent zu <expr>single</expr>).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>uno!</expr></td>
      <td class="r">Einzelbauern: Zähle alle Reihen, auf denen nur ein Bauer
                    einer Farbe steht (ohne die gegnerische Farbe zu beachten).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>duo</expr></td>
      <td class="r">Bauernduo: Zähle alle Bauern einer Farbe auf einer Reihe,
                    wenn sich mindestens zwei Bauern dieser Farbe auf dieser
                    Reihe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>duo!</expr></td>
      <td class="r">Bauernduo (exakt): Zähle zwei Bauern einer Farbe auf einer Reihe,
                    wenn sich dort genau zwei Bauern dieser Farbe auf dieser
                    Reihe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>trio</expr></td>
      <td class="r">Bauerntrio: Zähle alle Bauern einer Farbe auf einer Reihe,
                    wenn sich mindestens drei Bauern dieser Farbe auf dieser
                    Reihe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>trio!</expr></td>
      <td class="r">Bauerntrio (exakt): Zähle drei Bauern einer Farbe auf einer Reihe,
                    wenn sich dort genau drei Bauern dieser Farbe auf dieser
                    Reihe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart</expr></td>
      <td class="r">Bauernquart: Zähle alle Bauern einer Farbe auf einer Reihe,
                    wenn sich mindestens vier Bauern dieser Farbe auf dieser
                    Reihe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart!</expr></td>
      <td class="r">Bauernquart (exakt): eZähle vier Bauern einer Farbe auf einer Reihe,
                    wenn sich dort genau vier Bauern dieser Farbe auf dieser
                    Reihe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart(n)</expr></td>
      <td class="r">Bauern verbunden in einer Reihe: es werden alle verbundenen Bauern
                    auf einer Reihe gezählt, wenn mindestens n Bauern zu diesem Verbund
                    gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart!(n)</expr></td>
      <td class="r">Bauern verbunden in einer Reihe (exakt): es werden alle
                    verbundenen Bauern auf einer Reihe gezählt, wenn genau n
                    Bauern zu diesem Verbund gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>connected</expr></td>
      <td class="r">Verbundene Bauern: es werden alle Bauern gezählt, die einen
                    Bauern der gleichen Farbe auf einer benachbarten Linie haben.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>integrated</expr></td>
      <td class="r">Integrierte Bauern: es werden alle Bauern gezählt, die
                    auf allen Nachbarslinien Bauern der gleichen Farbe
                    haben.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>isolated</expr></td>
      <td class="r">Isolierte Bauern (Isolani): es werden alle Bauern gezählt,
                    die keinen Bauern gleicher Farbe auf einer benachbarten
                    Linie haben.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>halfisolated</expr></td>
      <td class="r">Halb-isolierte Bauern: es werden alle Bauern gezählt,
                    die auf einer benachbarten Linie mindstens einen
                    gleichfarbigen Bauern haben, aber keinen auf der anderen
                    benachbarten Linie. Ein Randbauer kann niemals
                    halb-isoliert sein.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>defended</expr></td>
      <td class="r">Verteidigte Bauern: es werden alle Bauern gezählt, die von
                    einem Bauern der gleichen Farbe gedeckt werden (auch wenn
                    sie nicht angegriffen sind).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>defender</expr></td>
      <td class="r">Verteidigende Bauern: es werden alle Bauern gezählt, die
                    einen Bauern der gleichen Farbe decken (auch wenn der
                    gedeckte Bauer nicht angegriffen ist).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained</expr></td>
      <td class="r">Bauernkette: es werden alle Bauern gezählt, die sich mit
                    gleichfarbigen Bauern auf einer Schräge befinden (sie
                    sind verbunden, und bis auf den hintersten sind alle
                    gedeckt).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained(n)</expr></td>
      <td class="r">Bauernkette: es werden alle Bauern gezählt, die sich mit
                    gleichfarbigen Bauern auf einer Schräge befinden (sie
                    sind verbunden, und bis auf den hintersten sind alle
                    gedeckt), aber nur wenn sich in diesem Verbund mindestens
                    n Bauern befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained!(n)</expr></td>
      <td class="r">Bauernkette: es werden alle Bauern gezählt, die sich mit
                    gleichfarbigen Bauern auf einer Schräge befinden (sie
                    sind verbunden, und bis auf den hintersten sind alle
                    gedeckt), aber  nur wenn sich in diesem Verbund genau
                    n Bauern befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>passed</expr></td>
      <td class="r">Freibauern: es werden alle Bauern gezählt, die keinen
                    gegnerischen Bauer auf der gleichen Linie vor sich haben,
                    und von keinem gegnerischen Bauern auf einer benachbarten
                    Linie gestoppt werden können.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>candidate</expr></td>
      <td class="r">Kandidaten: es werden alle Bauern gezählt, die keinen
                    gegnerischen Bauer auf der gleichen Linie vor sich haben,
                    und wenn die Anzahl der gleichfarbigen Bauern seitlich
                    des Bauern bzw. hinter dem Bauern auf benachbarten Linien
                    mindestens so groß ist wie die Anzahl der andersfarbigen
                    Bauern auf den benachbarten Linien in der Vowärtsrichtung
                    (somit ein Kanditat für einen Freibauern). Freibauern
                    (d.h. Bauern die keinen andersfarbigen Bauern auf den
                    Nachbarslinien begegnen) werden auch als Kandidat gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>candidate!</expr></td>
      <td class="r">Kandidaten: Ein Kandidat für einen Freibauern, der jedoch
                    noch kein Freibauer ist.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>blocked</expr></td>
      <td class="r">Blockierte Bauern: zählt alle Bauern, denen auf der gleichen
                    Linie ein gegnerischer Bauer gegenübersteht.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>blocked!</expr></td>
      <td class="r">Blockierte Bauern (unmittelbar): zählt alle Bauern, denen
                    unmittelbar ein Bauer gegenübersteht.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>behind</expr></td>
      <td class="r">Bauern hinter dem Feind: zählt alle Bauern, die hinter
                    dem hintersten gegenerischen Bauer auf der gleichen Linie
                    stehen.  Z.B. kann ein weißer Bauer c7 hinter einem schwarzen
                    Bauer c5 stehen, wenn auch entfernt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>behind!</expr></td>
      <td class="r">Bauern unmittelbar hinter dem Feind: zählt alle Bauern, die
                    unmittelbar hinter dem hintersten gegenerischen Bauer auf der
                    gleichen Linie stehen. Z.B. kann ein weißer Bauer c7 unmittelbar
                    hinter einem schwarzen Bauer c6 stehen.</td>
    </tr>
    </tr>
      <td class="l" valign="top"><expr>stoppable</expr></td>
      <td class="r">Stoppbare Bauern: alle Bauern, die am Weiterrücken bis
                    zur gegnerischen Grundreihe von einem gegnerischen Bauern
                    in einer benachbarten Linie gehindert werden.</td>
    </tr>
    </tr>
      <td class="l" valign="top"><expr>stopped</expr></td>
      <td class="r">Gestoppte Bauern: alle Bauern, die am Weiterrücken von
                    einem gegnerischen Bauern, der in einer benachbarten Reihe
                    einer benachbarten Linie steht, gehindert werden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>backward</expr></td>
      <td class="r">Rückständige Bauern: alle Bauern, deren benachbarte Bauern
                    gleicher Farbe zu weit vorgerückt sind, um ihn decken zu
                    können. Isolierte Bauern sind niemals rückständig.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>advanced</expr></td>
      <td class="r">Vorgerückte Bauern: alle Bauern, die bereits in der gegnerischen
                    Hälfte stehen.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive</expr></td>
      <td class="r">Hintereinanderstehende Bauern: alle Bauern gleicher
                    Farbe, die auf einer Linie direkt hintereinander stehen,
                    werden gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive(n)</expr></td>
      <td class="r">Hintereinanderstehende Bauern: mindestens n Bauern gleicher
                    Farbe, die auf einer Linie direkt hintereinander stehen,
                    werden gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive!(n)</expr></td>
      <td class="r">Hintereinanderstehende Bauern: genau n Bauern gleicher
                    Farbe, die auf einer Linie direkt hintereinander stehen,
                    werden gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>inside</expr></td>
      <td class="r">Einholbare Bauern: zählt die Bauern, die sich noch innerhalb
                    der Reichweite des gegnerischen Königs befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>symmetrical</expr></td>
      <td class="r">Symmetrische Bauernstruktur: zählt die Bauern, auf deren Linie
                    sich die gleiche Anzahl gegnerischer Bauern befindet.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>mirrored</expr></td>
      <td class="r">Gespiegelte Bauernstruktur: zählt alle Bauern,
                    auf deren Linie alle gegnerischen Bauern auf horizontal
                    gespiegelten Feldern stehen.</td>
    </tr>
  </table>
</box>

<p>
Es muss mindestens eine dieser Bauerneigenschaften verwendet werden.
</p>

<p>
Alle Bauerneigenschaften können auch mit einem vorangestellten Ausrufungszeichen
negiert werden, dazu Beispiele:
</p>

<verb>
<keyword>position:pawncount</keyword> &P; !blocked &gt;50%
</verb>

<p>
Mehr als 50% der weißen Bauern stehen keine gegnerischen Bauern auf der gleichen Linie
gegenüber.
</p>

<verb>
<keyword>position:pawncount</keyword> &P; !blocked! &gt;50%
</verb>

<p>
Mehr als 50% der weißen Bauern stehen keine gegnerischen Bauern auf der gleichen Linie
unmittelbar gegenüber.
</p>

<verb>
<keyword>position:pawncount</keyword> &P; !inside-passed &gt;0
</verb>

<p>
Mindestens ein Freibauer ist nicht mehr innerhalb der Reichweite des gegnerischen
Königs.
</p>

<p>
Bemerkung: Das Attribut <expr>passed</expr> ist nur eine Kurzschreibweise:
</p>

<dir>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l"><expr>passed</expr></td>
      <td class="m">=</td>
      <td class="r"><expr>!blocked-!stoppable</expr></td>
    </tr>
  </table>
</dir>

<p>
Jedoch ist <expr>!passed</expr> keine Kurzschreibweise.
</p>

<p>
Bemerkung: Das Attribut <expr>candidate!</expr> ist nur eine Kurzschreibweise:
</p>

<dir>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l"><expr>candidate!</expr></td>
      <td class="m">=</td>
      <td class="r"><expr>candidate-!passed</expr></td>
    </tr>
  </table>
</dir>

<p>
Die folgenden Attribute, die ebenfalls mit einem vorangestellten Ausrufungszeichen
negiert werden können, schränken die Sichtweise auf die Bauern ein:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>forefront</expr></td>
      <td class="r">Vorhut: nur die vordersten Bauern auf einer Linie
                    werden untersucht.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>rear</expr></td>
      <td class="r">Nachhut: nur die hintersten Bauern auf einer Linie
                    werden untersucht.</td>
    </tr>
  </table>
</box>

<p>
Die Position von <expr>forefront</expr> bzw. <expr>rear</expr> innerhalb der
Liste der Eigenschaften beeinflußt, für welche Attribute die Sichtweise
eingeschränkt wird. Beispiel:
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] double!-forefront-duo &gt;0)
</verb>

<p>
Dies findet nebeneinanderstehende Doppelbauern gleicher Farbe auf, wobei sie
auf den gleichen Reihen stehen müssen. <expr>forefront</expr> muß nach
<expr>double!</expr> verwendet werden, ansonsten ist kein Doppelbauer
auffindbar (tatsächlich meldet die Applikation dann einen Fehler). Die
Reihenfolge zu <expr>duo</expr> spielt hier keine Rolle.
</p>

<p>
Die unterstützen Attribute für die Modifikation der Zählweise sind:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>islands</expr></td>
      <td class="r">Bauerninseln: zähle alle Bauerninseln (nicht die Anzahl der
                    Bauern, die zu den Inseln gehören). Eine Bauerninsel besteht
                    aus einem Bauernverbund gleicher Farbe, die jeweils alle auf
                    benachbarten Linien stehen. Zwischen gleichfarbigen Inseln
                    kann sich also kein Bauer gleicher Farbe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>islands(n)</expr></td>
      <td class="r">Bauerninseln: zähle alle Bauerninseln (nicht die Anzahl der
                    Bauern, die zu den Inseln gehören). Eine Bauerninsel besteht
                    aus einem Bauernverbund gleicher Farbe, die jeweils alle auf
                    benachbarten Linien stehen. Zwischen gleichfarbigen Inseln
                    kann sich also kein Bauer gleicher Farbe befinden. Es werden
                    jedoch nur die Inseln gezählt, zu denen jeweils mindestens
                    n Bauern gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>islands!(n)</expr></td>
      <td class="r">Bauerninseln: zähle alle Bauerninseln (nicht die Anzahl der
                    Bauern, die zu den Inseln gehören). Eine Bauerninsel besteht
                    aus einem Bauernverbund gleicher Farbe, die jeweils alle auf
                    benachbarten Linien stehen. Zwischen gleichfarbigen Inseln
                    kann sich also kein Bauer gleicher Farbe befinden. Es werden
                    jedoch nur die Inseln gezählt, zu denen jeweils genau
                    n Bauern gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>compounds</expr></td>
      <td class="r">Bauernverbünde: zähle alle Bauernverbünde (nicht die Anzahl der
                    Bauern, die zu dem Verbund gehören). Eine Bauernverbund besteht
                    aus Bauern gleicher Farbe, die jeweils alle auf benachbarten Reihen
                    stehen. Zwischen gleichfarbigen Verbünden kann sich also kein Bauer
                    gleicher Farbe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>compounds(n)</expr></td>
      <td class="r">Bauernverbünde: zähle alle Bauernverbünde (nicht die Anzahl der
                    Bauern, die zu dem Verbund gehören). Eine Bauernverbund besteht
                    aus Bauern gleicher Farbe, die jeweils alle auf benachbarten Reihen
                    stehen. Zwischen gleichfarbigen Verbünden kann sich also kein Bauer
                    gleicher Farbe befinden. Es werden jedoch nur die Verbünde gezählt,
                    zu denen jeweils mindestens n Bauern gehören</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>compounds!(n)</expr></td>
      <td class="r">Bauernverbünde: zähle alle Bauernverbünde (nicht die Anzahl der
                    Bauern, die zu dem Verbund gehören). Eine Bauernverbund besteht
                    aus Bauern gleicher Farbe, die jeweils alle auf benachbarten Reihen
                    stehen. Zwischen gleichfarbigen Verbünden kann sich also kein Bauer
                    gleicher Farbe befinden. Es werden jedoch nur die Verbünde gezählt,
                    zu denen jeweils genau n Bauern gehören</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>files</expr></td>
      <td class="r">Bauer pro Linie: zähle alle Linien (nicht die Bauern auf den
                    Linien), auf denen sich Bauern mit den genannten Eigenschaften
                    befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>files(n)</expr></td>
      <td class="r">Bauer pro Linie: zähle alle Linien (nicht die Bauern auf den
                    Linien), auf denen sich mindestens n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>files!(n)</expr></td>
      <td class="r">Bauer pro Linie: zähle alle Linien (nicht die Bauern auf den
                    Linien), auf denen sich genau n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>ranks</expr></td>
      <td class="r">Bauer pro Reihe: zähle alle Reihen (nicht die Bauern auf den
                    Linien), auf denen sich Bauern mit den genannten Eigenschaften
                    befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>ranks(n)</expr></td>
      <td class="r">Bauer pro Reihe: zähle alle Reihen (nicht die Bauern auf den
                    Linien), auf denen sich mindestens n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>ranks!(n)</expr></td>
      <td class="r">Bauer pro Reihe: zähle alle Reihen (nicht die Bauern auf den
                    Linien), auf denen sich genau n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>bothsides</expr></td>
      <td class="r">Beide Flügel: das Resultat der Zählung ist das Minimum der
                    Bauernzahl auf dem Damenflügel (a-d) und der Bauernzahl auf dem
                    Königsflügel <nobr>(e-h).</nobr></td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>oneside</expr></td>
      <td class="r">Ein Flügel: entweder wird Null gezählt, wenn kein Bauer vorhanden
                    ist, bzw. wenn mindestens ein Bauer sowohl auf dem Dameflügel
                    <nobr>(a-d)</nobr> als auch auf dem Königsflügel <nobr>(e-h)</nobr>
                    vorhanden ist, ansonsten wird die Gesamtzahl der Bauern gezählt.</td>
    </tr>
  </table>
</box>

<p>
Eine Zählung erfolgt immer am Schluß, nachdem aller Bauern mit den gewünschten
Eigenschaften aufgefunden wurden. Damit dies klarer beim Lesen des Ausdrucks
wird, dürfen Attribute für die Zählung nur am Ende einer Attributliste
verwendet werden.
</p>

<p>
Die Attribute für die Zählweise haben keinen Einfluß auf die Auswahl der gezählten
Bauern. Sobald beispielsweise <expr>islands</expr> in einer Verknüpfung verwendet wird,
werden immer die Anzahl der Insel gezählt. Dazu Beispiele:
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] trio-islands)
</verb>

<p>
Nun wird die Anzahl aller Bauerntrios gezählt, nicht mehr die Anzahl der beteiligten
Bauern.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] chained-islands)
</verb>

<p>
Die Anzahl der Bauernketten wird gezählt, nicht die Anzahl der beteiligten Bauern.
</p>

<p>
Manche dieser Attribute können ein Zähler als Argument haben. Der Zähler muß den
Wertebereich einhalten:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>compounds, compounds!, ranks, ranks!</expr></td>
      <td class="r">1 &#x2264; n &#x2264; 6</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>islands, islands!, files, files!</expr></td>
      <td class="r">1 &#x2264; n &#x2264; 8</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive, consecutive!</expr></td>
      <td class="r">2 &#x2264; n &#x2264; 6</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained, chained!</expr></td>
      <td class="r">2 &#x2264; n &#x2264; 8</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple, triple!</expr></td>
      <td class="r">3 &#x2264; n &#x2264; 6</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart, quart!</expr></td>
      <td class="r">4 &#x2264; n &#x2264; 8</td>
    </tr>
  </table>
</box>

<p>
Grundsätzlich können alle Attribute miteinander verknüpft werden,
jedoch sind nicht alle Verknüpfungen sinnvoll. Es erfolgt eine Fehlermeldung,
wenn sich in einer Verknüpfung Attribute widersprechen (wie z.B. bei
<expr>chained-isolated</expr>, oder <expr>mirrored-unblocked</expr>).
</p>

<p>
Die Attribute wirken als Filter, d.h. jedes Attribut filtert die Bauern mit
der spezifizierten Eigenschaft, und das nachfolgende Attribut filtert dann
die verbliebenen Bauern aus der vorhergehenden Zählung. Daraus resultiert,
daß die Reihenfolge der verknüpften Attribute generell eine Rolle spielt,
so sind die folgenden Beispiele nicht äquivalent:
</p>

<verb><keyword>position:pawncount</keyword> [&P;&p;] single!-behind &gt;0</verb>
<verb><keyword>position:pawncount</keyword> [&P;&p;] behind-single! &gt;0</verb>

<p>
Im ersten Fall können tatsächlich nur dann Bauern auf einer Linie gezählt
werden, wenn es keinen weiteren der gleichen Farbe auf dieser Linie gibt,
aber im zweiten Fall würde <expr>behind</expr> evt. nur Bauern zurücklassen
(filtern), die dann ganz alleine auf der Linie sind (gegnerische Bauern
werden nicht berücksichtigt), und diese werden dann alle als Einzelbauern
gezählt. Diese Methodik mit der Filterung erlaubt mehr Einflußmöglichkeiten
auf die Zählung als eine einfache Und-Verknüpfung.
</p>

<p>
Weitere Beispiele:
</p>

<verb>
(position <keyword>position:pawncount</keyword> &P; blocked 100%)
</verb>

<p>
Alle weißen Bauern sind blockiert, d.h. jedem weißen Bauern steht ein schwarzer
Bauer (möglicherweise entfernt) gegenüber.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;][a-d?] blocked 100%)
</verb>

<p>
Alle Bauern auf dem Damenflügel sind blockiert, d.h. jedem Bauern auf dem Damenflügel
steht ein gegnerischer Bauer (möglicherweise entfernt) gegenüber.
</p>

<verb>
(position <keyword>position:pawncount</keyword> &P;[a-d?] blocked! &gt;=50%)
</verb>

<p>
Mindestens der Hälfte der weißen Bauern auf dem Damenflügel steht ein schwarzer
Bauer direkt gegenüber (dies kann niemals zutreffen, wenn es keine weißen Bauern
auf dem Damenflügel gibt).
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <keyword>position:pawncount</keyword> &P; double-!advanced-compounds &gt;=2)
</verbatim>

<p>
Einer der Parteien hat mindestens zwei Doppelbauern, wobei keiner
der betroffenen Bauern in der gegnerischen Hälfte steht.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-consecutive(3) &gt;=3)
</verb>

<p>
Findet isolierte Trippelbauern auf verbundenen Feldern, wie in folgender
Stellung:
</p>

<div id="tooltip1" style="margin-top:-8px">
<a><expr>8/p4pk1/8/2R1P1N1/6P1/6P1/2P2KP1/1r5r w - - 0 1</expr><img
  src="../images/cql-examples-1.png" height="241" width="241" alt=""/></a>
</div>

<p>
Die Alternative
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-triple-consecutive &gt;=3)
</verb>

<p>
wäre hier nicht das gewünschte, denn in diesem Fall werden beispielsweise auch
Trippelbauern gezählt, die nicht allesamt miteinander verbunden sind,
beispielsweise zwei isolierte Doppelbauern auf einer Linie. Wird jedoch
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-triple!-consecutive &gt;=3)
</verb>

<p>
verwendet, dann werden zwar wieder hintereinanderstehende isolierte Trippelbauern
gefunden, aber keine Stellungen mit mehr als drei hintereinanderstehenden isolierten
Bauern. Aber in diesem speziellen Beispiel ist die folgende alternative Formulierung
äquivalent zu <expr>isolated-consecutive(3)</expr>:
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-triple-compounds(3) &gt;0)
</verb>

<p>
Hier ist das Attribut <expr>triple</expr> redundant, macht aber die Sache einfacher
lesbar.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] backward-stopped-!blocked &gt;0)
</verb>

<p>
Einer der Parteien hat mindestens einen rückständigen Bauern, der keinen gegnerischen
Bauern auf der gleichen Linie vor ihm hat, aber von einem gegnerischen Bauer auf einer
benachbarten Linie in direkter Weise am Vorücken gehindert wird.
</p>

<verb>
(position <keyword>position:pawncount</keyword> &P;?4 stoppable-!blocked-duo! &gt;0)
</verb>

<p>
Weiß hat hängende Bauern auf der vierten Reihe: ein Bauerduo (zwei Bauern nebeneinander
auf einer Reihe), die sich auf halboffenen Linien befinden (d.h. sie sind nicht
blockiert, aber auch keine Freibauern).
</p>

<verb>
(position <keyword>position:pawncount</keyword> &p; bothsides 0)
</verb>

<p>
Schwarz hat nicht mehr auf beiden Flügeln Bauern aufzuweisen.
</p>

<verb>
(position <keyword>position:pawncount</keyword> &p; oneside &gt;0)
</verb>

<p>
Schwarz hat alle seine Bauern entweder auf dem Damenflügel oder auf
dem Königsflügel, aber nicht auf beiden Flügeln.
</p>

<p>
Siehe bei <a href="CQL-Examples.html#pawnending">CQL-Beispiele</a> für weiter Beispiele.
</p>

<p>
Siehe auch:
<cql>position:piececount</cql>,
<cql>position:pawncountdifference</cql>,
<cql>position:piececountdifference</cql>.
</p>

<h3 id="position:pawncountdifference">:pawncountdifference<extension/>&emsp;<n>(Bauerndifferenz)</n></h3>

<p>
<cql>:pawncountdifference</cql> filtert Positionen, wenn die Differenz
der Zählung von Bauern mit den spezifizierten Eigenschaften oder Strukturen
innerhalb der gegebenen Bereichsangabe liegt. Dieses Schlüsselwort kann
ein oder zwei Figurenbezeichner, die nur Bauern enthalten dürfen, als Argumente
erhalten, gefolgt von einer bindestrich-separierten Aufzählung von Eigenschaften,
und als letztes Argument wird eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> erwartet. Ist nur ein
Figurenbezeichner gegeben, dann wird die Differenz des Resultats der Zählung der
weißen Figuren im Figurenbezeichner minus dem Resultat der Zählung der schwarzen
Figuren im Figurenbezeichner ermittelt. Bei der Angabe von zwei Figurenbezeichnern
wird die Differenz des Resultats der Zählung des ersten Figurenbezeichners minus
dem Resultat der Zählung des zweiten Figurenbezeichners ermittelt. Diese Differenz
muß innerhalb der Bereichsangabe liegen, damit eine Position gefiltert wird.
</p>

<p>
Die unterstützen Bauerneigenschaften bzw. Bauernstruktureigenschaften sind
die gleichen wie unter <cql>position:pawncount</cql>.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <keyword>position:pawncountdifference</keyword> &P;[?5-7] &p;[?2-4] passed-lines &gt;0)
</verbatim>

<p>
Weiß hat mehr Freibauern, die in der gegnerischen Hälfte stehen, als Schwarz. Es
werden hier jedoch für jede Farbe nur ein Freibauer pro Linie gezählt (in diesem
speziellen Fall könnte statt <expr>lines</expr> auch <expr>forefront</expr>
verwendet werden).
</p>

<p>
Siehe auch:
<cql>position:pawncount</cql>,
<cql>position:piececount</cql>,
<cql>position:piececountdifference</cql>.
</p>

<h3 id="position:perpendicular">:perpendicular<extension/>&emsp;<n>(senkrecht verlaufend zu)</n></h3>

<p>
<cql>:perpendicular</cql> erwartet als Argument zwei Figurenbezeichner. Eine Stellung
wird gefiltert, wenn die potentiell möglichen Züge (.d.h. alle Zugmöglichkeiten auf
einem leeren Brett) des ersten Figurenbezeichners senkrecht zu den potentiell möglichen
Zügen des zweiten Figurenbezeichners verlaufen, oder anders ausgedrückt, wenn die
potentiellen Zugmöglichkeiten sich kreuzen. Dies kann nur von Langschrittlern erfüllt
werden (im Standardschach sind dies Dame, Turm, und Läufer). Beispiele:
</p>

<h3 id="position:piececount">:piececount&emsp;<n>(Materialzählung)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argument einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert
eine Position genau dann, wenn die Anzahl der Vorkommen der bezeichneten
Figuren in dieser Position innerhalb der gegebenen Bereichsangabe liegt.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:piececount</keyword> &R; 2)
</verb>

<p>
Dies wird jede Position filtern mit exakt zwei weißen Türmen &ndash; eine Position
mit drei weißen Türmen würde nicht gefiltert werden.
</p>

<verbatim>
(position
  &N;d4
  <keyword>position:piececount</keyword> [&R;&r;][a1-8] 1 3
  <keyword>position:piececount</keyword> [&Q;&q;][a-h8] 4)
</verbatim>

<p>
Dies wird jede Position filtern mit einem weißen Springer auf d4, ein bis drei
Türmen auf eine Linie, und exakt vier Damen auf der achten Reihe. Ein alternative
Schreibweise dieser Abfrage ist:
</p>

<verbatim>
(position
  &N;d4
  <keyword>position:piececount</keyword> [&R;&r;][a?] 1 3
  <keyword>position:piececount</keyword> [&Q;&q;][?8] 4)
</verbatim>

<p>
Siehe auch:
<cql>position:pawncountdifference</cql>,
<cql>position:piececountdifference</cql>,
<cql>position:powerdifference</cql>.
</p>

<h3 id="position:piececountdifference">:piececountdifference<extension/>&emsp;<n>(Materialdifferenz)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argumente zuerst entweder ein oder zwei
Figurenbezeichner, gefolgt von einer
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert Positionen
in denen die Differenz der Figurenzählung, die von den Figurenbezeichnern
spezifiziert werden, innerhalb der gegebenen Bereichsangabe liegt. Ist nur
ein Figurenbezeichner gegeben, dann muß die Differenz der Zählung der weißen
Figuren im Figurenbezeichner minus der Zählung der schwarzen Figuren im
Figurenbezeichner innerhalb der Bereichsangabe liegen. Bei zwei Figurenbezeichnern
muß die Differenz der Zählung aller bezeichneten Figuren im ersten
Figurenbezeichner minus der Zählung aller bezeichneten Figuren im zweiten
Figurenzähler innerhalb der Bereichsangabe liegen.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <keyword>position:piececountdifference</keyword> [&R;&r;][a1,a8,h1,h8] 1)
</verbatim>

<p>
Weiß hat genau einen Turm mehr als Schwarz auf den Eckfeldern stehen.
</p>

<verbatim>
(position
  <keyword>position:piececountdifference</keyword> [&B;][b2,g2] [&b;][b7,g7] &gt;0)
</verbatim>

<p>
Weiß hat mehr fianchettierte Läufer als Schwarz.
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <keyword>position:piececountdifference</keyword> &q; &Q; 1
  <keyword>position:piececountdifference</keyword> &I; &i; 1
  <keyword>position:piececountdifference</keyword> &P; &p; 1 2)
</verbatim>

<p>
Finde alle Positionen, in denen eine der Parteien genau eine Dame weniger
hat, und als Ausgleich genau einen Turm, genau eine Leichtfigur, und ein oder
zwei Bauern mehr hat.
</p>

<p>
Siehe auch:
<cql>position:piececount</cql>,
<cql>position:pawndifference</cql>,
<cql>position:powerdifference</cql>.
</p>

<h3 id="position:power">:power&emsp;<n>(Figurenpotential)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argumente einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es wird
jede Position gefiltert, in der das Gesamtfigurenpotential in dieser Position
innerhalb der gegebenen Bereichsangabe liegt. Das Potential einer Figur
ist sein Materialwert, abhängig von der
<a href="Chess-Variants.html">Schachform</a>:
</p>

<dir>
INCLUDE ../Power-Values.txt
</dir>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:power</keyword> &a; 6)
</verb>

<p>
Dies wird Positionen finden deren Gesamtfigurenpotential aller schwarzen
Figuren genau den Wert 6 hat.
</p>

<verb>
(position <keyword>position:power</keyword> &A;[a-h1-4] 10 25)
</verb>

<p>
Dies wird Positionen finden deren Gesamtfigurenpotential aller weißen
Figuren in der weißen Hälfte einen Wert zwischen 10 und 25 aufweist (inklusive).
</p>

<p>
Siehe auch:
<cql>position:pawncount</cql>,
<cql>position:piececount</cql>.
</p>

<h3 id="position:powerdifference">:powerdifference&emsp;<n>(Figurenpotentialdifferenz)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argumente ein oder zwei Figurenbezeichner,
gefolgt von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es
filtert Positionen, in denen die Differenz des Figurenpotentials (<see/>
<cql>position:power</cql>) der bezeichneten Figuren innerhalb der gegebenen
Bereichsangabe liegt. Im Falle nur eines Figurenbezeichners ist die Differenz
die Summe des Figurenpotentials aller bezeichneten weißen Figuren im Figurenbezeichner
minus dem Figurenpotential aller bezeichneten schwarzen Figuren im
Figurenbezeichner. Im Fall von zwei Figurenbezeichnern wird die Differenz
aus dem Figurenpotential aller bezeichneten Figuren im ersten Figurenbezeichner
minus dem Figurenpotential aller bezeichneten Figuren im zweiten Figurenbezeichner
gebildet.
</p>

<note>
Standard-CQL kennt nur die Form mit einem Figurenbezeichner.
</note>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:powerdifference</keyword> &U; 4)
</verb>

<p>
Dies filtert Positionen, in denen das Potential der weißen Figuren genau
um 4 größer ist als das Potential der schwarzen Figuren.
</p>

<verb>
(position <keyword>position:powerdifference</keyword> &R; &r; -5 10)
</verb>

<p>
Diese filtert Positionen, in denen Weiß ein Potential zwischen einem Turm
Materialnachteil und zwei Türmen Materialvorteil besitzt.
</p>

<verb>
(position <keyword>position:powerdifference</keyword> [&R;&B;&N;] [&r;&b;&n;] &lt;=&#x2212;2)
</verb>

<p>
Dies filtert Positionen, in denen Schwarz mindestens eine Qualität Vorteil hat.
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <keyword>position:powerdifference</keyword> [&R;&B;&N;] [&r;&b;&n;] &lt;=&#x2212;2)
</verbatim>

<p>
Dies filtert Positionen, in denen eine der Partien mindestens eine Qualität Vorteil hat.
</p>

<div id="eithercolor:example">
<verbatim>
(match
  <cql>match:result</cql> 1-0
  (position
    <cql>position:sequence</cql> (
      (position
        <keyword>position:powerdifference</keyword> &U; -2 +2
        <keyword>position:powerdifference</keyword> &Q; &q; 0)
      (position
        <cql>position:repetitioncount</cql> &gt;=12
        <keyword>position:powerdifference</keyword> &Q; &q; &lt;=&#x2212;9))))
</verbatim>
</div>

<p>
Dieses Beispiel zeigt eine Möglichkeit auf, wie mit Hilfe von
<cql>:powerdifference</cql> nach Damenopfern gesucht wird. Eine Seite opfert
eine Dame, und verbleibt mindestens 12 Züge lang mit einer Dame in
Materialnachteil, um letztendlich zu gewinnen.
</p>

<p>
Siehe auch:
<cql>position:pawncountdifference</cql>,
<cql>position:piececountdifference</cql>,
<cql>position:power</cql>.
</p>

<h3 id="position:ray">:ray&emsp;<n>(Strahl)</n></h3>

<p>
Ein Strahl bezeichnet eine Liste von Figurenbezeichnern. Es ist eine
zusammenhängende Menge von Feldern entweder auf einer Linie, einer Reihe,
oder einer Diagonalen auf dem Schachbrett.
</p>

<p>
Sei R ein Felderstrahl mit einer geordneten Menge von Feldern in einer
zusammenhängenden Linie, Reihe, oder Diagonalen <nobr>S<sub>1</sub>,</nobr>
<nobr>S<sub>2</sub>,</nobr> <nobr>...,</nobr> <nobr>S<sub>n</sub>.</nobr>
Gegeben sei eine Strahlendefinition <nobr>(G<sub>1</sub>,</nobr>
<nobr>G<sub>2</sub>,</nobr> <nobr>...,</nobr> <nobr>G<sub>k</sub>),</nobr>
wobei jedes G<sub>i</sub> einen Figurenbezeichner definiert. Der Felderstrahl R
ist gültig in Bezug auf die gegebene Strahlendefinition wenn
<nobr>G<sub>1</sub></nobr> eine Figur auf dem Feld <nobr>S<sub>1</sub></nobr>
bezeichnet, <nobr>G<sub>k</sub></nobr> eine Figur auf dem Feld
<nobr>S<sub>n</sub></nobr> bezeichnet, und wenn alle anderen
<nobr>G<sub>i</sub></nobr> jeweils mit einem Feld einer Untermenge
des Felderstrahls gepaart werden können ohne die Reihenfolge zu verletzen,
so daß jedes <nobr>G<sub>i</sub></nobr> eine Figur auf dem zugeordneten Feld
bezeichnet, und alle ungepaarten Felder leer sind.
</p>

<p>
Das Schlüsselwort <cql>:ray</cql> erwartet eine Strahlendefinition und eine
optionale <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Wenn die
Bereichsangabe nicht vorhanden ist, so wird <code>&gt;=1</code>
als Bereich angenommen. <cql>:ray</cql> filtert eine Position wenn die Anzahl
der Felderstrahlen in dieser Position, die in Bezug auf die Strahlendefinition
gültig sind, innerhalb der Bereichsangabe liegen.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:ray</keyword> (&k; &Q;))
</verb>

<p>
Filtert eine Position, in der eine weiße Dame den schwarzen König attackiert.
</p>

<verb>
(position <keyword>position:ray</keyword> (&Q;a? &n; &k;[?4-8]))
</verb>

<p>
Filtert eine Position, in der eine weiße Dame auf der a-Linie einen schwarzen
Springer fesselt, und der schwarze König auf den letzten vier Reihen steht.
</p>

<verb>
(position <keyword>position:ray</keyword> (&Q;a? &Q;c? &Q;e? &k;g?))
</verb>

<p>
Filtert entweder eine Position, in der alle drei weißen Damen und der schwarze
König auf der gleichen Reihe stehen mit jeweils exakt einem Leerfeld zwischen
diesen Figuren, oder eine Position, in der alle drei weißen Damen und der
schwarze König eine Diagonale formen mit jeweils einem Leerfeld zwischen diesen
Figuren, und die Damen stehen in beiden Fällen auf den a, c, und e-Linien.
</p>

<verb>
(position <keyword>position:ray</keyword> (&Q; &n; &k;) 2 4)
</verb>

<p>
Zwei bis vier schwarze Springer sind gefesselt.
</p>

<p>
Siehe auch: <cql>position:rayattack</cql>.
</p>

<h3 id="position:rayattack">:rayattack&emsp;<n>(Strahlenangriff)</n></h3>

<p>
Hat die gleiche Syntax wie <cql>position:ray</cql>. Es hat auch die gleiche
Semantik, außer das nur orthogonale Strahlen, die auf einem Feld mit einer
Schwerfigur starten, sowie diagonale Strahlen, die auf einem Feld mit einer
Dame oder einem Läufer starten, eingeschlossen sind.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:rayattack</keyword> (&A; &a; &k;))
</verb>

<p>
Filtert eine Position, in der eine schwarze Figur gefesselt ist.
</p>

<verb>
(position <keyword>position:rayattack</keyword> (&A;d5 &a; [&r;&k;][a-h1-4]) 3)
</verb>

<p>
Filtert Positionen, in denen drei schwarze Figuren von einer weißen Figur auf
d5 gefesselt werden, wobei ein schwarzer Turm und der schwarze König auf den
ersten vier Reihen stehen.
</p>

<verb>
(position <cql>position:stalemate</cql> <keyword>position:rayattack</keyword>
(&A; &a; &k;) 2 8 <cql>position:flipcolor</cql>)
</verb>

<p>
Findet Pattstellungen mit Mehrfachfesselungen auf.
</p>

<p>
Siehe auch: <cql>position:ray</cql>.
</p>

<h3 id="position:raydiagonal">:raydiagonal&emsp;<n>(Diagonalstrahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf diagonale Linien beschränkt sind.
</p>

<h3 id="position:rayhorizontal">:rayhorizontal&emsp;<n>(Horizontaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf horizontale Linien beschränkt sind.
</p>

<h3 id="position:rayorthogonal">:rayorthogonal&emsp;<n>(Othogonaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf vertikale und horizontale Linien beschränkt sind.
</p>

<h3 id="position:rayvertical">:rayvertical&emsp;<n>(Vertikaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf  vertikale Linien beschränkt sind.
</p>

<!-- ############################################################################## -->
<h2 id="move">Schlüsselwörter für die Zuganalyse</h2>
<!-- ############################################################################## -->

<p>
Ein Zug hat drei Ausprägungen: einen Herkunftsbezeichner, einen
Zielbezeichner, und einen Bauernumwandlungsbezeichner. Diese beziehen
sich auf die Figur und das Feld von der dieser Zug weggeht; die Figur und
das Feld wohin dieser Zug geht (aber bevor dieser Zug tatsächlich erfolgt),
und die Figur und das Feld wo eine Bauernumwandlung stattfindet, sofern eine
solche vorhanden. In den Schachformen %::mc::VariantName(DropChess)% und
%::mc::VariantName(Bughouse)% hat ein Zug noch eine vierte Ausprägung: den
Figurenartbezeichner für die Einsetzfigur. Er bezieht sich auf die Figurenart die
eingesetzt wird, sofern es ein Einsetzzug ist.
</p>

<p>
Beispielsweise ist der Zielbezeichner für einen weißen Turm auf a4, der
einen schwarzen Springer auf d4 schlägt: <expr>&n;d4</expr>, und der
Herkunftsbezeichner ist <expr>&R;a4</expr>. Der Zielbezeichner eines
Zuges nach e4, der keine Figur schlägt, ist <expr>.e4</expr>.
</p>

<p>
Es werden einige Schlüsselwörter angeboten, die auf die nachfolgende
Position vorausschauen, wie z.B. <cql>position:ismate</cql>. Während
<cql>position:mate</cql> die Position findet, in der eine der Seiten matt
ist, findet <cql>position:ismate</cql> die Position, in der die Seite am
Zug matt setzt. In einigen Fällen ist diese Vorausschau sehr nützlich,
insbesondere in Verbindung mit <cql>position:cond</cql>,
<cql>position:cut</cql> und <cql>position:exclude</cql>. Diese
Vorausschau kann auch die Verwendung von <cql>position:sequence</cql>
ersparen.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:captureforced">:captureforced</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:forced">:forced</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:halfmovenumber">:halfmovenumber</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ischeck">:ischeck</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:iscontactcheck">:iscontactcheck</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isdoublecheck">:isdoublecheck</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isillegal">:isillegal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isinvalid">:isinvalid</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ismate">:ismate</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isnull">:isnull</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isstalemate">:isstalemate</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:moveto">:moveto</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:promote">:promote</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:takeslastpiece">:takeslastpiece</a></td></tr>
</table>

<h3 id="position:captureforced">:captureforced<extension/>&emsp;<n>(Schlagen ist erzwungen)</n></h3>

<p>
Der nächste Zug ist verpflichtet eine Figur zu schlagen. Dieses Schlüsselwort
hat nur in der Schachform %::mc::VariantName(Antichess)% eine Bedeutung und wird in
anderen Schachformen niemals erfüllt.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:captureforced</keyword>)
</verb>

<p>
Der nächste Zug ist nicht verpflichtet eine Figur zu schlagen, dies
heißt das in dieser Stellung auch keine Figur geschlagen werden kann.
Dies gilt jedoch nur für die Schachform %::mc::VariantName(Antichess)%,
in allen anderen Schachformen wird diese Bedingung immer erfüllt.
</p>

<p>
Siehe auch: <cql>position:mustcapture</cql>.
</p>

<h3 id="position:forced">:forced<extension/>&emsp;<n>(Forciert)</n></h3>

<p>
Der nächste Zug ist erzwungen, kein anderer Zug ist möglich.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>(position <keyword>!position:forced</keyword>)
</verb>

<p>
Der nächste Zug ist nicht erzwungen, es gibt auch andere Züge (auch wenn sie nicht
gut sein sollten).
</p>

<h3 id="position:enpassant">:enpassant</h3>

<p>
Der nächste Zug ist ein en-passant Schlagzug.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:enpassant</keyword>)
</verb>

<p>
Der nächste Zug ist kein en-passant Schlagzug.
</p>

<h3 id="position:halfmovenumber">:halfmovenumber<extension/>&emsp;<n>(Halbzugnummer)</n></h3>

<p>
<cql>:halfmovenumber</cql> erwartet als Argument eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>, und filtert eine
Position nur dann, wenn die aktuelle Halbzugnummer innerhalb des gegebenen
Bereichs liegt. Innerhalb von Untervarianten hat dieses Schlüsselwort keine
Wirkung und ist immer erfolglos.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> 0)
</verb>

<p>
Dies bezeichnet die erste Position in der Partie (vor dem ersten Zug). Dies ist
identisch zu:
</p>

<verb>
(position <cql>position:initial</cql>)
</verb>

<p>
Als eine Erweiterung kann auch <expr>end</expr>, bzw.
<nobr><expr>end</expr>&minus;N</nobr> als numerisches Argument verwendet werden.
Auch dazu Beispiele:
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> end)
</verb>

<p>
Dies bezeichnet die Endposition (nach dem letzten Zug der Partie); siehe auch
<cql>position:terminal</cql>.
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> end-3)
</verb>

<p>
Dies bezeichnet den drittletzten Halbzug in der Partie, d.h. es folgen
noch drei Halbzüge.
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> end-1 <cql>position:moveto</cql> &U;)
</verb>

<p>
Filtere alle Partien, in denen im letzten Zug der Partie eine Figur geschlagen wird.
Dies ist einfacher und viel effizienter als der äquivalente Ausdruck:
</p>

<verbatim>
(position <cql>position:sequence</cql> (
  (position <cql>position:moveto</cql> &U;)
  (position <cql>position:terminal</cql>)))
</verbatim>

<annotation>
Der Einsatz von <cql>:halfmovenumber</cql> kann die Suchzeiten erheblich verkürzen.
</annotation>

<p>
Siehe auch:
<cql>position:initial</cql>,
<cql>position:terminal</cql>,
<cql>position:movenumber</cql>.
</p>

<h3 id="position:iscastling">:iscastling<extension/>&emsp;<n>(Rochadezug?)</n></h3>

<p>
Der nächste Zug ist eine Rochade. Als Argument können die Figurenartbezeichner
&K;, &k;, &Q; und &q; folgen, die die Rochade genauer spezifizieren.
</p>

<p>
Beispiele:
</p>

<verb>
  <keyword>position:iscastling</keyword> <comment>; die Seite am Zug rochiert</comment>
</verb>
<verb>
  <keyword>position:iscastling</keyword> &K; <comment>; Weiß rochiert kurz</comment>
</verb>
<verb>
  <keyword>position:iscastling</keyword> [&K;&Q;] <comment>; Weiß rochiert</comment>
</verb>
<verb>
  <keyword>position:iscastling</keyword> [&Q;&q;] <comment>; die Seite am Zug rochiert lang</comment>
</verb>

<p>
Hier muß zur Negierung das Schlüsselwort <cql>position:not</cql> verwendet werden;
zum Beispiel:
</p>

<verb>
(position <cql>position:not</cql> (position <keyword>position:iscastling</keyword> &K;))
</verb>

<p>
Der nächste Zug ist keine kurze weiße Rochade.
</p>

<p>
Siehe auch: <cql>position:castling</cql>,
</p>

<h3 id="position:ischeck">:ischeck<extension/>&emsp;<n>(Schachgebot?)</n></h3>

<p>
Filtert eine Position, wenn der nächste Zug ein Schachgebot ist. Ist als Argument
eine <a href="CQL-Range-Specifiers.html">Bereichsangabe</a> vorhanden, dann wird
eine Position gefiltert, wenn der nächste Zug ein Schachgebot ist, und die Anzahl
der Schachgebote, die die Seite am Zug dem Gegner bot, einschließlich des
nächsten Zugs, innerhalb dieser Bereichsangabe liegt. Die untere Schranke dieser
Bereichsangabe kann nicht kleiner als 1 sein.
</p>

<note>
<cql>:ischeck</cql> mit nachfolgender Bereichsangabe ist in erster Linie nützlich
in der Schachform %::mc::VariantName(ThreeCheck)%. Das nachfolgende Beispiel gilt
für diese Schachform.
</note>

<verb>
(position <keyword>position:ischeck</keyword> 3)
</verb>

<p>
Die Seite am Zug bietet nun zum dritten Mal in der Partie dem Gegner
Schach. Dies kann nur eine Endstellung sein (in %::mc::VariantName(ThreeCheck)%).
</p>

<verb>
(position
  <cql>position:matchcount</cql> 1
  <keyword>position:ischeck</keyword>)
</verb>

<p>
Das einzige Schachgebot in der Partie überhaupt.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:ischeck</keyword>)
</verb>

<p>
Der nächste Zug ist kein Schachgebot.
</p>

<p>
Siehe auch: <cql>position:checkcount</cql>,
</p>

<h3 id="position:iscontactcheck">:iscontactcheck<extension/>&emsp;<n>(Kontaktschachgebot?)</n></h3>

<p>
Der nächste Zug ist ein Kontaktschachgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:iscontactcheck</keyword>)
</verb>

<p>
Der nächste Zug ist kein Kontaktschachgebot (aber trotzdem möglicherweise
ein Schachgebot).
</p>

<p>
Siehe auch: <cql>position:contactcheck</cql>,
</p>

<h3 id="position:isdoublecheck">:isdoublecheck<extension/>&emsp;<n>(Doppelschachgebot?)</n></h3>

<p>
Der nächste Zug ist ein Doppelschachgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isdoublecheck</keyword>)
</verb>

<p>
Der nächste Zug ist kein Doppelschachgebot (aber trotzdem möglicherweise
ein Schachgebot).
</p>

<p>
Siehe auch: <cql>position:doublecheck</cql>,
</p>

<h3 id="position:isillegal">:isillegal<extension/>&emsp;<n>(Regelwidrig?)</n></h3>

<p>
Der nächste Zug ist ein regelwidriger Zug, beispielsweise eine Rochade, obwohl der
König im Schach steht.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isillegal</keyword>)
</verb>

<p>
Der nächste Zug ist kein regelwidriger Zug.
</p>

<h3 id="position:isinvalid">:isinvalid<extension/>&emsp;<n>(Unerlaubt?)</n></h3>

<p>
Der nächste Zug ist ein unerlaubter Zug, beispielsweise ein Läuferzug, der auf einem
schwarzen Feld beginnt, aber auf einem weißen Feld endet (dies unterstützt den
Kinderschachmodus).
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isinvalid</keyword>)
</verb>

<p>
Der nächste Zug ist kein unerlaubter Zug.
</p>

<h3 id="position:ismate">:ismate<extension/>&emsp;<n>(Mattgebot?)</n></h3>

<p>
Der nächste Zug ist ein Mattgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:ismate</keyword>)
</verb>

<p>
Der nächste Zug ist kein Mattgebot.
</p>

<p>
Siehe auch: <cql>position:mate</cql>,
</p>

<h3 id="position:isnull">:isnull<extension/>&emsp;<n>(Nullzug?)</n></h3>

<p>
Der nächste Zug ist ein Nullzug.
</p>

<verb>
(position <keyword>position:isnull</keyword>)
</verb>

<p>
Suche nach Partien die einen Nullzug enthalten.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isnull</keyword>)
</verb>

<p>
Filtere alle Positionen, in denen kein Nullzug erfolgt.
</p>

<h3 id="position:isstalemate">:isstalemate&emsp;<n>(Pattgebot?)</n></h3>

<p>
Der nächste Zug ist ein Pattgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isstalemate</keyword>)
</verb>

<p>
Der nächste Zug ist kein Pattgebot.
</p>

<p>
Siehe auch: <cql>position:stalemate</cql>,
</p>

<h3 id="position:movefrom">:movefrom&emsp;<n>(Zug von)</n></h3>

<p>
Erwartet als Parameter eine Figurenbezeichner. Eine Position wird gefiltert,
wenn dieser Figurenbezeichner den Herkunftsbezeichner des nächsten Zuges
beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:movefrom</keyword> &R;a3)
</verb>

<p>
Filtere eine Position, in der der nächste Zug ein Turmzug von a3 ist.
</p>

<verb>
(position <keyword>position:movefrom</keyword> &U;?8)
</verb>

<p>
Filtere eine Position, in der der nächste Zug mit einer Figur von der
achten Reihe geschieht.
</p>

<verb>
(position <keyword>position:movefrom</keyword> &Q;[+] <cql>position:moveto</cql> .?8)
</verb>

<p>
Ein weiße Dame wird auf der schwarzen Grundreihe eingesetzt
(%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%).
</p>

<verb>
(position <keyword>position:movefrom</keyword> ???)
</verb>

<p>
Dieser Ausdruck ist in den Schachformen %::mc::VariantName(DropChess)% und
%::mc::VariantName(Bughouse)% sinnvoll: in dieser Position wird keine
Figur (aus der Rückhand) eingesetzt.
</p>

<verb>
(position <keyword>position:movefrom</keyword> .)
</verb>

<p>
Dies kann niemals gefiltert werden, auch keinen Einsetzzug
(%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%).
</p>

<p>
Siehe auch:
<cql>position:isnull</cql>,
<cql>position:line</cql>,
<cql>position:moveto</cql>,
<cql>position:promote</cql>.
</p>

<h3 id="position:movenumber">:movenumber&emsp;<n>(Zugnummer)</n></h3>

<p>
<cql>:movenumber</cql> erwartet als Argument eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>, und filtert eine
Position nur dann, wenn die aktuelle Zugnummer innerhalb des gegebenen
Bereichs liegt. Die Zugnummernzählung geht von einem Anzugsrecht der
weißen Seite aus.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:movenumber</keyword> 10 20 <cql>position:check</cql>)
</verb>

<p>
Filtert eine Position, in der ein Schachgebot zwischen dem 10. und dem
20. Zug erfolgt.
</p>

<verb>
(position <keyword>position:movenumber</keyword> 35 <cql>position:mate</cql>)
</verb>

<p>
Filtert eine Position, in der im 35. Zug mattgesetzt wird.
</p>

<p>
Als eine Erweiterung (des CQL-Standards) kann auch <expr>end</expr>, bzw.
<nobr><expr>end</expr>&minus;N</nobr> als Argument verwendet werden.
Jedoch ist das Verhalten undefiniert, wenn die Suche in den Untervarianten erfolgt
(<see/> <cql>position:variations</cql>), sollte also in diesem Fall nicht
verwendet werden. Auch dazu Beispiele:
</p>

<verb>
(position <keyword>position:movenumber</keyword> end)
</verb>

<p>
Dies bezeichnet die Endposition (nach dem letzten Zug der Partie); siehe auch
<cql>position:terminal</cql>.
</p>

<verb>
(position <keyword>position:movenumber</keyword> end-3)
</verb>

<p>
Dies bezeichnet den drittletzten Zug in der Partie (nicht zu
verwechseln mit Halbzügen; siehe <cql>position:halfmovenumber</cql>).
</p>

<verb>
(position <keyword>position:movenumber</keyword> end-4 end-3)
</verb>

<p>
Dies bezeichnet den Bereich vom viertletzten bis zum drittletzten Zug
in der Partie.
</p>

<p>
Siehe auch:
<cql>position:halfmovenumber</cql>,
<cql>position:initial</cql>,
<cql>position:terminal</cql>.
</p>

<h3 id="position:moveto">:moveto&emsp;<n>(Zug nach)</n></h3>

<p>
Erwartet als Argument einen Figurenbezeichner. <cql>:moveto</cql> filtert
einen Zug wenn dieses Argument den Zielbezeichner des Zuges beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:moveto</keyword> &U;)
</verb>

<p>
Filtert eine Position dessen nächster Zug ein Schlagzug ist.
</p>

<verb>
(position <keyword>position:moveto</keyword> .)
</verb>

<p>
Filtert eine Position dessen nächster Zug kein Schlagzug ist.
</p>

<verb>
(position <keyword>position:moveto</keyword> &U;~)
</verb>

<p>
Im nächsten Zug wird eine Figur geschlagen, die aus einer Bauernumwandlung hervorging.
</p>

<verb>
(position <keyword>position:moveto</keyword> &U;~~)
</verb>

<p>
Die Figur, die im nächsten Zug geschlagen wird, stammt nicht von einer Bauernumwandlung ab.
</p>

<verb>
(position <keyword>position:moveto</keyword> &R;[b1-8])
</verb>

<p>
Filtert eine Position, in der der nächste Zug einen weißen Turm auf der
b-Linie schlagen wird. Beachte daß dies sehr verschieden ist von der
Interpretation einer Zugbeschreibung im
<a href="http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm">PGN-Format</a>&#x2006;:
dort würde dies als ein Turmzug auf die b-Linie interpretiert werden.
Und dies wiederum geschieht in CQL auf diese Weise:
</p>

<verb>
(position <cql>position:movefrom</cql> &R; <keyword>position:moveto</keyword> ?b?)
</verb>

<p>
Filtert einen Zug, in dem der weiße Turm auf die b-Linie zieht.
Dies schließt einen Turm aus der Rückhand aus (%::mc::VariantName(DropChess)%
und %::mc::VariantName(Bughouse)%). Soll eine Figur aus der Rückhand mit
einbezogen werden, so ist folgende Erweiterung notwendig:
</p>

<verb>
(position <cql>position:movefrom</cql> &R;[*] <keyword>position:moveto</keyword> ?b?)
</verb>

<p>
Im nächsten Beispiel wird der en-passant-Fall behandelt:
</p>

<verb>
(position <keyword>position:moveto</keyword> .e6 <cql>position:enpassant</cql>)
</verb>

<p>
Ein Bauer auf e5 wird en-passant geschlagen.
</p>

<p>
Siehe auch:
<cql>position:isnull</cql>,
<cql>position:line</cql>,
<cql>position:movefrom</cql>,
<cql>position:promote</cql>.
</p>

<h3 id="position:noenpassant">:noenpassant&emsp;<n>(Kein en-passant)</n></h3>

<p>
Dieses Schlüsselwort ist veraltet und sollte nicht mehr verwendet werden, es wird
nur aus Kompatibilitätsgründen zu CQL unterstützt. Es hat die gleiche Bedeutung
wie <cql>!:enpassant</cql>.
</p>

<h3 id="position:promote">:promote&emsp;<n>(Bauernumwandlung)</n></h3>

<p>
Erwartet als Argument einen Figurenbezeichner. Ein Zug wird gefiltert wenn
es sich um eine Bauernumwandlung handelt, und der gegebene Figurenbezeichner
den Bauernumwandlungsbezeichner des Zuges beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:promote</keyword> [&R;&B;&N;])
</verb>

<p>
Filtert eine Position dessen nächster Zug eine weiße Unterverwandlung ist.
</p>

<verb>
(position <keyword>position:promote</keyword> [&B;&N;]a8)
</verb>

<p>
Filtert eine Position dessen nächster Zug eine weiße Bauernumwandlung in
eine Leichtfigur ist.
</p>

<verb>
(position <keyword>position:promote</keyword> &R;e8
<cql>position:movefrom</cql> &P;f7 <cql>position:moveto</cql> &q;)
</verb>

<p>
Filtert eine Position, in der der nächster Zug einen Bauern von f7 nach e8
zieht, wobei eine schwarze Dame geschlagen wird und eine Bauernumwandlung
in einen Turm geschieht.
</p>

<verb>
(position <keyword>position:promote</keyword> [])
</verb>

<p>
Filtert eine Position, in der der nächster Zug keine Bauernumwandlung ist
(denn der Figurenartbezeichner ist leer).
</p>

<p>
Siehe auch:
<cql>position:isnull</cql>.
<cql>position:line</cql>,
<cql>position:movefrom</cql>,
<cql>position:moveto</cql>,
</p>

<h3 id="position:takeslastpiece">:takeslastpiece<extension/>&emsp;<n>(Schlägt die letzte Figur)</n></h3>

<p>
Dieses Schlüsselwort hat nur in der Schachform %::mc::VariantName(Antichess)% eine Bedeutung,
und kann in anderen Schachformen niemals erfüllt werden. Es wird erfüllt, wenn im nächsten
Zug die letzte gegnerische Figur geschlagen wird.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:takeslastpiece</keyword>)
</verb>

<p>
In der Schachformen %::mc::VariantName(Antichess)% wird es erfüllt, wenn im nächsten
Zug nicht die letzte gegnerische Figur geschlagen wird. In anderen Schachformen
wird diese Bedingung immer erfüllt.
</p>

<p>
Siehe auch: <cql>position:losing</cql>,
</p>

<!-- ############################################################################## -->
<h2 id="sequence">Schlüsselwörter für Sequenzen</h2>
<!-- ############################################################################## -->

<p>
Standard-CQL hat die folgende Einschränkung:
Die Gesamtzahl von Sequenzen in Positionslisten, die auf oberster Ebene
einer Positionsliste auftreten können, darf Eins nicht überschreiten.
Um die Wirkung von beiden Schlüsselwörtern in einer Positionsliste zu
erhalten, wird mit dem Gebrauch von <cql>position:and</cql> bewerkstelligt.
</p>

<p>
Diese Einschränkung gilt nicht für <nobr>CQL-S</nobr>, aber es ist zu beachten,
daß insbesondere die Verwendung von <cql>:gappedsequence</cql> bei geschachtelten
Sequenzen zu unerwarteten Resultaten führen kann. Auch die Kombination von
geschachtelten Sequenzen mit logischen Kontrollwörtern (<cql>:and</cql>, <cql>:or</cql>,
&hellip;) ist im allgemeinen sehr undurchsichtig.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:line">:line</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:line_">:line*</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:match">:match</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:matchconsecutive">:matchconsecutive</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:sequence">:sequence</a></td></tr>
</table>

<h3 id="position:gappedsequence">:gappedsequence&emsp;<n>(Löchrige Folge)</n></h3>

<p>
Erwartet als Argument eine Liste von Positionslisten. Eine Positionsliste A
wird als eine Verfeinerung einer Positionsliste B definiert, wenn A aus B
geformt werden kann durch das Einfügen von beliebig vielen (einschließlich Null)
Listen der Form <expr>(position)</expr> auf oberster Ebene in B. Zum Beispiel:
</p>

<verb>
((position &N;a4) (position) (position &R;b2))
</verb>

<p>
verfeinert
</p>

<verb>
((position &N;a4) (position &R;b2))
</verb>

<p>
denn es wurde geformt durch das Einfügen einer einzelnen Position in die
letztere Liste.
</p>

<p>
Eine löchrige Folge (<cql>position:gappedsequence</cql>) mit Argument B
filtert eine Position genau dann, wenn es eine Verfeinerung A von B gibt, so
daß eine Folge (<cql>position:sequence</cql>) mit Argument A diese Position
filtern würde. D.h., <cql>:gappedsequence</cql> ist wie
<cql>position:sequence</cql>, außer das die Folge von filternden Positionen
dazwischenliegende Positionen der Partie enthalten kann.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <keyword>position:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
Diese wird jede Position filtern, die mit der ersten Position in der Liste
von <cql>:gappedsequence</cql> startet, und nach Null oder mehr weiteren
aufeinanderfolgenden Positionen in der Partie die zweite Position von
<cql>:gappedsequence</cql> auffindet.
</p>

<p>
Die folgende Positionsliste filtert eine Position, in der ein Springer auf d4
steht in irgendeiner Partiestellung, aber nach der gefundenen Position:
</p>

<verbatim>
(position
  <keyword>position:gappedsequence</keyword> (
    (position)
    (position &N;d4)))
</verbatim>

<p>
Siehe auch: <cql>position:match</cql>.
</p>

<h3 id="position:line">:line<extension/>&emsp;<n>(Zugfolge)</n></h3>

<p>
Dieses Schlüsselwort bietet eine Kurzschreibweise für Sequenzen, die nur
Schlüsselwörter für die Zuganalyse verwendet. Daher bietet <cql>:line</cql>
nur wenig neue Funktionalität, ist aber meistens viel besser lesbar als die
enstprechende Formulierung mit <cql>:sequence</cql>. So ist die folgende Sequenz
</p>

<verbatim>
(position
  <cql>position:initial</cql>
  <cql>position:sequence</cql> (
    (position <cql>position:movefrom</cql> &P;e2 <cql>position:moveto</cql> e4)
    (position <cql>position:movefrom</cql> &p;e7 <cql>position:moveto</cql> e6)
    (position <cql>position:movefrom</cql> &P;d2 <cql>position:moveto</cql> d4)
    (position <cql>position:movefrom</cql> &p;d7 <cql>position:moveto</cql> d5)))
</verbatim>

<p>
identisch zur dieser Zugfolge:
</p>

<verbatim>
(position <keyword>position:line</keyword> (1.&P;e2-e4 &P;e7-e6 2.&P;d2-d4 &P;d7-d5))
</verbatim>

<p>
Auch unter <a href="CQL-Examples.html#line">CQL-Beispiele</a> sind gute
Beispiele für den Gebrauch von <cql>:line</cql> zu finden.
</p>

<p>
Das Argument von <cql>:line</cql> ist eine Folge von Zügen innerhalb eines
Klammernpaares. Die Zugfolge muß in der ausführlichen reversiblen Form notiert werden.
Grundsätzlich müssen die CQL-Figurenartbezeichner verwendet werden, und es können
Felderbezeichner eingesetzt werden. Es gibt sieben Zugnotationen:
</p>

<ol>
  <li>
    <b>Züge auf leere Felder</b><br/>
    Hier wird ein Bindestrich verwendet, z.B. <expr>&N;f3-e5</expr>, das Zielfeld
    e5 muß leer sein.
  </li>
  <li style="margin-top:5px">
    <b>Züge auf besetzte Felder</b><br/>
    Hier wird ein Schlagsymbol verwendet, z.B. <expr>&N;f3xe5</expr>, das Zielfeld
    e5 darf nicht leer sein.
  </li>
  <li style="margin-top:5px">
    <b>Züge auf leere oder besetzte Felder</b><br/>
    Hier wird ein Doppelpunkt verwendet, z.B. <expr>&N;f3:e5</expr>, das Zielfeld
    e5 kann leer sein, aber auch besetzt. Ist es nicht leer, dann ist es ein Schlagzug.
    Diese Notation ist auch in Verbindung mit Figurenartbezeichnern verwendbar, z.B.
    <expr>&N;f3:&n;e5</expr>: entweder ist das Feld e5 leer, oder es steht dort ein
    schwarzer Springer.
  </li>
  <li style="margin-top:5px">
    <b>Rochaden</b><br/>
    Mit dem speziellen Symbol <expr>O-O-O-O</expr> wird eine beliebige Rochade
    (lang oder kurz) bezeichnet. Wird für die Rochade eine Farbangabe benötigt
    dann sollte eine alternative Notation verwendet werden:
    <dir><table>
      <tr><td><expr>&K;-&Q;&emsp;</expr></td><td>Weiße lange Rochade</td></tr>
      <tr><td><expr>&k;-&q;&emsp;</expr></td><td>Schwarze lange Rochade</td></tr>
      <tr><td><expr>&K;-&K;&emsp;</expr></td><td>Weiße kurze Rochade</td></tr>
      <tr><td><expr>&k;-&k;&emsp;</expr></td><td>Schwarze kurze Rochade</td></tr>
      <tr><td><expr>&K;-&K;&Q;&emsp;</expr></td><td>Weiße Rochade (lang oder kurz)</td></tr>
      <tr><td><expr>&k;-&k;&q;&emsp;</expr></td><td>Schwarze Rochade (lang oder kurz)</td></tr>
    </table></dir>
  </li>
  <li style="margin-top:5px">
    <b>Einsetzzüge (%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%)</b><br/>
    Hier wird ein "at" verwendet und auf das Herkunftsfeld verzichtet, z.B.
    bezeichnet <expr>&N;@f3</expr> ein Zug, der einen weißen Springer auf das Feld f3
    einsetzt.
  </li>
  <li style="margin-top:5px">
    <b>Beliebige Zuge</b><br/>
    Dies wird durch die Notation <expr>--</expr> notiert, jedoch sind Nullzüge
    hier nicht eingeschlossen. Aber Einsetzzüge (%::mc::VariantName(DropChess)%,
    %::mc::VariantName(Bughouse)%) zählen dazu.
  </li>
  <li style="margin-top:5px">
    <b>Nullzüge</b><br/>
    Ein Nullzug wird mit dem speziellen Symbol <expr>null</expr> notiert.
  </li>
</ol>

<p>
Zu beachten ist, daß immer eine beliebige Figur angenommen wird, wenn der Figurenbezeichner
des Herkunftfeldes nicht angegeben ist (also nicht unbedingt ein Bauer wie sonst üblich).
Ist der Figurenbezeichner des Zielfeldes nicht angegeben, dann wird bei einem Schlagzug
immer eine beliebige Figur angenommen.
</p>

<p>
Ist das Herkunftsfeld beliebig, dann kann abkürzend für <expr>&N;??-e5</expr> auch
<expr>&N;e5</expr> notiert werden; entsprechend <expr>&N;xe5</expr> als Kurzschreibweise
für <expr>&N;??xe5</expr>, bzw. <expr>&N;:e5</expr> als Kurzschreibweise für
<expr>&N;??:e5</expr>.  Ist auch das Zielfeld beliebig, dann kann noch weitergehend
abgekürzt werden; so bezeichnet einfach nur <expr>&N;</expr> einen beliebigen Springerzug
auf ein freies Feld; <expr>&N;x</expr> ist eine beliebiger Springerzug auf ein besetztes
Feld, und <expr>&N;:</expr> ist ein beliebiger Springerzug auf ein freies oder auf ein
besetztes Feld.
</p>

<p>
Weiterhin können auch Schachgebote <nobr>(<expr>+</expr>)</nobr>, Doppelschachgebote
<nobr>(<expr>++</expr>)</nobr>, Kontaktschachgebote <nobr>(<expr>+++</expr>)</nobr>
und Mattgebote <nobr>(<expr>#</expr>)</nobr> notiert werden. Ebenso kann auch explizit
notiert werden das kein Schach geboten wird (mittels <nobr><expr>-</expr>)</nobr>, oder
kein Matt <nobr>(<expr>*</expr>)</nobr>, bzw. kein Doppelschach
<nobr>(<expr>--</expr>)</nobr>, oder kein Kontaktschach <nobr>(<expr>---</expr>)</nobr>.
Außerdem kann ein en-passant-Zug <nobr>(<expr>ep</expr>)</nobr> notiert werden, als
auch ein Bauernumwandlungszug (z.B. <nobr><expr>=&Q;</expr>)</nobr>. Bei einem
Bauernumwandlungszug ist die Angabe der verwandelten Figur zwingend. Mit dem Zeichen
<expr>!</expr> werden forcierte Züge (einzig möglicher Zug) ausgezeichnet.
</p>

<p>
Werden Zugnummern verwendet &ndash; sie müssen streng aufsteigend sein &ndash;
so werden diese bei der Suche mitberücksichtigt.
</p>

<p>
Beispiele:
</p>

<table class="stripes">
  <tr valign="top" class="stripes">
    <td class="l"><expr>e2-e4</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> ?e2<br/>
      <cql>position:moveto</cql> .e4
    </expr></td>
    <td class="r">
      Eine beliebige Figur zieht von e2 nach e4.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&P;e2-e4</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &P;e2<br/>
      <cql>position:moveto</cql> .e4
    </expr></td>
    <td class="r">
      Eine weißer Bauer zieht von e2 nach e4.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>1.e2-e4</expr></td>
    <td class="m"><expr>
      <cql>position:halfmovenumber</cql> 1<br/>
      <cql>position:movefrom</cql> ?e2<br/>
      <cql>position:moveto</cql> .e4
    </expr></td>
    <td class="r">
      Im ersten Zug der Partie zieht die Figur auf e2 nach e4
      (normalerweise ein Bauernzug).</td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>1...e7-e5</expr></td>
    <td class="m"><expr>
      <cql>position:halfmovenumber</cql> 2<br/>
      <cql>position:movefrom</cql> ?e7<br/>
      <cql>position:moveto</cql> .e5
    </expr></td>
    <td class="r">
      Im ersten Zug der Partie zieht die Figur auf e7 nach e5
      (normalerweise ein Bauernzug).</td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&P;d5xe6 ep</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &P;d5<br/>
      <cql>position:moveto</cql> .e6<br/>
      <cql>position:enpassant</cql>
    </expr></td>
    <td class="r">
      Weißer Bauer auf d5 schlägt en-passant den Bauern auf e5
      (nur ein Bauer kann en-passant geschlagen werden).
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&P;d5x&p;e6</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &P;d5<br/>
      <cql>position:moveto</cql> &p;e6
    </expr></td>
    <td class="r">
      Weißer Bauer auf d5 schlägt den Bauern auf e6
      (hier ist en-passant ausgeschlossen).
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&P;=&Q;</expr></td>
    <td class="m"><expr>
      <cql>position:promote</cql> &Q;
    </expr></td>
    <td class="r">
      Weißer Bauer zieht auf die Grundreihe und verwandelt
      in eine Dame.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&P;=&A;#</expr></td>
    <td class="m"><expr>
      <cql>position:promote</cql> &A;<br/>
      <cql>position:ismate</cql>
    </expr></td>
    <td class="r">
      Ein weißer Bauer zieht auf die Grundreihe, und verwandelt beliebig
      mit einem Mattgebot.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&Q;+*</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &Q;<br/>
      <cql>position:ischeck</cql><br/>
      <cql>!position:ismate</cql>
    </expr></td>
    <td class="r">
      Eine weiße Dame bietet dem König Schach, aber es ist
      kein Mattgebot.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&Q;+++</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &Q;<br/>
      <cql>position:iscontactcheck</cql>
    </expr></td>
    <td class="r">
      Eine weiße Dame bietet dem König Kontaktschach.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&N;b1-[ac]3</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &N;b1<br/>
      <cql>position:moveto</cql> .[ac]3
    </expr></td>
    <td class="r">
      Weißer Springer zieht von b1 nach a3 oder nach c3.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&b;[bg]7x&I;?1</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &b;[bg]7<br/>
      <cql>position:moveto</cql> &I;?1
    </expr></td>
    <td class="r">
      Schwarzer Läufer auf b7 oder g7 schlägt eine weiße
      Schwerfigur auf der ersten Reihe.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&M;?[1-7]-?8+</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &M;?[1-7]<br/>
      <cql>position:moveto</cql> .?8<br/>
      <cql>position:ischeck</cql>
    </expr></td>
    <td class="r">
      Eine weiße Schwerfigur zieht auf die schwarze Grundreihe
      und bietet Schach.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&M;?[1-7]-?8-</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &M;?[1-7]<br/>
      <cql>position:moveto</cql> .?8<br/>
      <cql>!position:ischeck</cql>
    </expr></td>
    <td class="r">
      Eine weiße Schwerfigur zieht auf die schwarze Grundreihe
      ohne ein Schachgebot.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&B;g5++</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &B;<br/>
      <cql>position:moveto</cql> .g5<br/>
      <cql>position:isdoublecheck</cql>
    </expr></td>
    <td class="r">
      Weißer Läufer zieht auf das Feld g5 und Schwarz wird
      Doppelschach geboten.</td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&N;:f7#</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &N;<br/>
      <cql>position:moveto</cql> ?f7<br/>
      <cql>position:ismate</cql>
    </expr></td>
    <td class="r">
      Weißer Springer zieht auf das Feld f7 und setzt matt;
      f7 kann auch von einer schwarzen Figur besetzt sein.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&n;x&P;e4</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &n;<br/>
      <cql>position:moveto</cql> &P;e4
    </expr></td>
    <td class="r">
      Ein schwarzer Springer schlägt einen Bauern auf dem Feld e4.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&N;xe4</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &n;<br/>
      <cql>position:moveto</cql> ?e4
    </expr></td>
    <td class="r">
      Ein weißer Springer schlägt eine beliebige Figur auf dem Feld e4.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&N;</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &N;<br/>
      <cql>position:moveto</cql> .
    </expr></td>
    <td class="r">
      Ein beliebiger Springerzug eines weißen Springers auf ein freies Feld.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&N;x</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &N;<br/>
      <cql>position:moveto</cql> &a;
    </expr></td>
    <td class="r">
      Ein beliebiger Springerzug eines weißen Springers auf ein besetztes Feld.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&N;x&m;</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &N;<br/>
      <cql>position:moveto</cql> &m;
    </expr></td>
    <td class="r">
      Ein beliebiger Springerzug eines weißen Springers,
      bei dem eine schwarze Schwerfigur geschlagen wird.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>x&m;</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &A;<br/>
      <cql>position:moveto</cql> &m;
    </expr></td>
    <td class="r">
      Ein beliebiger Zug mit einer weißen Figur,
      bei dem eine schwarze Schwerfigur geschlagen wird.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&N;:</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &N;:
    </expr></td>
    <td class="r">
      Ein beliebiger Springerzug eines weißen Springers auf ein freies
      oder auf ein besetztes Feld.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>O-O</expr></td>
    <td class="m"><expr>
      <cql>position:iscastling</cql> [&K;&k;]
    </expr></td>
    <td class="r">
      Die Seite am Zug führt die kurze Rochade aus.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>O-O-O</expr></td>
    <td class="m"><expr>
      <cql>position:iscastling</cql> [&Q;&q;]
    </expr></td>
    <td class="r">
      Die Seite am Zug führt die lange Rochade aus.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>O-O-O-O</expr></td>
    <td class="m"><expr>
      <cql>position:iscastling</cql>
    </expr></td>
    <td class="r">
      Die Seite am Zug führt eine Rochade aus (lang oder kurz).
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&K;-&Q;</expr></td>
    <td class="m"><expr>
      <cql>position:iscastling</cql> [&Q;]
    </expr></td>
    <td class="r">
      Weiß führt eine lange Rochade aus.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&k;-&k;&q;</expr></td>
    <td class="m"><expr>
      <cql>position:iscastling</cql> [&k;&q;]
    </expr></td>
    <td class="r">
      Schwarz führt eine Rochade aus (lang oder kurz).
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&K;!</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &K;<br/>
      <cql>position:forced</cql>
    </expr></td>
    <td class="r">
      Der weiße König zieht, und es handelt sich
      dabei um den einzig möglichen Zug in der Stellung.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&U;x[&Q;~&q;~]</expr></td>
    <td class="m"><expr>
      <cql>position:moveto</cql> [&Q;~&q;~]
    </expr></td>
    <td class="r">
      Die Seite am Zug schlägt eine Dame, die aus einer Bauernumwandlung
      hervorging.
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&Q;~~#</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &Q;~~<br/>
      <cql>position:ismate</cql>
    </expr></td>
    <td class="r">
      Eine weiße Dame, die nicht das Resultat einer Bauernumwandlung ist,
      setzt matt.
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>&P;@?7</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &P;[+]<br/>
      <cql>position:moveto</cql> ?7
    </expr></td>
    <td class="r">
      Eine weißer Bauer wird auf der siebten Reihe eingesetzt
      (%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%).
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>&A;@+</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &A;[+]<br/>
      <cql>position:ischeck</cql>
    </expr></td>
    <td class="r">
      Eine weiße Figur wird mit Schachgebot eingesetzt
      (%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%).
    </td>
  </tr>

  <tr valign="top">
    <td class="l"><expr>--</expr></td>
    <td class="m"><expr>
      <cql>position:movefrom</cql> &U;[*]
    </expr></td>
    <td class="r">
      Diese Kurzschreibweise bezeichnet einen beliebigen Zug
      (jedoch keinen Nullzug).
    </td>
  </tr>

  <tr valign="top" class="stripes">
    <td class="l"><expr>null</expr></td>
    <td class="m"><expr>
      <cql>position:isnull</cql>
    </expr></td>
    <td class="r">
      Dieses Symbol bezeichnet einen Nullzug.
    </td>
  </tr>
</table>

<p>
Die Zugfolgen können mit oder ohne Zugnummern notiert werden. Mit der Verwendung von
Zugnummern können statt den CQL-Standardfigurenartbezeichnern auch die normalen
<a href="http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm">PGN</a>-Figurenbezeichner
verwendet werden, denn hier ergeben sich die Figurenfarben aus der Position in der
Notation. Bei Gebrauch von Zugnummern kann <cql>position:flipcolor</cql> nicht mehr
verwendet werden.
</p>

<p>
Beispiele:
</p>

<box>
  <dl>
    <dt>
      <expr><keyword>position:line</keyword> (1.&P;e2-e4 &N;g8-f6)</expr>
    </dt>
    <dd>
      Suche nach Partien, die mit der Aljechin-Eröffnung beginnen.
      (die Figurenfarbe wird durch die Zugnummern bestimmt.)
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line</keyword> (2...&P;e7-e6)</expr>
    </dt>
    <dd>
      Suche nach Partien, in denen im zweiten Zug ein
      schwarzer Bauer von e7 nach e6 zieht.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line</keyword> (&P;e2-e4 &n;g8-f6)</expr>
    </dt>
    <dd>
      Suche nach einem Zugmuster irgendwo in der Partie.
      Dies wird auch alle Aljechin-Eröffnungspartien auffinden.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line</keyword> (&P;e2-e4 &N;g8-f6)</expr>
    </dt>
    <dd>
      Dieser Ausdruck wird als fehlerhaft zurückgewiesen (die Figurenfarben
      müssen alternieren, wenn keine Zugnummern vorhanden sind).
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line</keyword> (&P;c4x&P;d5 &n;f6x&P;d5 &N;c3x&N;d5 &p;e6x&N;d5)</expr>
    </dt>
    <dd>
      Suche nach einem typischen Schlagabtauschmuster.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line</keyword> ([&Q;&q;]x[&R;&r;])</expr>
    </dt>
    <dd>
      Die Seite am Zug schlägt mit der Dame einen Turm. Dies erspart zwar die Verwendung
      von <cql>position:flipcolor</cql>, aber für die Lesbarkeit ist grundsätzlich die
      Verwendung von <cql>position:flipcolor</cql> vorzuziehen.
    </dd>
  </dl>
</box>

<p>
Bei der Verwendung von Zugnummern muß dies konsequent geschehen, d.h. eine
Mischung von Sequenzen mit und ohne Zugnummern ist nicht zulässig.
</p>

<p>
Transformationen der Figuren- bzw. Felderbezeichner
(<cql>position:flip</cql>, <cql>position:shift</cql>,
usw.) wirken nicht auf das Schlüsselwort <cql>:line</cql>. Dazu muß
<cql>position:sequence</cql> verwendet werden, wenn solche Transformationen
verlangt sind. Aber die Farbwechseltransformation <cql>position:flipcolor</cql>
kann verwendet, wie bereits beschrieben wurde.
</p>

<p>
<cql>:line</cql> wartet mit einem zusätzlichen Funktionalität auf: mit dem
Trennzeichen <expr>|</expr> kann eine potentielle Zugfolge definiert werden.
Es sei folgende formale Beschreibung einer Zugfolge gegeben:
</p>

<verb>
<keyword>:line</keyword> (&lt;m<sub>1</sub>&gt; &lt;m<sub>2</sub>&gt; &hellip;
  &lt;m<sub>k</sub>&gt; | &lt;m<sub>k+1</sub>&gt; &hellip; &lt;m<sub>n</sub>&gt;)
</verb>

<p>
Es wird eine Partie genau dann gefunden, wenn in der Partie eine Zugfolge
<expr>&lt;m<sub>1</sub>&gt;</expr> <expr>&hellip;</expr> <expr>&lt;m<sub>k</sub>&gt;</expr>
existiert, so daß die Stellung (dies muß keine Endstellung sein) mit der restlichen Zugfolge
<expr>&lt;m<sub>k+1</sub>&gt;</expr> <expr>&hellip;</expr> <expr>&lt;m<sub>n</sub>&gt;</expr>
fortgesetzt werden könnte. Die Züge
<expr>&lt;m<sub>k+1</sub>&gt;</expr> <expr>&hellip;</expr> <expr>&lt;m<sub>n-1</sub>&gt;</expr>
sollten (müssen aber nicht) eindeutig bestimmt sein
(siehe bei <cql>position:line*</cql> wegen der eindeutigen Bestimmtheit), ansonsten kann
die Suchzeit exponentiell wachsen (d.h. die Suchzeit kann sich sehr rapide steigern).
</p>

<p>
Dazu ein Beispiel: wir suchen nach mehreren nacheinanderfolgenden Turmschachgeboten,
jeweils gefolgt von einem Königszug auf ein freies Feld. Dies kommt normalerweise
nur dann vor, wenn ein Patt durch Schlagen des Turms vermieden werden will.
</p>

<verbatim>
(match
  <cql>match:result</cql> 1/2
  (position
    <cql>position:sequence</cql> (
      (position
        <cql>position:flipcolor</cql>
        <cql>position:line</cql> (&R;:+ &k; &R;:+ &k; &R;:+ &k; &R;:+ | &k;))
      (position <cql>position:terminal</cql>))))
</verbatim>

<p>
Es wird hier am Ende der Partie gesucht. Es ist zu beachten, daß die gesuchten
Partien mit einem Turmzug oder aber mit einem Königszug enden
können. Endet eine solche Partie mit einem Turmzug, dann wird sie gefunden, wenn
in der Stellung nach dem letzten Turmzug ein Königszug möglich ist. Es werden aber
auch die Partien aufgefunden, die mit dem potentiellen Königszug enden. Es werden
also alle Partien aufgefunden, die entweder mit der Zugfolge
</p>

<dir>
  <expr>(&R;:+ &k; &R;:+ &k; &R;:+ &k; &R;:+ &k;)</expr>
</dir>

oder aber mit der Zugfolge

<dir>
  <expr>(&R;:+ &k; &R;:+ &k; &R;:+ &k; &R;:+)</expr>
</dir>

<p>
enden, wobei nach letzterer Zugfolge ein weiterer Königszug in der Stellung möglich
sein muss. Siehe bei <a href="CQL-Examples.html#line">Beispiele für Zugsequenzen</a>
für weitere Anwendungen potentieller Zugfolgen.
</p>

<p>
Siehe auch:
<cql>position:isnull</cql>,
<cql>position:line*</cql>,
<cql>position:movefrom</cql>,
<cql>position:moveto</cql>,
<cql>position:sequence</cql>.
</p>

<h3 id="position:line_">:line*<extension/>&emsp;<n>(Transpositionsinvariante Zugfolge)</n></h3>

<p>
Diese Version von <cql>position:line</cql> prüft Zugsequenzen
transpositionsinvariant, und die Suche beginnt deshalb immer mit dem ersten
Zug in der vorliegenden Grundstellung. Es können optional Zugnummern verwendet
werden, sie sind jedoch hier nicht erforderlich.  Eine transpositionsinvariante
Suche ist jedoch nur möglich wenn alle Züge eindeutig bestimmt sind (eindeutiges
Herkunftsfeld, eindeutiges Zielfeld, eindeutige Figuren, eindeutige
Bauernumwandlung). Dies ist erforderlich damit beispielsweise auch
Schach-960-Positionen korrekt geprüft werden. Weiterhin wird bei der
transpositionsinvarianten Suche ein mögliches en-passant-Recht ignoriert.
Transformierende Schlüsselwörter (<cql>position:flip</cql>,
<cql>position:flipcolor</cql>, &hellip;) sind in Verbindung mit
Transpositionsinvarianz nicht erlaubt.
</p>

<p>
Auch sind bei einer transpositionsinvarianten Suche die Angaben von Schach,
Doppelschach und Kontaktschach nicht erlaubt, außer im letzten Halbzug.
Solche Angaben im letzten Zug schränken im allgemeinen die möglichen
Transpositionen ein.
</p>

<p>
Potentielle Zugfolgen wie bei <cql>:line</cql> sind hier nicht erlaubt.
</p>

<p>
Beispiele:
</p>

<box>
  <dl>
    <dt>
      <expr><keyword>position:line*</keyword> (e2-e4 d7-d5)</expr>
    </dt>
    <dd>
      Dies ist eine fehlerhafter Ausdruck, die Figuren sind nicht eindeutig
      bestimmt.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line*</keyword> (&P;e2-e4 &P;d7-d5)</expr>
    </dt>
    <dd>
      Dies ist eine korrekter Ausdruck (die Figurenfarbe wird durch die
      Halbzugposition eindeutig bestimmt).
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line*</keyword> (&P;e2-e4 &p;d7-d5)</expr>
    </dt>
    <dd>
      Ebenfalls ein korrekter Ausdruck.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line*</keyword> (&P;e2-e4 &p;d7-d5 &P;e4xd5)</expr>
    </dt>
    <dd>
      Inkorrekt, denn die geschlagene Figur ist nicht eindeutig.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line*</keyword> (&P;e2-e4 &p;d7-d5 &P;e4x&P;d5)</expr>
    </dt>
    <dd>
      Korrekt, alles ist eindeutig bestimmt.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line*</keyword> (&P;e2-e?)</expr>
    </dt>
    <dd>
      Inkorrekt, denn das Zielfeld ist nicht eindeutig.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line*</keyword> (&P;e2-e4 &P;f7-f6 &Q;d1-h5+ &P;g7-g6)</expr>
    </dt>
    <dd>
      Inkorrekt, denn ein Schachgebot darf hier nicht notiert werden.
    </dd>
    <dt style="margin-top:10px">
      <expr><keyword>position:line*</keyword> (&P;e2-e4 &P;f7-f6 &Q;d1-h5+)</expr>
    </dt>
    <dd>
      Korrekt, ein Schachgebot im letzten Halbzug ist zulässig,
    </dd>
  </dl>
</box>

<p>
Weitere Beispiele:
</p>

<verbatim>
(position <keyword>position:line*</keyword> (1.&P;e2-e4 &P;e7-e6 2.&P;d2-d4 &P;d7-d5))
</verbatim>

<p>
Filtere alle Stellungen die mit Französisch beginnen, inklusive Zugumstellungen
wie 1.d4 d5 2.e4 e6. Dies ist in Partien, die mit der Standardstartposition beginnen,
äquivalent zur folgenden Abfrage:
</p>

<verbatim>
(position
  <cql>position:fen</cql> "rnbqkbnr/pppp1ppp/4p3/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2")
</verbatim>

<p>
Diese Äquivalenz trifft jedoch nicht für Partien zu, die nicht mit der Standardstartposition
beginnen.
</p>

<p>
Wird die exakte Eröffnungszugfolge 1.e4 e6 2.d4 d5 gesucht,
so geschieht dies mittels <cql>position:line</cql>:
</p>

<verbatim>
(position <cql>position:line</cql> (1.&P;e2-e4 &P;e7-e6 2.&P;d2-d4 &P;d7-d5))
</verbatim>

<p>
Siehe auch:
<cql>position:fen</cql>,
<cql>position:line</cql>,
</p>

<h3 id="position:match">:match<extension/>&emsp;<n>(Suchfolge)</n></h3>

<p>
Dies entspricht genau dem Verhalten der Suchliste <expr>(match</expr>
<expr>...)</expr>, nur daß hier ausnahmslos Positionslisten als Argumente
erwartet werden. Somit wird dieses Schlüsselwort normalerweise nicht
benötigt, es kann jedoch von Nutzen sein, wenn es als Argument für eines der
logischen Schlüsselwörter dient. Ein formales Beispiel:
</p>

<verbatim>
(match
  (position
    <cql>position:and</cql> (
      (position ...)
      (position <cql>position:match</cql> (
        (position ...)
        (position ...)
        ...
        (position ...))))))
</verbatim>

<h3 id="position:matchconsecutive">:matchconsecutive<extension/>&emsp;<n>(Sukzessive Suchfolge)</n></h3>

<p>
Diese Variante der Suchfolge filtert genau dann eine Partie, wenn alle Positionen
dieser Suchfolge nacheinander aufgefunden werden, jedoch unabhängig von der Reihenfolge.
</p>

<p>
Beispiel:
</p>

<verbatim>
(match
  (position
    <cql>position:flipcolor</cql>
    <keyword>position:matchconsecutive</keyword> (
      (position <cql>position:promote</cql> &B;)
      (position)
      (position <cql>position:promote</cql> &N;))))
</verbatim>

<p>
Filtert alle Partien, in denen nacheinander eine der Parteien eine
Bauernumwandlung in zwei verschiedene Leichtfiguren ausführt.
</p>

<h3 id="position:sequence">:sequence&emsp;<n>(Folge)</n></h3>

<p>
Erwartet als Argument eine Liste von Positionslisten. Eine Position wird
gefiltert, wenn sie und alle aufeinanderfolgenden Positionen von jedem
Element im Argument gefiltert werden.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  &R;e8
  <keyword>position:sequence</keyword> (
    (position &Q;f3 .g2)
    (position .f3 &Q;g2)))
</verbatim>

<p>
Diese Positionsliste filtert exakt diejenigen Positionen mit einem weißen Turm
auf e8, so daß:
</p>

<ol>
  <li>in dieser Position hat Weiß eine Dame auf f3, das Feld g2 ist leer, und</li>
  <li>nach dem nächsten Zug ist das Feld f3 leer, und die weiße Dame befindet sich auf g2.</li>
</ol>

<p>
Diese Positionsliste ist offensichtlich identisch zu:
</p>

<verb>
(position &R;e8 <cql>position:movefrom</cql> &Q;f3 <cql>position:moveto</cql> .g2)
</verb>

<p>
Außerdem ist sie identisch zu:
</p>

<verb>
(position &R;e8 <cql>position:line</cql> (&Q;f3-g2))
</verb>

<p>
Der folgende recht typische Gebrauch von <cql>:sequence</cql> sucht nach allen
Treppenschachmanövern mit einer Dame:
</p>

<verbatim>
(position
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <keyword>position:sequence</keyword> (
    (position <cql>position:movefrom</cql> &Q;a2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c4)
    (position <cql>position:check</cql>)))
</verbatim>

<p>
Diese Positionsliste filtert eine Position mit einer weißen Dame auf a2,
die nacheinander auf die bezeichneten Felder zieht und dabei Schach bietet.
Die Schlüsselwörter <cql>position:shift</cql>, <cql>position:flip</cql>, und
<cql>position:flipcolor</cql> suchen nach den gespiegelten oder gedrehten
Manövern irgendwo auf dem Schachbrett. Jedoch kann dies folgendermaßen
viel einfacher ausgedrückt werden:
</p>

<verbatim>
(position
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <cql>position:line</cql> (&Q;a2-b2+ -- &Q;b2-b3+ -- &Q;b3-c3+ -- &Q;c3-c4+))
</verbatim>

<p>
Siehe auch:
<cql>position:line</cql>,
<cql>position:matchconsecutive</cql>.
</p>

<!-- ############################################################################## -->
<h2 id="game">Schlüsselwörter für die Partieinformationen</h2>
<!-- ############################################################################## -->

<p>
Diese Schlüsselwörter beziehen sich auf Partiemerkmale und werden nicht von
den Positionen beeinflußt; sie sind als Schlüsselwörter für die Positionsliste
verfügbar, damit eine von diesen Merkmalen abhängige Suche gestaltet werden kann;
z.B. um Abfragen an die einzelnen <a href="Chess-Variants.html">Schachformen</a>
anzupassen.
</p>

<p>
Die Schlüsselwörter <cql>position:elo</cql>, <cql>position:whiteelo</cql> und
<cql>position:blackelo</cql> werden nur unterstützt, um kompatibel mit
Standard-CQL zu sein, und sollten nicht mehr in Positionslisten verwendet werden.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:elo">:elo</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ischess960">:ischess960</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isshufflechess">:isshufflechess</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:result">:result</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:startposition">:startposition</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:variant">:variant</a></td></tr>
</table>

<h3 id="position:blackelo">:blackelo&emsp;<n>(ELO &ndash; Schwarz)</n></h3>

<p>
Dieses Schlüsselwort wird nur unterstützt, um kompatibel mit dem CQL-Standard
zu sein. Es wird zur Verwendung des gleichnamigen Schlüsselworts
<cql>match:blackelo</cql> in der Suchliste geraten. Dort wird es auch genauer
beschrieben.
</p>

<h3 id="position:elo">:elo</h3>

<p>
Dieses Schlüsselwort wird nur unterstützt, um kompatibel mit dem CQL-Standard
zu sein. Es wird zur Verwendung des gleichnamigen Schlüsselworts
<cql>match:elo</cql> in der Suchliste geraten. Dort wird es auch genauer
beschrieben.
</p>

<h3 id="position:ischess960">:ischess960<extension/>&emsp;<n>(Schach-960?)</n></h3>

<p>
Filtert Partien, die mit einer Schach-960-Position beginnen. Dies beeinhaltet
die Standardstartposition 518. Diese Schlüsselwort ist eine Kurzschreibweise für:
</p>

<verb>
<cql>position:startposition</cql> 1-960
</verb>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:ischess960</keyword>)
</verb>

<p>
Filtert Partien, die nicht mit einer Schach-960-Position beginnen.
</p>

<p>
Siehe auch: <cql>position:isshufflechess</cql>.
</p>

<h3 id="position:isshufflechess">:isshufflechess<extension/>&emsp;<n>(Shuffle-Schach?)</n></h3>

<p>
Filtert Partien, die mit einer Schuffle-Schach-Position beginnen. Dies beinhaltet
Schach-960-Positionen. Diese Schlüsselwort ist eine Kurzschreibweise für:
</p>

<verb>
<cql>match:startposition</cql> 1-3840
</verb>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isshufflechess</keyword>)
</verb>

<p>
Filtert Partien, die nicht mit einer Schuffle-Schach-Position beginnen.
</p>

<p>
Siehe auch: <cql>position:ischess960</cql>.
</p>

<h3 id="position:result">:result&emsp;<n>(Ergebnis)</n></h3>

<p>
Dieses Schlüsselwort wird nur aus Kompatibilätsgründen zu CQL 1.0
unterstützt, sollte aber nicht mehr verwendet werden (denn <nobr>CQL-S</nobr>
bietet <cql>match:eithercolor</cql> als Erweiterung zu
<cql>position:flipcolor</cql>).
</p>

<p>
Dieses Schlüsselwort erwartet das gleiche Argument wie das Schlüsselwort
<cql>match:result</cql> in der Suchliste.
</p>

<h3 id="position:startposition">:startposition<extension/></h3>

<p>
Erwartet eine kommaseparierte Liste von Startpositionsbereichen. Eine Startposition
ist entweder eine Positionsnummer, oder eine FICS-Variantenbezeichnung. Ein
Startpositionsbereich ist eine Folge von Startpositionen.
Für eine genauere Beschreibung siehe bei <cql>match:startposition</cql>.
</p>

<p>
Siehe auch:
<cql>position:ischess960</cql>,
<cql>position:isshufflechess</cql>.
</p>

<h3 id="position:variant">:variant</h3>

<p>
Für eine Beschreibung dieses Schlüsselwortes siehe beim gleichnamigen
Schlüsselwort <cql>match:variant</cql> der Suchliste. Dieses
Schlüsselwort wird hier bereitgestellt, um bei einzelnen Positionslisten
eine Unterscheidung zwischen den
<a href="Chess-Variants.html">Schachformen</a> treffen zu können.
</p>

<h3 id="position:whiteelo">:whiteelo&emsp;<n>(ELO &ndash; Weiß)</n></h3>

<p>
Dieses Schlüsselwort wird nur unterstützt, um kompatibel mit dem CQL-Standard
zu sein. Es wird zur Verwendung des gleichnamigen Schlüsselworts
<cql>match:whiteelo</cql> in der Suchliste geraten. Dort wird es auch genauer
beschrieben.
</p>

<!-- ############################################################################## -->
<h2 id="relation">Relationen zwischen den Positionen</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:relation">:relation</a></td></tr>
</table>

<h3 id="position:relation">:relation</h3>

<p>
Das Argument, eine Relationenbeschreibung, wird benutzt um nach Partien zu
suchen, in denen Positionenpaare P1 und P2 gewisse Eigenschaften erfüllen.
Siehe <a href="CQL-Relation-List.html">Relationsliste</a> für eine
Beschreibung von Relationen.
</p>

<!-- ############################################################################## -->
<h2 id="matching">Schlüsselwörter zur Zählung</h2>
<!-- ############################################################################## -->

<p>
Diese Schlüsselwörter zählen die Anzahl der Positionen, die von einer
Positionsliste gefiltert werden. Jedes von ihnen erwartet eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> als Argument.
</p>

<p>
Laut Standard-CQL können sie nur in Positionslisten verwendet werden, die sich auf
oberster Ebene einer Suchliste befinden. Diese Einschränkung gilt nicht für
<nobr>CQL-S</nobr>.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pretransformrepetitioncount">:pretransformrepetitioncount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:repetitioncount">:repetitioncount</a></td></tr>
</table>

<h3 id="position:checkcount">:checkcount<extension/>&emsp;<n>(Schachgebotszähler)</n></h3>

<p>
Es werden zwei <a href="CQL-Range-Specifiers.html">Bereichsangaben</a> erwartet,
deren untere Schranken nicht kleiner als Null sein dürfen.
Eine Position wird gefiltert, wenn die Anzahl der Schachgebote, die Weiß von
Schwarz erhielt, innerhalb der ersten Bereichsangabe,
und die Anzahl der Schachgebote, die Schwarz von Weiß erhielt, innerhalb der
zweiten Bereichsangabe liegt. Die Bereichsangaben müssen mit dem Trennzeichen
<expr>:</expr> getrennt werden.
</p>

<note>
<cql>:checkcount</cql> ist in erster Linie nützlich in der Schachform
%::mc::VariantName(ThreeCheck)%. Die nachfolgenden Beispiele gelten
für diese Schachform.
</note>

<verb>
(position <keyword>position:checkcount</keyword> &lt;=2 : 3)
</verb>

<p>
Filtere eine Position wenn Schwarz insgesamt drei Schachgebote erhalten hat.
Dies kann nur eine Endstellung sein (in %::mc::VariantName(ThreeCheck)%).
Die Schachgebote, die Weiß erhielt, spielen hier keine Rolle, denn sie
können nur im Wertebereich Null bis 2 liegen.
</p>

<verb>
(position <cql>position:not</cql> <keyword>position:checkcount</keyword> 0 : 0)
</verb>

<p>
Dies ist tatsächlich eine sinnvolle Abfrage. Wir nehmen an, daß eine
der Partien mit folgender Position beginnt (beschrieben mit der
<a href="FEN.html">Forsyth-Edwards-Notation</a>):
</p>

<example>
rnb1k1nr/pppp1ppp/8/4p3/3PP2q/2N5/PP3PPP/R1BQKBNR w KQkq - 1 5 +0+2
</example>

<p>
Diese Position würde gefiltert werden (das Schlüsselwort <cql>:not</cql> ist zu
beachten), denn Schwarz hat dem weißen König bereits zweimal Schach geboten.
Mit anderen Worten: diese Abfrage sucht nach Partien die mit einer
fortgeschrittenen Stellung beginnen, wobei eine Seite der anderen bereits ein
Schachgebot gab. Kombiniert mit <cql>position:initial</cql> finden wir alle
Partien auf, die mit einer Startstellung beginnen, in denen eine der Seiten
bereits Schachgebote erhalten hat:
</p>

<verbatim>
(position
    <cql>position:initial</cql>
    <cql>position:not</cql> (position <keyword>position:checkcount</keyword> 0 : 0))
</verbatim>

<p>
Siehe auch: <cql>position:ischeck</cql>.
</p>

<h3 id="position:matchcount">:matchcount&emsp;<n>(Übereinstimmungszähler)</n></h3>

<p>
Filtert nur dann wenn die Anzahl der Positionen in der Partie, die von dieser
Positionsliste gefunden werden, innerhalb der gegebenen
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> liegt.
</p>

<p>
Beispiel:
</p>

<verb>
(position <cql>position:moveto</cql> [&Q;&q;] <keyword>position:matchcount</keyword> &gt;=4)
</verb>

<p>
Filtert jede Partie in der mindestens vier Damen geschlagen wurden.
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <keyword>position:matchcount</keyword> &gt;=4
  <cql>position:movefrom</cql> Q
  <cql>position:moveto</cql> ?[a1,a8,h1,h8])
</verbatim>

<p>
Filtert jede Partie, in denen eine weiße und eine schwarze Dame zusammen mindestens viermal
auf ein Eckfeld zog. Wird nach Partien gesucht, in denen jeweils die weiße und schwarze Dame
mindestend vier mal auf ein Eckfeld zog, dann wird stattdessen folgender Ausdruck verwendet:
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <cql>position:pretransformmatchcount</cql> &gt;=4
  <cql>position:movefrom</cql> Q
  <cql>position:moveto</cql> ?[a1,a8,h1,h8])
</verbatim>

<p>
Siehe dazu <cql>position:pretransformmatchcount</cql>.
</p>

<h3 id="position:pretransformmatchcount">:pretransformmatchcount&emsp;<n>(Prä-Transformation-Übereinstimmungszähler)</n></h3>

<p>
Dieses Schlüsselwort hat die gleiche Syntax wie <cql>position:matchcount</cql>.
Zur Beschreibung dieses Schlüsselwortes nehmen wir folgende allgemeine Form
einer Positionsliste an:
</p>

<verbatim>
(position
  T<sub>1</sub> T<sub>2</sub> ... T<sub>k</sub>
  X<sub>1</sub> X<sub>2</sub> ... X<sub>n</sub>
  <keyword>position:pretransformmatchcount</keyword> n<sub>1</sub> n<sub>2</sub>)
</verbatim>

<p>
Alle <expr>T<sub>i</sub></expr> sind die transformierenden Schlüsselwörter,
und alle anderen Elemente (nur keine Transformationsschlüsselwörter) sind mit
<expr>X<sub>i</sub></expr> bezeichnet. <expr>n<sub>1</sub></expr>
<expr>n<sub>2</sub></expr> ist die Bereichsangabe. Wir nehmen nun an, daß
<expr>Y<sub>i,j</sub></expr> ein Element bezeichnet das aus
<expr>X<sub>i</sub></expr> in einem der Transformationsschritte j ensteht
(möglicherweise identisch zu <expr>X<sub>i</sub></expr>, weil es
transformationsinvariant ist). <expr>m</expr> soll die Anzahl aller
Transformationsschritte bezeichnen. Nun bilden wir einen neuen Ausdruck:
</p>

<verbatim>
(position
  <cql>position:or</cql> (
    (position Y<sub>1,1</sub> Y<sub>2,1</sub> ... Y<sub>n,1</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    (position Y<sub>1,2</sub> Y<sub>2,2</sub> ... Y<sub>n,2</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    ...
    (position Y<sub>1,m</sub> Y<sub>2,m</sub> ... Y<sub>n,m</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)))
</verbatim>

<p>
Die Positionsliste mit <cql>:pretransformmatchcount</cql> filtert genau
diejenigen Positionen, die von der neugeformten Positionsliste gefiltert
werden. Mit anderen Worten: die Zählung erfolgt für jeden
Transformationsschritt einzeln.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <cql>position:moveto</cql> &U;d4
  <keyword>position:pretransformmatchcount</keyword> &gt;=12
  <cql>position:shift</cql>)
</verbatim>

<p>
Dies würde jede Partie finden in der mindestens 12 Figuren auf dem gleichen
Feld geschlagen wurden. Ersetzen wir <cql>:pretransformmatchcount</cql>
durch <cql>position:matchcount</cql>, dann würde diese Positionsliste Partien
auffinden in denen mindestens 12 Figuren irgendwo auf dem Schachbrett geschlagen
wurden.
</p>

<h3 id="position:pretransformrepetitioncount">:pretransformrepetitioncount<extension/>&emsp;<n>(Prä-Transformation-Wiederholungszähler)</n></h3>

<p>
Dieses Schlüsselwort hat die gleiche Syntax wie <cql>position:repetitioncount</cql>,
und ist so zu verstehen wie das ähnliche Schlüsselwort
<cql>position:pretransformmatchcount</cql>, nur daß <cql>:repetitioncount</cql>
aufeinanderfolgende Positionsmerkmale zählt.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <cql>position:moveto</cql> &U;d4
  <keyword>position:pretransformrepetitioncount</keyword> &gt;=6
  <cql>position:shift</cql>)
</verbatim>

<p>
Dies würde jede Partie finden in der mindestens sechs Figuren aufeinanderfolgend
auf dem gleichen Feld geschlagen wurden.
</p>

<h3 id="position:repetitioncount">:repetitioncount<extension/>&emsp;<n>(Wiederholungszähler)</n></h3>

<p>
Filtert eine Position, wenn sich die Positionsmerkmale aufeinanderfolgend wiederholen,
wobei die Anzahl der Wiederholungen durch eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> spezifiziert wird.
</p>

<p>
Beispiele:
</p>

<verb>
(position <cql>position:moveto</cql> &U; <keyword>position:repetitioncount</keyword> &gt;=10)
</verb>

<p>
Filtert jede Position, in der aufeinanderfolgend mindestens zehn Figuren geschlagen werden.
</p>

<verb>
(position <cql>position:moveto</cql> &U; <keyword>position:repetitioncount</keyword> 0)
</verb>

<p>
Filtert jede Partie, in der niemals eine Figur geschlagen wird. Dies ist äquivalent zu:
</p>

<verb>
(position <cql>position:moveto</cql> &U; <cql>position:matchcount</cql> 0)
</verb>

<!-- ############################################################################## -->
<h2 id="evaluation">Schlüsselwörter für die Stellungs- und Zugbeurteilung</h2>
<!-- ############################################################################## -->

<p>
Die folgenden Schlüsselwörter analysieren Positionen.
<cql>position:evaluation</cql> und <cql>position:moveevaluation</cql> sollten
mit Vorsicht verwendet werden, es sind sehr, sehr langsame Operationen. In einigen
Fällen mögen die Schlüsselwörter <cql>position:exchangeevaluation</cql> und
<cql>position:maxswapevaluation</cql> eine Alternative sein, diese Operationen
sind viel schneller, aber auch noch recht zeitverbrauchend.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:endgameevaluation">:endgameevaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:endgameevaluation_">:endgameevaluation*</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td></tr>
</table>

<h3 id="position:endgameevaluation">:endgameevaluation<extension/>&emsp;<n>(Endspielbewertung)</n></h3>

<p>
Dieses Schlüsselwort bewertet die aktuelle Endspielposition mit Hilfe von
Endspieltabellen (Tablebases). Dieses Schlüsselwort kann nur dann erfüllt
werden, wenn die entsprechenden Endspieltabellen lokal vorliegen (es erfolgt
keine Online-Abfrage).
</p>

<p>
Als erstes Argument wird spezifiziert, welches Ergebnis laut Endspieltabellen
bei bestem Spiel erzielt wird:
</p>

<box>
  <table>
    <tr>
      <td class="l"><expr>remis</expr></td><td class="r">Das Endspiel ist remis.</td>
    </tr>
    <tr>
      <td class="l"><expr>mate</expr></td><td class="r">Die Seite am Zug kann gewinnen.</td>
    </tr>
    <tr>
      <td class="l"><expr>*mate</expr></td><td class="r">Einer der Parteien kann gewinnen.</td>
    </tr>
    <tr>
      <td class="l"><expr>+mate</expr></td><td class="r">Weiß kann gewinnen.</td>
    </tr>
    <tr>
      <td class="l"><expr>-mate</expr></td><td class="r">Schwarz kann gewinnen.</td>
    </tr>
  </table>
</box>

<p>
Das optionale zweite Argument gibt an, wieviele Halbzüge minimal und maximal
bei beidseitig bestem Spiel erforderlich sind, um Matt zu setzen.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &U; 6
  <cql>position:piececount</cql> &P; 2
  <cql>position:piececount</cql> &p; 2
  <keyword>position:endgameevaluation</keyword> *mate)
</verbatim>

<p>
Filtert alle Positionen mit einem Endspiel <expr>&K;+&P;+&P;</expr> gegen
<expr>&K;+&P;+&P;</expr>, in dem einer der Parteien laut Endspieltabelle gewinnen kann.
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &U; 6
  <cql>position:piececount</cql> &P; 2
  <cql>position:piececount</cql> &p; 2
  <keyword>position:endgameevaluation</keyword> mate &gt;=40)
</verbatim>

<p>
Filtert alle Positionen mit einem Endspiel <expr>&K;+&P;+&P;</expr> gegen
<expr>&K;+&P;+&P;</expr>, in dem die Seite am Zug laut Endspieltabelle gewinnen
kann, aber dafür bei beidseitig bestem Spiel mindestens 40 Halbzüge zum Matt
benötigt.
</p>

<h3 id="position:endgameevaluation_">:endgameevaluation*<extension/>&emsp;<n>(Endspielbewertung)</n></h3>

<p>
Diese Version von <cql>position:endgameevaluation</cql> untersucht nur die Positionen,
in denen die spezifizierte Figurenkonstellation zum ersten Mal in der Partie erfüllt wird.
Somit ist diese Version unter Umständen erheblich schneller in der Suche.
</p>

<p>
TODO: wird nicht benötigt, denn dies kann mit <cql>position::cut</cql> realisiert werden:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &U; 6
  <cql>position:piececount</cql> &P; 2
  <cql>position:piececount</cql> &p; 2
  <keyword>position:endgameevaluation</keyword> mate &gt;=40
  <cql>position:cut</cql>)
</verbatim>

<h3 id="position:evaluation">:evaluation<extension/>&emsp;<n>(Bewertung)</n></h3>

<annotation>
Diese ist eine sehr langsame Operation und sollte eingeschränkt verwendet werden.
</annotation>

<p>
Dieses Schlüsselwort bewertet die aktuelle Position mit Hilfe eines externen
Schachprogramms. Die ersten beide Parameter bestimmen den Berechnungsmodus: 
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "sd <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">suche nur &lt;d&gt; Halbzüge tief</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">suche exakt &lt;ms&gt; Millisekunden pro Zug</td>
    </tr>
  </table>
</dir>

<p>
Jetzt kann entweder eine Mattsuche oder eine Stellungsbewertungssuche
spezifiziert werden.
</p>

<p>
Eine Mattsuche erwartet einen weiteren Parameter: nämlich das Wort <i>mate</i>
(für Matt). Die Abfrage ist erfolgreich, wenn ein Matt aufgefunden wurde.
</p>

<p>
Die Stellungsbewertungssuche erfordert zwei weitere Parameter.
Der erste davon ist eine <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>,
nur das hier Bauerneinheiten verwendet werden.  Die Abfrage ist erfolgreich,
wenn die Bewertung der Position innerhalb der gegebenen Grenzen
liegt.  Der zweite Parameter ist entweder <i>sidetomove</i> (Zugrecht)
oder <i>absolute</i> (absolut). <i>sidetomove</i> bedeutet, daß die
Bewertungswerte vom Zugrecht abhängig sind, und mit <i>absolute</i> sind die
Bewertungswerte unabhängig davon.
</p>

<note>
Beachte daß im Modus <i>movetime</i> die Angabe der Millisekunden auf
Centisekunden aufgerundet wird, wenn das verwendete Schachprogramm auf das
Protokoll <nobr>WinBoard</nobr>/<nobr>XBoard</nobr> eingeschränkt ist.
Steht dem Schachprogramm das UCI-Protokoll zur Verfügung, so wird die exakte
Millisekundenangabe verwendet.
</note>

<p>
Beispiele:
</p>

<verb>
<keyword>position:evaluation</keyword> depth 4 &gt;=2.5 sidetomove
</verb>

<p>
Die Seite mit dem Zugrecht hat (wahrscheinlich) eine Gewinnstellung, denn sie
ist mit mindestens 2,5 Bauerneinheiten im Vorteil.
</p>

<verb>
<keyword>position:evaluation</keyword> depth 4 &lt;=&#x2212;2.5 sidetomove
</verb>

<p>
Die Seite mit dem Zugrecht hat (wahrscheinlich) eine Verluststellung, denn sie
ist mit mindestens 2,5 Bauerneinheiten im Nachteil.
</p>

<verb>
<keyword>position:evaluation</keyword> movetime 3000 &lt;=&#x2212;3.0 absolute
</verb>

<p>
Schwarz ist (wahrscheinlich) verloren, denn er ist mindestens 3,0
Bauerneinheiten im Nachteil.
</p>

<verb>
<keyword>position:evaluation</keyword> depth 6 mate
</verb>

<p>
Eine der Seiten kann in spätestens 3 Zügen (6 Halbzüge) mattgesetzt werden.
</p>

<h3 id="position:exchangeevaluation">:exchangeevaluation<extension/>&emsp;<n>(Figurentauschbewertung)</n></h3>

<p>
Dieses Schlüsselwort analysiert Schlagzüge, um zu sehen ob sie profitabel
erscheinen.
</p>

<p>
Diese Funktion erfordert zwei bis drei Parameter. Der erste davon bezeichnet die maximale
Halbzugtiefe, die durchgerechnet wird.  Mit "*" wird eine unbegrenzte Halbzugtiefe spezifiziert.
Der zweite Parameter erwartet eine <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>,
nur das hier Bauerneinheiten verwendet werden. Der optionale dritte Parameter ist ein
Figurenbezeichner, es werden nur Schlagzüge berechnet, deren Zielfeld (das Feld, auf dem
die Figur gechlagen wird) mit diesem Figurenbezeichner spezifiziert ist.

Das Schlüsselwort filtert den aktuellen Zug, wenn der Wert innerhalb der
angegeben Grenzen der <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>
liegt, hier werden jedoch Bauerneinheiten verwendet. Nur Schlagzüge werden
bewertet. Die Bewertungsfunktion bezieht mit ein, daß Figuren gefesselt sein
können, oder daß sie von anderen Figuren gedeckt werden. Der Wert dieser
Funktion hängt nicht vom Zugrecht ab.
</p>

<p>
Bezüglich der Figurenwerte siehe <cql>position:power</cql>.
</p>

<p>
Beachte daß diese Funktion keine Stellungsbewertung vornimmt, stattdessen
wird nur der Schlagabtausch abgeschätzt.
</p>

<p>
Beispiel:
</p>

<verb>
<keyword>position:exchangeevaluation</keyword> * &lt;=&#x2212;2
</verb>

<p>
Dieser Schlagzug ist (wahrscheinlich) ein Patzer.
</p>

<verb>
<keyword>position:exchangeevaluation</keyword> 1 &gt;&#x2212;0 Q
</verb>

<p>
Die weiße Dame kann geschlagen werden.
</p>

<h3 id="position:maxswapevaluation">:maxswapevaluation<extension/>&emsp;<n>(Maximum einer Schlagabtauschbewertung)</n></h3>

<p>
Dieses Schlüsselwort erlaubt die Abschätzung von Zügen. Es erwartet
als Argument zwei Figurenbezeichner, gefolgt von einer
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>.
Das erste Argument spezifiziert die erlaubten Figuren und Felder des nächsten
Zuges, das zweite Argument spezifiziert die Zielfelder. Für jeden erlaubten
Zug wird ein Wert berechnet, der den materiellen Vorteil bzw. Verlust dieses
Zuges berechnet (in Bauerneinheiten), aufgrund möglicher Schlagabtäusche auf
dem Zielfeld. Abschliessend wird das Maximum alle berechneten Werte ausgewählt.
</p>

<p>
Das Schlüsselwort filtert eine Position wenn der berechnete Wert innerhalb der
gegebenen <a href="CQL-Range-Specifiers.html">Bereichsangabe</a> liegt, wobei
der Bereich in Bauerneinheiten spezifiziert wird. Die Bewertungsfunktion
bezieht mit ein, das Figuren gefesselt sein können, oder von anderen Figuren
gedeckt werden. Der Wert dieser Funktion hängt nicht vom Zugrecht ab.
</p>

<p>
Bezüglich der Figurenwerte siehe <cql>position:power</cql>.
</p>

<p>
Beachte daß diese Funktion keine Stellungsbewertung vornimmt, stattdessen
wird nur der Schlagabtausch abgeschätzt.
</p>

<note>
Dieses Schlüsselwort ist ähnlich dem Schlüsselwort <cql>:maxswapvalue</cql>
von Chess Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
aber auf sehr verschiedene Weise implementiert.
</note>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:maxswapevaluation</keyword> &A; &a; &gt;0)
</verb>

<p>
Diese Abfrage filtert Positionen, in denen Weiß mit Materialgewinn droht.
</p>

<verb>
(position <keyword>position:maxswapevaluation</keyword> &Q;?1-7 ??8 &gt;=0)
</verb>

<p>
Diese Abfrage filtert Positionen, in denen eine weiße Dame die achte Reihe
erobern kann ohne materiellen Verlust.
</p>

<h3 id="position:moveevaluation">:moveevaluation<extension/>&emsp;<n>(Zugbewertung)</n></h3>

<annotation>
Diese ist eine sehr langsame Operation und sollte eingeschränkt verwendet werden.
</annotation>

<p>
Dieses Schlüsselwort vergleicht die Differenz einer Stellungsbewertung der
aktuellen Position mit der nächsten Position. Die Bewertung wird mit
Einsatz eines externen Schachprogramm durchgeführt. Es werden sieben
Parameter erwartet. Die ersten beiden Parameter sind Figurenbezeichner. Der
erste davon spezifiziert die erlaubten Figuren und Felder des nächsten Zuges,
der zweite spezifiziert die Zielfelder. Der dritte und vierte Parameter
spezifizieren den Berechnungsmodus:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">suche nur &lt;d&gt; Halbzüge tief</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">suche exakt &lt;ms&gt; Millisekunden pro Zug</td>
    </tr>
  </table>
</dir>

<p>
Der fünfte Parameter ist die <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>
in Bauerneinheiten. Die Abfrage ist erfolgreich, wenn die Bewertung der Position
innerhalb der gegebenen Grenzen liegt. Der Wert des letzten Zuges ist die Differenz
zwischen der Bewertung der aktuellen Position und der Bewertung der vorangegangenen
Position. Im Falle von Mattpositionen ist die Differenz immer größer als 10.000.
</p>

<p>
Der sechste Parameter ist entweder <i>sidetomove</i> (Zugrecht) oder
<i>absolute</i> (absolut). <i>sidetomove</i> bedeutet, daß die Bewertungswerte
vom Zugrecht abhängig sind, und mit <i>absolute</i> sind die Bewertungswerte
unabhängig davon.
</p>

<note>
Beachte daß im Modus <i>movetime</i> die Angabe der Millisekunden auf
Centisekunden aufgerundet wird, wenn das verwendete Schachprogramm auf das
Protokoll <nobr>WinBoard</nobr>/<nobr>XBoard</nobr> eingeschränkt ist.
Steht dem Schachprogramm das UCI-Protokoll zur Verfügung, so wird die exakte
Millisekundenangabe verwendet.
</note>

<p>
Beispiele:
</p>

<verb>
<keyword>position:moveevaluation</keyword> &U; ? depth 4 &gt;=3.0 sidetomove
</verb>

<p>
Filtere die erste Position mit einer Bewertungsdifferenz von mindestens 3,0
Bauerneinheiten. Dies heißt. das der letzte Zug (wahrscheinlich) ein Patzer
war.
</p>

<verb>
<keyword>position:moveevaluation</keyword> &A; &a; depth 4 &lt;=&#x2212;3.0 absolute
</verb>

<p>
Filtere die erste Position, in der die Bewertungsdifferenz mindestens 3,0
Bauerneinheiten als Vorteil für Schwarz beträgt. Dies bedeutet, daß der letzte
weiße Zug (wahrscheinlich) ein Patzer war. Nur Schlagzüge werden bewertet.
</p>

<verbatim>
(match
  (position <keyword>position:moveevaluation</keyword> [&P;&p;] ?[?1,?8]
             &lt;=0.0 movetime 5000 absolute)
  (position <cql>position:promotion</cql> &U; <cql>position:cut</cql>))
</verbatim>

<p>
Suche nach Positionen, in denen sie Seite mit dem Zugrecht die erste
Bauernverwandlung in dieser Partie ausführt, aber keinen bessere
Stellungsbewertung dadurch erzielt. Wir stellten sicher, daß nur
Bauernumwandlungszüge bewertet werden.
</p>

<p>
Siehe auch:
<cql>position:endgameevaluation</cql>,
</p>

EXCLUDE-BEGIN

<h3 id="position:passedpawnrace">:passedpawnrace<extension/>&emsp;<n>(Freibauernrennen)</n></h3>

<p>
Dieses Schlüsselwort berechnet, ob die spezifizierte Seite bzw. die Seite am Zug
das Freibauernrennen in einer Position gewinnt. Es erwartet als optionales Argument
einen Figurenartbezeichner, wobei die Figurenarten folgende Bedeutung haben:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&P;</expr></td>
      <td class="r">Weiß gewinnt das Freibauernrennen.</td>
    </tr>
    <tr>
      <td class="l"><expr>&p;</expr></td>
      <td class="r">Schwarz gewinnt das Freibauernrennen.</td>
    </tr>
  </table>
</dir>

<p>
Ist keine Figurenart gegeben, dann wird für die Seite am Zug berechnet.
</p>

<p>
Es können nur die Positionen berechnet werden, in denen die spezifizierte Seite
Freibauern besitzt, und die andere Seite (möglicherweise auch die spezifizierte
Seite) hat außer dem König und Bauern keine weiteren Figuren. Alle anderen
Situationen können niemals gefiltert werden. Dieses Schlüsselwort ist insbesondere
dann interessant, wenn beide Seiten über Freibauern verfügen (in einem reinen
Bauernendspiel).
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>position:passedpawnrace</keyword>)
</verb>

<p>
Die Seite am Zug gewinnt das Freibauernrennen, sofern in dieser Position
die Seite am Zug Freibauern besitzt, und die andere Seite keine anderen
Figuren außer König und Bauern. Es können auch diejenigen Positionen
gefiltert werden, in denen die Seite, die nicht am Zug ist, keine Freibauern
besitzt.
</p>

<verbatim>
(position
  <cql>position:pawncount</cql> [&P;&p;] passed &gt;0 : &gt;0
  <keyword>position:passedpawnrace</keyword>)
</verbatim>

<p>
Beide Seiten verfügen über Freibauern, und die Seite am Zug kann
einen Freibauern verwandeln, bevor es die andere Seite kann (bzw.
nur die Seite am Zug kann einen Freibauern verwandeln).
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <cql>position:wtm</cql>
  <cql>position:unstoppablepawns</cql> [&P;&p;] &gt;0 : &gt;0
  <keyword>position:passedpawnrace</keyword> &p;)
</verbatim>

<p>
Beide Seiten verfügen über unaufhaltsame Freibauern, und die Seite, die
nicht am Zug ist, kann verwandeln, bevor es die andere Seite kann.
</p>

<p>
Siehe auch:
<cql>position:endgameevaluation</cql>,
<cql>position:unstoppablepawns</cql>.
</p>

<h3 id="position:unstoppablepawns">:unstoppablepawns<extension/>&emsp;<n>(Unaufhaltbare Bauern)</n></h3>

<p>
Dieses Schlüsselwort untersucht Positionen nach unaufhaltsamen Bauern auf dem
Weg zur Umwandlung (dies können nur Freibauern sein). Diese Funktion berechnet
mit einem schnellem Algorithmus ohne Einsatz eines Schachprogramms und kann nur
diejenigen Positionen berechnen, in denen die Seite, die die Freibauern stoppen
will, außer dem König und Bauern keine weiteren Figuren besitzt. In allen anderen
Situationen können keine unaufhaltsamen Bauern gefunden werden. Es wird bei der
Berechnung nicht berücksichtigt, welche Seite zuerst einen Bauern verwandeln
kann &ndash; wenn beispielsweise Weiß zuerst einen Bauern verwandeln könnte,
dann hat dies keinen Enfluß auf die Berechnung der unaufhaltsamen Bauern von
Schwarz.
</p>

<p>
Das erste Argument ist ein Figurenbezeichner, der keine anderen Figuren als
Bauern enthalten darf. Das zweite Argument ist eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es werden alle
Positionen gefiltert, in denen die Anzahl der unaufhaltsamen Bauern
innerhalb der Bereichsangabe liegt. Sind im Figurenbezeichner beide Farben
enthalten, dann können auch zwei Bereichsangaben, getrennt durch das Zeichen
<expr>:</expr>, mitgegeben werden. In diesem Fall wird eine Position gefiltert,
wenn die Anzahl der unaufhaltsamen weißen Bauern innerhalb der ersten
Bereichsangabe liegt, und die Anzahl der unaufhaltsamen schwarzen Bauern
innerhalb der zweiten Bereichsangabe.
</p>

<p>
Diese Funktion macht keine Aussage darüber, welche Seite zuerst die gegnerische
Grundreihe mit einem Bauern erreichen kann. Dazu sollte das Schlüsselwort
<cql>position:passedpawnrace</cql> eingesetzt werden.
</p>

<note>
<expr>unstoppablepawns</expr> sollte nicht mit <expr>pawncount</expr>
<expr>unstoppable</expr> verwechselt werden, letzteres hat eine völlig
andere Bedeutung.
</note>

<p>
Beispiel:
</p>

<verb>
(position <keyword>position:unstoppablepawns</keyword> &P; &gt;0)
</verb>

<p>
Filtert alle Positionen, in denen für Weiß mindestens ein unaufhaltsamer Bauer
berechnet wurde (was heißt, daß Schwarz in dieser Position außer dem König und
Bauern keine weiteren Figuren hat). Dies schließt nicht aus, daß auch Schwarz
unaufhaltsame Bauern besitzt, die möglicherweise zuerst verwandeln können.
</p>

<verb>
(position <keyword>position:unstoppablepawns</keyword> [&P;&p;][a-d?] &gt;0 : &gt;0)
</verb>

<p>
Filtert alle Positionen, in denen sowohl Weiß als auch Schwarz über unaufhaltsame
Bauern am Damenflügel verfügen.
</p>

<p>
Siehe auch: <cql>position:passedpawnrace</cql>.
</p>

EXCLUDE-END

<!-- ############################################################################## -->
<h2 id="accumulator">Schlüsselwörter für Akkumulationen</h2>
<!-- ############################################################################## -->

<p>
Es gibg hauptsächlich zwei Akkumulatorschlüsselwörter, <cql>:accumulate</cql>
und <cql>:sumrange</cql>. Diese werden verwendet um die Anzahl der
Transformationen einer Positionsliste zu zählen, die die aktuelle Position
filtern. Jedesmal wenn eine transformierte Positionsliste eine Position
filtert, wird der assoziierte Akkumulator inkrementiert. Jede Positionsliste
kann dann mit <cql>:sumrange</cql> testen, ob der akkumulierte Wert innerhalb
eines gewissen Bereichs liegt.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:accumulate_">:accumulate*</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td></tr>
</table>

<h3 id="position:accumulate">:accumulate&emsp;<n>(Akkumulieren)</n></h3>

<p>
Dies erwartet als Argument den Namen des Akkumulators. Jedesmal
wenn die Anwendung eines Elements auf die Menge der transformierten
Positionslisten eine Position filtert, wird der mit diesem Namen assoziierte
Akkumulator inkrementiert. Der Akkumulator wird wieder auf Null gesetzt,
sobald eine neue Position untersucht wird (nach einem Zug). Als Folge davon
sollte <cql>:accumulate</cql> nicht innerhalb von folgenden Schlüsselwörtern
verwendet werden: <cql>position:not</cql>, <cql>position:sequence</cql>,
und <cql>position:gappedsequence</cql>. Zu beachten ist daß
<cql>position:flipcolor</cql> in den meisten Fällen unerwartete Ergebnisse
hervorruft, wenn es zusammen mit <cql>:accumulate</cql> verwendet wird,
denn der Akkumulator wird nicht auf Null zurückgesetzt zwischen den
Farbwechseln.
</p>

<p>
Für Beispiele siehe:
<a href="CQL-Examples.html#accumulator">Benutzung von Akkumulatoren zur Zählung von Freibauern</a>.
</p>

<p>
Siehe auch: <cql>position:accumulate*</cql>.
</p>

<h3 id="position:accumulate_">:accumulate*<extension/>&emsp;<n>(Akkumulieren)</n></h3>

<p>
Um auch <cql>position:flipcolor</cql> verwenden zu können
bietet <nobr>CQL-S</nobr> eine Erweiterung, indem <expr>accumulate*</expr>
verwendet wird, hier wird für jede Farbe einzeln gezählt, dies macht eine
getrennte Zählung möglich.
</p>

<p>
Für ein Beispiel siehe: <a href="CQL-Examples.html#accumulator#passed-pawn"
>Benutzung von Akkumulatoren zur Zählung von Freibauern</a>.
</p>

<p>
Siehe auch: <cql>position:accumulate</cql>.
</p>

EXCLUDE-BEGIN

<h3 id="position:reset">:reset<extension/>&emsp;<n>(Zurücksetzen)</n></h3>

<p>
Diese Schlüsselwort erwartet als Argument den Namen des Akkumulators. Es setzt
den mit diesen Namen assoziierten Akkumulator nach der Anwendung einer
Transformationen wieder auf Null zurück. Wenn die Variante <expr>accumulate*</expr>
verwendet wird, dann werden Farbwechsel (durch <cql>position:flipcolor</cql>) nicht
zurückgesetzt.
</p>

<p>
Beispiel:
</p>

<p>
Trippelbauern können auf folgende Weise aufgefunden werden:
</p>

<verbatim>
(position
  <keyword>position:reset</keyword> akku
  &P;e2
  <cql>position:flipcolor</cql>
  <cql>position:accumulate*</cql> akku
  <cql>position:sumrange</cql> akku 3
  <cql>position:shiftvertical</cql>
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Beachte das dies nur ein Beispiel für eine Anwendung dieses Schlüsselwort ist
(aus <a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
es wird nicht geraten diese Abfrage für die Trippelbauersuche einzusetzen.
Eine viel bessere Abfrage dafür ist:
</p>

<verb>
(position <cql>position:pawncount</cql> triple &gt;0)
</verb>

EXCLUDE-END

<h3 id="position:sumrange">:sumrange<extension/>&emsp;<n>(Ergebnisbereich)</n></h3>

<p>
Dies erwartet als Argument den Namen eines Akkumulator und eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert eine
Position, wenn der Wert des bezeichneten Akkumulators innerhalb des gegebenen
Bereichs liegt. Wenn <cql>position:accumulate*</cql> verwendet wird, dann unterscheidet
<cql>:sumrange</cql> automatisch zwischen den Farben.
</p>

<p>
Für Beispiele siehe:
<a href="CQL-Examples.html#accumulator">Benutzung von Akkumulatoren zur Zählung von Freibauern</a>.
</p>

<!-- ############################################################################## -->
<h2 id="tagging">Schlüsselwörter für das Markieren</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td></tr>
</table>

<h3 id="position:tagmatch">:tagmatch<extension/>&emsp;<n>(Markierungsvergleich)</n></h3>

<p>
Das Schlüsselwort <cql>:tagmatch</cql> erwartet zwei Argumente, den Namen einer
Markierung und einen Figurenbezeichner. Es filtert nur dann wenn die an die
Markierung gebundene Figur vom zweiten Argument bezeichnet wird. Für weitere
Informationen siehe Abschnitt <a href="CQL-Tagging.html">Markierung</a>.
</p>

<!-- ############################################################################## -->
<h2 id="control">Schlüsselwörter für die Steuerung</h2>
<!-- ############################################################################## -->

<p>
Die folgenden steuernden Schlüsselwörter beeinflussen den Ablauf der Suche
bzw. das Suchergebnis.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:cut">:cut</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:exclude">:exclude</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:skip">:skip</a></td></tr>
</table>

<h3 id="position:cut">:cut<extension/>&emsp;<n>(Beschneiden)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es
parameterlos, oder es hat eine Positionsliste als Parameter.
In der ersten Form wird die Positionssuche in der aktuellen Haupt-/Untervariante
abgebrochen sobald die Bedingung der Positionsliste aufgefunden wird. In
der zweiten Form bricht die Suche in der aktuellen Haupt-/Untervariante
ab sobald die Bedingung des Arguments aufgefunden wird. Dieses
Schlüsselwort ist immer erfolgreich, mit anderen Worten: es beeinflußt
nicht das Resultat der anderen Filter.
</p>

<p>
Der <cql>:cut</cql>-Filter hat niedrigere Priorität als alle anderen Filter.
Das heißt, daß eine Position gefiltert wird, wenn alle anderen Filter diese
Position akzeptieren, unabhängig vom Resultat des <cql>:cut</cql>-Filters.
Soll die Suche aber immer mit einem negativen Resultat abschliessen, wenn
die <cql>:cut</cql>-Bedingung zutrifft, dann wird stattdessen das Schlüsselwort
<cql>position:exclude</cql> verwendet.
</p>

<note>
<cql>:cut</cql> hat eine niedrigere Priorität als <cql>position:exclude</cql>.
</note>

<p>
Beispiele für <cql>:cut</cql>:
</p>

<verbatim>
(match
  (position <cql>position:mate</cql>)
  (position <keyword>position:cut</keyword> <cql>position:check</cql>))
</verbatim>

<p>
Suche nach Partien die mit einem Matt enden, und keine der beiden Seiten hat
jemals zuvor Schach geboten. Hier kann <cql>:cut</cql> nicht durch
<cql>position:exclude</cql> ersetzt werden, denn ein Mattgebot enthält
immer auch ein Schachgebot, und dies würde auch die Partie ausschliessen.
</p>

<p>
Tatsächlich wäre das Schlüsselwort <cql>:cut</cql> für das obige
Suchkriterium nicht erforderlich, wie folgende Umformung zeigt:
</p>

<verbatim>
(match
  (position <cql>position:mate</cql>)
  (position <cql>position:check</cql> <cql>position:matchcount</cql> 1))
</verbatim>

<p>
Aber diese Version durchsucht evt. die gesamte Partie, und die vorhergehende Version
mit <cql>:cut</cql> schlägt bereits fehl sobald das erste Schachgebot erfolgt.
In vielen Fällen kann der Gebrauch des Schlüsselwortes <cql>:cut</cql> viel
effizienter sein als der Gebrauch von <expr>":matchcount</expr> <expr>1"</expr>.
</p>

<p>
Diese Suche nach dem ersten Schachgebot in der Partie, das zugleich auch Matt
bietet, kann auch mit <cql>position:checkcount</cql> formuliert werden:
</p>

<verbatim>
(match
  (position
    <cql>position:checkcount</cql> 1 : 0
    <cql>position:mate</cql>
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
Jedoch ist auch hier die Version mit <cql>:cut</cql> viel effizienter, denn auch
hier wird nicht nach dem ersten Schachgebot die Suche abgebrochen, d.h. es wird
unter Umständen die gesamte Partie durchsucht.
</p>

<h3 id="position:exclude">:exclude<extension/>&emsp;<n>(Ausschliessen)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es
parameterlos, oder es hat eine Positionsliste als Parameter.
In der ersten Form wird die aktuelle Variante ausgeschlossen wenn eine Position
von der Positionsliste gefiltert wird. In der zweiten Form wird die aktuelle
Variante ausgeschlossen, wenn das Resultat des Arguments positiv ist. Diese
Schlüsselwort beeinflußt nicht das Resultat der anderen Filter.
</p>

<p>
Dieses Schlüsselwort schließt selbst dann Varianten aus, wenn eine Position
gefiltert wurde bevor die <cql>:exclude</cql>-Bedingungen erfüllt wurden. Kurz
gesagt: <cql>:exclude</cql> schließt unter gewissen Bedingungen Partien
vollständig aus der Suche aus (wenn die Hauptvariante ausgeschlossen wurde).
</p>

<note>
<cql>:exclude</cql> hat eine höhere Priorität als <cql>position:cut</cql>.
</note>

<p>
Beispiel:
</p>

<verbatim>
(match
  (position &lt;A&gt;)
  (position <keyword>position:exclude</keyword> &lt;B&gt;))
</verbatim>

<p>
Suche nach Partien die eine Position enthalten, die Bedingung
<expr>&lt;A&gt;</expr> erfüllen, aber nicht wenn es in dieser Partie
eine Position gibt, die die Bedingung <expr>&lt;B&gt;</expr> erfüllt.
</p>

<p>
Soll <cql>:exclude</cql> nicht mehr wirken, nachdem &lt;A&gt; erfüllt ist,
dann kann folgender Ausdruck verwendet werden:
</p>

<verbatim>
(match
  (position <cql>position:cut</cql> &lt;A&gt;)
  (position <keyword>position:exclude</keyword> &lt;B&gt;))
</verbatim>

<p>
Aber hier wirkt <cql>:exclude</cql>, wenn &lt;A&gt; und &lt;B&gt;
zugleich erfüllt werden. Soll <cql>:exclude</cql> aber nur wirken,
solange &lt;A&gt; nicht erfüllt ist, so geschieht dies folgendermaßen:
</p>

<verbatim>
(match
  (position <cql>position:cond</cql> (
    (position &lt;A&gt;) (position <cql>position:cut</cql>)
    (position <keyword>position:exclude</keyword> &lt;B&gt;)))
</verbatim>

<p>
Zur Erinnerung: die Auswertungsreihenfolge in von links nach rechts.
</p>

<p>
Und soll <cql>:exclude</cql> nur dann wirken, nachdem &lt;A&gt; erfüllt
wurde, so geschieht dies mit:
</p>

<verbatim>
(match
  (position <cql>position:gappedsequence</cql> (
    (position &lt;A&gt;)
    (position <keyword>position:exclude</keyword> &lt;B&gt;)))
</verbatim>

<h3 id="position:skip">:skip<extension/>&emsp;<n>(Überspringen)</n></h3>

<p>
Mit Hilfe dieses Schlüsselwortes kann eine gefundene Stellung übersprungen werden.
Dies kann auch ohne die Verwendung dieses Schlüsselwortes formuliert werden, jedoch
ist die Formulierung der Positionsliste mit Hilfe dieses Schlüsselwortes manchmal
unkomplizierter, und dies resultiert oft in eine schnellere Suche.
</p>

<!-- ############################################################################## -->
<h2 id="meaningless">Bedeutungslose Schlüsselwörter</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#match:markall">:markall</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#match:noannotate">:noannotate</a></td></tr>
</table>

<h3 id="position:markall">:markall&emsp;<n>(Alles markieren)</n></h3>

<p>
Dieses Schlüsselwort wird unterstützt um kompatibel mit dem CQL-Standard
zu sein, es hat jedoch keinerlei Bedeutung in <nobr>CQL-S</nobr>.
</p>

<h3 id="position:noannotate">:noannotate&emsp;<n>(Nicht kommentieren)</n></h3>

<p>
Dieses Schlüsselwort wird unterstützt um kompatibel mit dem CQL-Standard
zu sein, es hat jedoch keinerlei Bedeutung in <nobr>CQL-S</nobr>.
</p>

END

<!-- vi:set ts=2 sw=2 et filetype=html fileencoding=latin1: -->
