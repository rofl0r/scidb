<!-- **********************************************************************
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
*********************************************************************** -->

<!-- **********************************************************************
* Copyright: (C) 2013 Gregor Cramer
*********************************************************************** -->

<!-- **********************************************************************
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*********************************************************************** -->

INDEX Positionsliste (CQL)
INDEX CQL Positionsliste

DEFINE <extension/> &ensp;<img src="../images/ft-scidb-tiny.png" />

TITLE CQL - Die Positionsliste

<p>
Das Symbol <img src="../images/ft-scidb-tiny.png" /> im Titel einer
Schlüsselwortdefinition kennzeichnet, daß dieses Schlüsselwort eine
Erweiterung ist, also nicht zum CQL-Standard gehört.
</p>

<p>
Die Schlüsselwörter <cql>position:castling</cql>, <cql>position:endgame</cql>,
<cql>position:inside</cql>, und <cql>position:reset</cql> sind von Chess
Assistant 9 entlehnt worden. Die Beschreibung dieser Schlüsselwörter entstammt
dem Dokument <a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#index">Index</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#logical">Schlüsselwörter für die Kontrolllogik</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#simple">Einfache Schlüsselwörter</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#transform">Transformierende Schlüsselwörter</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#piece">Schlüsselwörte für die Figurenanalyse</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#move">Schlüsselwörter für die Zuganalyse</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#sequence">Schlüsselwörter für Sequenzen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#game">Schlüsselwörter für die Partieinformationen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#relation">Relationen zwischen den Positionen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#matching">Schlüsselwörter zur Zählung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#evaluation">Schlüsselwörter für die Stellungsbeurteilung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#accumulator">Schlüsselwörter für Akkumulationen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#tagging">Schlüsselwörter für das Markieren</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#control">Schlüsselwörter für die Steuerung</a></td></tr>
  </table>
</dir>

<h2 id="index">Index</h2>

<dir>
  <table>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:and">:and</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:inside">:inside</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:promote">:promote</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:ray">:ray</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:markall">:markall</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:relation">:relation</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:reset">:reset</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:cut">:cut</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:result">:result</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:moveto">:moveto</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sequence">:sequence</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shift">:shift</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:endmost">:endmost</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exclude">:exclude</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nolosing">:nolosing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flip">:flip</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:variant">:variant</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:not">:not</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:or">:or</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piececount">:piececount</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:following">:following</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:power">:power</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:preceding">:preceding</a></td>
    </tr>
  </table>
</dir>

<h2 id="logical">Schlüsselwörter für die Kontrolllogik</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:and">:and</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:not">:not</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:or">:or</a></td></tr>
  </table>
</dir>

<h3 id="position:and">:and&emsp;<n>(und)</n></h3>

<p>
Erwartet eine Liste von Positionslisten, und filtert genau dann eine Position,
wenn jede von ihnen diese Position filtert.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <cql>position:wtm</cql>
  <cql>position:check</cql>
  <keyword>:and</keyword> (
    (position &K;e2 &k;g2 <cql>position:shift</cql> <cql>position:flip</cql>)
    (position &N;e2)))
</verbatim>

<p>
Filtert Positionen in denen die Könige in Opposition stehen, ein Springer auf
e2 platziert ist, und der weiße König steht im Schach.
</p>

<h3 id="position:not">:not&emsp;<n>(nicht)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es in
einer Positionsliste enthalten, oder es hat eine Positionsliste als Parameter.
Im ersten Fall filtert dieses Schlüsselwort, wenn die Positionsliste ohne dieses
Schlüsselwort nicht filtern würde. Im zweiten Fall: das Resultat des
Arguments wird negiert. Die erste Form ist konform mit dem CQL-Standard des
Schlüsselwortes <cql>:not</cql>, die zweite Form ist eine Erweiterung.
</p>

<p>
Beispiele:
</p>

<verbatim>
(match
  (position
    ; <comment>wir suchen für beide Seiten</comment>
    <cql>position:flipcolor</cql>
    <comment>; die Mattposition muß alle folgenden Kriterien erfüllen</comment>
    <cql>position:and</cql> (
      <comment>; der König ist von Leerfeldern umgeben, wird einmal</comment>
      <comment>; attackiert, und ist matt</comment>
      (position
        <cql>position:attackcount</cql> &k; . 8
        <cql>position:attackcount</cql> A &k; 1
        <cql>position:mate</cql>
        <cql>position:btm</cql>)
      <comment>; überprüfe daß kein Nachbar des schwarzen Königs</comment>
      <comment>; mehr als einmal attackiert wird</comment>
      (position
        <keyword>:not</keyword>
        <cql>position:attackcount</cql> &k; .e4 1
        <cql>position:attackcount</cql> A .e4 2 unlimited
        <cql>position:shift</cql>))))
</verbatim>

<p>
Dies findet alle Idealmatts: Studien in denen der König von Leerfeldern
umgeben ist und genau einmal angegriffen wird, so daß er auf einem
Nachbarsfeld ebenfalls genau einmal angegriffen wäre.
</p>

<p>
Die folgende Positionsliste
</p>

<verb>
(position &R;a3 <keyword>:not</keyword>)
</verb>

<p>
ist equivalent zu
</p>

<verb>
(position [a&Q;&B;&N;&P;&K;.]a3)
</verb>

<h3 id="position:or">:or&emsp;<n>(oder)</n></h3>

<p>
Erwartet eine Liste von Positionslisten, und filter genau dann eine Position,
wenn mindestens eine von ihnen diese Position filtert.
</p>

<p>
Beispiel:
</p>

<verbatim>
(match
  (position
    <keyword>:or</keyword> (
      (position <cql>position:piececount</cql>
        &B;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9)
      (position <cql>position:piececount</cql>
        &B;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9))))
</verbatim>

<p>
Suche nach Partien, die Positionen mit zwei gleichfarbigen Läufern auf einer
Seite beinhalten.
</p>

<h2 id="simple">Einfache Schlüsselwörter</h2>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:markall">:markall</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
  </table>
</dir>

<h3 id="position:blackcannotwin">:blackcannotwin<extension/>&emsp;<n>(Schwarz kann nicht gewinnen)</n></h3>

<p>
Filtere nur dann wenn der schwarze Spieler keine Gewinnmöglichkeit mehr hat.
</p>

<p>
Normalerweise ist dies equivalent zu folgender Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; nur schwarzer König</comment>
  (<cql>position:piececount</cql> a 1)
  <comment>; nur schwarzer König und schwarze Leichtfigur</comment>
  (<cql>position:piececount</cql> a 2 <cql>position:piececount</cql> i 1))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit <cql>:blackcannotwin</cql> nur dann, wenn Schwarz nur noch den König
besitzt, und in allen anderen Schachformen hat dieses Schlüsselwort keine
Bedeutung und ist immer erfolglos.
</p>

<p>
Siehe auch: <cql>position:whitecannotwin</cql>
</p>

<h3 id="position:btm">:btm&emsp;<n>(Schwarz am Zug)</n></h3>

<p>
Filtere nur wenn Schwarz am Zug ist.
</p>

<p>
Siehe auch: <cql>position:wtm</cql>.
</p>

<h3 id="position:check">:check&emsp;<n>(Schachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach.
</p>

<p>
Siehe auch: <cql>position:nocheck</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:checkcount">:checkcount<extension/>&emsp;<n>(Schachgebotszähler)</n></h3>

<p>
Ist das Argument ein einzelner Wert (zwischen 0 und 3 ist erlaubt),
dann werden alle Positionen gefiltert, in denen der letzte Zug der anderen
Seite zum n-ten mal Schach bot.
</p>

<p>
Hat der Parameter die Form <expr>+&lt;n<sub>1</sub>&gt;+&lt;n<sub>2</sub>&gt;</expr>,
wobei <expr>&lt;n<sub>i</sub>&gt;</expr> ein Wert zwischen 0 und 3 ist, so wird
die erste Position gefiltert, in der Weiß dem Schwarzen <nobr>n<sub>1</sub></nobr>
Schachgebote gab, und Schwarz dem Weißen <nobr>n<sub>2</sub></nobr> Schachgebote.
</p>

<note>
Diese Abfrage ist nur sinnvoll in der Schachform %::mc::VariantName(ThreeCheck)%,
in allen anderen Schachformen schlägt diese Abfrage immer fehl (ausgenommen
alle Parameterwerte sind Null).
</note>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:checkcount</keyword> 2)
</verb>

<p>
Filtere sobald eine der Seiten dem anderen sein zweites Schach bot.
</p>

<verb>
(position <keyword>:checkcount</keyword> +0+3)
</verb>

<p>
Filtere wenn Schwarz dem weißen König zum dritten Mal Schach bot. Dies kann nur
eine Endstellung sein.
</p>

<verb>
(position <cql>position:not</cql> <keyword>:checkcount</keyword> +0+0)
</verb>

<p>
Dies ist tatsächlich eine sinnvolle Abfrage. Wir nehmen an, daß eine
der Partien mit folgender Position beginnt (beschrieben mit der
<a href="FEN.html">Forsyth-Edwards-Notation</a>):
</p>

<dir><code>
rnb1k1nr/pppp1ppp/8/4p3/3PP2q/2N5/PP3PPP/R1BQKBNR w KQkq - 1 5 +0+2
</code></dir>

<p>
Diese Partie würde gefiltert werden (das Schlüsselwort <cql>:not</cql> ist zu
beachten), denn Schwarz hat dem weißen König bereits zweimal Schach geboten.
Mit anderen Worten: diese Abfrage sucht nach Partien die mit einer
fortgeschrittenen Stellung beginnen, wobei eine Seite der anderen bereits ein
Schachgebot gab.
</p>

<h3 id="position:castling">:castling<extension/>&emsp;<n>(Rochade)</n></h3>

<p>
Dieses Schlüsselwort spezifiziert die Rochademöglichkeiten beider Seiten.
Es erwartet als Argument einen Figurenartbezeichner, wobei die Figurenarten
folgende Bedeutung haben:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">Weiß besitzt das Recht zur kurzen Rochade</td>
    </tr>
    <tr>
      <td class="l"><expr>&Q;</expr></td>
      <td class="r">Weiß besitzt das Recht zur langen Rochade</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Schwarz besitzt das Recht zur kurzen Rochade</td>
    </tr>
    <tr>
      <td class="l"><expr>&q;</expr></td>
      <td class="r">Schwarz besitzt das Recht zur langen Rochade</td>
    </tr>
  </table>
</dir>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:castling</keyword> &K;)
</verb>

<p>
Weiß hast das Recht zu kurzen Rochade.
</p>

<verb>
(position <keyword>:castling</keyword> [&K;&Q;])
</verb>

<p>
Weiß has das Recht entweder für die kurze oder für die lange Rochade
(aber nicht für beide).
</p>

<verb>
(position <keyword>:castling</keyword> &K; <keyword>:castling</keyword> &Q;)
</verb>

<p>
Weiß hat das Recht für kurze und lange Rochade.
</p>

<h3 id="position:contactcheck">:contactcheck<extension/>&emsp;<n>(Kontaktschachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach, und es ist ein Kontaktschachgebot
(kein Zwischensetzen einer Figur möglich, auch nicht theoretisch).
</p>

<p>
Dies ist equivalent zu:
</p>

<verbatim>
(position
  <cql>position:check</cql> <comment>; um Schlagschachpartien auszufiltern</comment>
  <cql>position:or</cql> (
    (position <cql>position:doublecheck</cql>)
    (position <cql>position:attackcount</cql> [&N;&P;] &k; 1 <cql>position:flipcolor</cql>)
    (position [&Q;&R;]d4 &k;[c4,e4,d3,d5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)
    (position [&Q;&B;]d4 &k;[c3,c5,e3,e5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)))
</verbatim>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:doublecheck">:doublecheck<extension/>&emsp;<n>(Doppelschachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach, und es ist ein Doppelschachgebot.
</p>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:endgame">:endgame<extension/>&emsp;<n>(Endspiel)</n></h3>

<p>
Die Position ist eine Endspielposition. Dieses Schlüsselwort ist equivalent
zur folgenden Abfrage:
</p>

<verbatim>
  (position
    <cql>position:or</cql> (
      (position
      <cql>position:piececount</cql> [&Q;&q;] 0
      <cql>position:piececount</cql> [&R;&B;&N;] 0 3
      <cql>position:piececount</cql> [&r;&b;&n;] 0 3)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &q; 1
      <cql>position:piececount</cql> [&R;&r;] 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> i 0 1)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &R; 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> &q; 0
      <cql>position:power</cql> [&r;&b;&n;] 0 16
      <cql>position:flipcolor</cql>)))
</verbatim>

<p>
Siehe auch: <cql>position:noendgame</cql>.
</p>

<h3 id="position:fen">:fen<extension/></h3>

<p>
Die Position ist identisch zur beschriebenen Position im Argument. Dieses
Argument muß eine gültige <a href="FEN.html">FEN (Forsyth-Edwards-Notation)</a>
sein.
</p>

<h3 id="position:fiftymoverule">:fiftymoverule<extension/>&emsp;<n>(Fünfzig-Züge-Regel)</n></h3>

<p>
Die erste Position in der Partie, in der in den letzten 50 aufeinanderfolgenden
Zügen kein Stein geschlagen und auch kein Bauer gezogen wurde.
</p>

<p>
Siehe auch: <cql>position:halfmoveclocklimit</cql>.
</p>

<h3 id="position:gameisover">:gameisover<extension/>&emsp;<n>(Partie ist beendet)</n></h3>

<p>
Dies ist eine Kurzschreibweise für:
</p>

<verbatim>
  <cql>position:or</cql> (
    (position <cql>position:mate</cql>)
    (position <cql>position:stalemate</cql>)
    (position <cql>position:losing</cql>)
    (position <cql>position:checkcount 3</cql>)
    (position <cql>position:nomatingmaterial</cql>))
</verbatim>

<h3 id="position:initial">:initial&emsp;<n>(Startposition)</n></h3>

<p>
Dies ist die erste Position in der Partie (vor dem ersten Zug).
</p>

<h3 id="position:halfmoveclocklimit">:halfmoveclocklimit<extension/>&emsp;<n>(Halbzugzähler)</n></h3>

<p>
Dieses Schlüsselwort filtert Positionen, in denen der Halbzugzähler kleiner
oder gleich dem gegebenen Limit ist.
</p>

<p>
Halbzugzähler: Das ist die Anzahl der Halbzüge seit dem letzten Zug, in dem
ein Bauer zog oder eine Figur geschlagen wurde. Dieser Zähler entscheidet
auch, ob eine Seite ein Remis reklamieren kann aufgrund der 50-Züge-Regel
(<see/> <cql>position:fiftymoverule</cql>).
</p>

<p>
Beispiel:
</p>

<verb>
<keyword>:halfmoveclocklimit</keyword> 30
</verb>

<p>
Schließe alle Positionen aus, in denen in mehr als 30 Halbzügen (15 Züge
auf jeder Seite) kein Bauernzug erfolgte und auch kein Stein geschlagen
wurde.
</p>

<p>
Siehe auch: <cql>position:fiftymoverule</cql>.
</p>

<h3 id="position:losing">:losing<extension/>&emsp;<n>(Verlust)</n></h3>

<p>
Filtere nur Endstellungen, in denen eine der Seiten alle Figuren verlor.
Dies ist nur in Schlagschachpartien möglich.
</p>

<p>
Siehe auch: <cql>position:nolosing</cql>.
</p>

<h3 id="position:markall">:markall&emsp;<n>(Alles markieren)</n></h3>

<p>
Dieses Schlüsselwort wird unterstützt um kompatibel mit dem CQL-Standard
zu sein, es hat jedoch keinerlei Bedeutung in Scidb.
</p>

<h3 id="position:mate">:mate&emsp;<n>(Schachmatt)</n></h3>

<p>
Filtere nur dann, wenn es eine Mattstellung ist.
</p>

<annotation>
Wenn nach Mattstellungen gesucht wird, dann sollte stets auch dieses
Schlüsselwort mitverwendet werden auch wenn es aufgrund anderer
Bedingungen überflüssig erscheint, denn es beschleunigt die Suche (nur
Endstellungen werden geprüft).
</annotation>

<p>
Beispiel:
</p>

<verb>
(position <keyword>:mate</keyword> <cql>position:movenumber</cql> 1 20)
</verb>

<p>
Filtere nur dann wenn eine Seite in den ersten 20 Zügen mattgesetzt wurde.
</p>

<p>
Siehe auch: <cql>position:nomate</cql>.
</p>

<h3 id="position:matingmaterial">:matingmaterial<extension/>&emsp;<n>(Mattmaterial)</n></h3>

<p>
Filtere Positionen, in denen einer der Spieler noch über Mattmaterial verfügt
(<see/> <cql>position:nomatingmaterial</cql>).
</p>

<p>
Siehe auch: <cql>position:nomatingmaterial</cql>.
</p>

<h3 id="position:noannotate">:noannotate&emsp;<n>(nicht kommentieren)</n></h3>

<p>
Dieses Schlüsselwort wird unterstützt um kompatibel mit dem CQL-Standard
zu sein, es hat jedoch keinerlei Bedeutung in Scidb.
</p>

<h3 id="position:nocheck">:nocheck&emsp;<n>(kein Schachgebot)</n></h3>

<p>
Keine Seite befindet sich im Schach.
</p>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:nocontactcheck">:nocontactcheck<extension/>&emsp;<n>(kein Kontaktschachgebot)</n></h3>

<p>
Keine Seite befindet sich im Schach, oder aber es ist kein
Kontaktschachgebot (<see/> <cql>position:contactcheck</cql>).
</p>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:contactcheck</cql>.
</p>

<h3 id="position:nodoublecheck">:nodoublecheck<extension/>&emsp;<n>(kein Doppelschachgebot)</n></h3>

<p>
Keine der Seiten befindet sich im Schach, oder aber es ist kein
Doppelschachgebot.
</p>

<h3 id="position:noendgame">:noendgame<extension/>&emsp;<n>(kein Endspiel)</n></h3>

<p>
Diese Position ist keine Endspielposition (<see/>
<cql>position:endgame</cql>).
</p>

<p>
Siehe auch: <cql>position:endgame</cql>.
</p>

<h3 id="position:nomate">:nomate<extension/>&emsp;<n>(kein Schachmatt)</n></h3>

<p>
Schließe alle Mattstellungen aus.
</p>

<p>
Siehe auch: <cql>position:mate</cql>.
</p>

<h3 id="position:nomatingmaterial">:nomatingmaterial<extension/>&emsp;<n>(kein Mattmaterial)</n></h3>

<p>
Filtere nur Position, in denen keiner der Spieler noch über Mattmaterial
verfügt.
</p>

<p>
Normalerweise ist dies equivalent zur folgenden Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; König gegen König</comment>
  (<cql>position:piececount</cql> U 2)
  <comment>; König und Leichtfigur gegen König</comment>
  (<cql>position:piececount</cql> U 3 <cql>position:piececount</cql> [Ii] 1)
  <comment>; König and Läufer gegen König und Läufer,</comment>
  <comment>; beide Läufer entweder weiß- oder schwarzfeldrig</comment>
  (<cql>position:piececount</cql> U 4
   <cql>position:piececount</cql> [&B;&b;][a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,
     d6,d8,e1,e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2)
  (<cql>position:piececount</cql> U 4
   <cql>position:piececount</cql> [&B;&b;][a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,
     d5,d7,e2,e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit <cql>:nomatingmaterial</cql> nur dann, wenn nur noch Könige auf dem
Schachbrett sind, und in allen anderen Schachformen hat dieses Schlüsselwort
keine Bedeutung und ist immer erfolglos.
</p>

<p>
Siehe auch: <cql>position:matingmaterial</cql>.
</p>

<h3 id="position:nostalemate">:nostalemate<extension/>&emsp;<n>(kein Patt)</n></h3>

<p>
Filtere nur Positionen in denen niemand patt ist.
</p>

<p>
Siehe auch: <cql>position:stalemate</cql>,
</p>

<h3 id="position:repetition">:repetition<extension/>&emsp;<n>(Stellungswiederholung)</n></h3>

<p>
Filtere die erste Position in der Hauptvariante, die zum dritten Mal in der
Partie wiederholt wurden, mit der gleichen Seite am Zug, und den gleichen
Rochade- und en-passant-Rechten. Diese Wiederholung muß nicht aufeinanderfolgen.
Dies stimmt mit der FIDE-Regelung der
<a href="http://de.wikipedia.org/wiki/Stellungswiederholung">
Stellungswiederholung</a> überein.
</p>

<h3 id="position:stalemate">:stalemate&emsp;<n>(Patt)</n></h3>

<p>
Filtert nur Pattstellungen.
</p>

<p>
Siehe auch: <cql>position:nostalemate</cql>,
</p>

<h3 id="position:terminal">:terminal<extension/>&emsp;<n>(Endstellung)</n></h3>

<p>
Dies ist die letzte Position in der Partie.
</p>

<h3 id="position:variations">:variations&emsp;<n>(Varianten)</n></h3>

<p>
Ziehe die Untervarianten in die Suche mit ein. Ohne diese Angabe werden
die Untervarianten bei der Suche ausgelassen.
</p>

<h3 id="position:variationsonly">:variationsonly&emsp;<n>(Nur die Varianten)</n></h3>

<p>
Suche nur in den Untervarianten, nicht in der Hauptvariante.
</p>

<h3 id="position:whitecannotwin">:whitecannotwin<extension/>&emsp;<n>(Weiß kann nicht gewinnen)</n></h3>

<p>
Filtert nur dann wenn Weiß keine Gewinnmöglichkeit mehr hat.
</p>

<p>
Normalerweise ist dies equivalent zur folgenden Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; nur weißer König</comment>
  (<cql>position:piececount</cql> A 1)
  <comment>; nur weißer König und weiße Leichtfigur</comment>
  (<cql>position:piececount</cql> A 2 <cql>position:piececount</cql> I 1))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit <cql>:whitecannotwin</cql> nur dann, wenn Weiß nur noch den König
besitzt, und in allen anderen Schachformen hat dieses Schlüsselwort keine
Bedeutung und ist immer erfolglos.
</p>

<p>
Siehe auch: <cql>position:blackcannotwin</cql>
</p>

<h3 id="position:wtm">:wtm&emsp;<n>(Weiß am Zug)</n></h3>

<p>
Filtert nur wenn Weiß am Zug ist.
</p>

<h2 id="transform">Transformierende Schlüsselwörter</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:flip">:flip</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:inside">:inside</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shift">:shift</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:flip">:flip&emsp;<n>(Spiegelung)</n></h3>

<p>
Dies ist identisch zu <cql>position:flipdihedral</cql> (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipcolor">:flipcolor&emsp;<n>(Farbwechsel)</n></h3>

<p>
Die Farbwechseltransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipdiagonal">:flipdiagonal&emsp;<n>(Diagonale Spiegelung)</n></h3>

<p>
Die diagonale und gegendiagonale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipdihedral">:flipdihedral&emsp;<n>(Diedrische Transformation)</n></h3>

<p>
Die diedrische Transformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:fliphorizontal">:fliphorizontal&emsp;<n>(Horizontale Spiegelung)</n></h3>

<p>
Die horizontale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipvertical">:flipvertical&emsp;<n>(Vertikale Spiegelung)</n></h3>

<p>
Die vertikale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:inside">:inside<extension/>&emsp;<n>(innerhalb)</n></h3>

<p>
Dieses Schlüsselwort filtert Translationen, bei denen die involvierten Figuren
innerhalb einer bestimmten Region auf dem Schachbrett verbleiben. Es werden
zwei Argumente erwartet, ein Figurenbezeichner und ein Felderbezeichner.
Jegliche Translation beinflußt nur das erste Argument. Eine Translation wird
von der <cql>:inside</cql>-Beschränkung gefiltert, wenn mindestens eine Figur,
die mit dem ersten Argument bezeichnet wird (wobei die Transformation mit
einbezogen ist), auf einem Feld steht das vom zweiten Argument bezeichnet wird.
</p>

<p>
Beispiel:
</p>

<p>
Wir formulieren die folgende Abfrage um Trippelbauern aufzufinden:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Um Trippelbauern auf der Hauptdiagonalen (a1-h8) aufzufinden, erweitern
wir diese Abfrage:
</p>

<verbatim>
(position
  <keyword>:inside</keyword> &P;[b2-7] [b2,c3,d4,e5,f6,g7]
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<h3 id="position:shift">:shift&emsp;<n>(Translation)</n></h3>

<p>
Die Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftdiagonal">:shiftdiagonal&emsp;<n>(Diagonale Translation)</n></h3>

<p>
Die hauptdiagonale und gegendiagonale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shifthorizontal">:shifthorizontal&emsp;<n>(Horizontale Translation)</n></h3>

<p>
Die horizontale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftmaindiagonal">:shiftmaindiagonal&emsp;<n>(Hauptdiagonale Translation)</n></h3>

<p>
Die hauptdiagonale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftoffdiagonal">:shiftoffdiagonal&emsp;<n>(Gegendiagonale Translation)</n></h3>

<p>
Die gegendiagonale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftvertical">:shiftvertical&emsp;<n>(Vertikale Translation)</n></h3>

<p>
Die vertikale Translation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h2 id="piece">Schlüsselwörter für die Figurenanalyse</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piececount">:piececount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:power">:power</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:ray">:ray</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:attackcount">:attackcount&emsp;<n>(Angriffs-Zähler)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argumente zwei Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Der erste
ist der Figurenbezeichner der attackierenden Figuren, der zweite ist
der Figurenbezeichner der angegriffenen Figuren. Ein Angriff einer Figur
auf ein Feld liegt vor, wenn die bezeichnete Figur auf dieses Feld ziehen kann.
<cql>:attackcount</cql> zählt alle gültigen Züge (Angriffe), deren Ausgangsfeld
vom ersten Argument bezeichnet wird, und deren Zielfeld vom zweiten Argument
bezeichnet
wird.
</p>

<p>
<img src="../images/gameflag-Illegal-Move.png" />
<a href="http://www.rbnn.com/cql/">CQL Manual</a> sagt aus:
"disregarding any possible checks"; dies ergibt keinen Sinn.
</p>

<p>
Das Schlüsselwort <cql>:attackcount</cql> filtert eine Position, wenn die
Gesamtzahl aller gültigen Angriffe in dieser Position innerhalb der gegebenen
Bereichsangabe liegt.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2)
</verb>

<p>
Filtert jede Position mit einem Doppelangriff weißer Figuren auf den
schwarzen König (jedoch sollte für diese Abfrage
<cql>position:doublecheck</cql> in Verbindung mit <cql>position:btm</cql>
vorgezogen werden).
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2 <cql>position:flipcolor</cql>)
</verb>

<p>
Filtert jede Position mit einem Doppelangriff auf einen König
(auch hier sollte <cql>position:doublecheck</cql> vorgezogen werden).
</p>

<verb>
(position <keyword>:attackcount</keyword> A .h3 1)
</verb>

<p>
Filtert eine Position, in der genau eine weiße Figur auf das freie Feld h3
ziehen kann.
</p>

<verb>
(position <keyword>:attackcount</keyword> [&R;&B;][a-c8] ??1 5 9
</verb>

<p>
Filtert eine Position, in der die Anzahl der Möglichkeiten, daß ein weißer
Turm oder ein weißer Läufer auf den Feldern a8, b8, oder c8 auf ein Feld
der ersten Reihe ziehen kann, zwischen 5 und 9 liegt (inklusive).
</p>

<verb>
(position <keyword>:attackcount</keyword> &n; [&K;&R;&Q;] 3 unlimited)
</verb>

<p>
Filtert eine Position, in der es genau drei Möglichkeiten gibt, daß ein
schwarzer Springer den weißen König oder eine weiße Schwerfigur attackiert.
</p>

<h3 id="position:piececount">:piececount&emsp;<n>(Figurenzähler)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argument einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert
eine Position genau dann, wenn die Anzahl der Vorkommen einer bezeichneten
Figur in dieser Position innerhalb der gegebenen Bereichsangabe liegt.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:piececount</keyword> &R; 2)
</verb>

<p>
Dies wird jede Position filtern mit exakt zwei weißen Türmen - eine Position
mit drei weißen Türmen würde nicht gefiltert werden.
</p>

<verbatim>
(position
  &N;d4
  <keyword>:piececount</keyword> [&R;&r;][a1-8] 1 3
  <keyword>:piececount</keyword> [&Q;&q;][a-h8] 4)
</verbatim>

<p>
Dies wird jede Position filtern mit einem weißen Springer auf d4, ein bis drei
Türmen auf eine Linie, und exakt vier Damen auf der achten Reihe. Ein alternative
Schreibweise dieser Abfrage ist:
</p>

<verbatim>
(position
  &N;d4
  <keyword>:piececount</keyword> [&R;&r;][a?] 1 3
  <keyword>:piececount</keyword> [&Q;&q;][?8] 4)
</verbatim>

<h3 id="position:power">:power&emsp;<n>(Figurenpotential)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argument einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es wird
jede Position gefiltert, in der das Gesamtfigurenpotential in dieser Position
innerhalb der gegebenen Bereichsangabe liegt. Das Potential einer Figur
ist sein Materialwert, abhängig von der
<a href="Chess-Variants.html">Schachform</a>:
</p>

<dir>
  <table cellpadding="3">
    <tr>
      <td align="right"></td>
      <td align="right">&King;</td>
      <td align="right">&Queen;</td>
      <td align="right">&Rook;</td>
      <td align="right">&Bishop;</td>
      <td align="right">&Knight;</td>
      <td align="right">&Pawn;</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Normal)%, %::mc::VariantName(ThreeCheck)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Crazyhouse)%, %::mc::VariantName(Bughouse)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Losers)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 4</td>
      <td align="right"> 3</td>
      <td align="right"> 4</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Suicide)%, %::mc::VariantName(Giveaway)%&emsp;</td>
      <td align="right">30</td>
      <td align="right"> 3</td>
      <td align="right"> 9</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 1</td>
    </tr>
  </table>
</dir>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:power</keyword> a 6)
</verb>

<p>
Dies wird Positionen finden deren Gesamtfigurenpotential aller schwarzen
Figuren genau den Wert 6 hat.
</p>

<verb>
(position <keyword>:power</keyword> A[a-h1-4] 10 25)
</verb>

<p>
Dies wird Positionen finden deren Gesamtfigurenpotential aller weißen
Figuren in der weißen Hälfte einen Wert zwischen 10 und 25 aufweist (inklusive).
</p>

<h3 id="position:powerdifference">:powerdifference&emsp;<n>(Figurenpotentialdifferenz)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argument einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert
Positionen in denen die Differenz des Figurenpotentials (<see/>
<cql>position:power</cql>) der weißen und schwarzen Figuren, die vom ersten
Argument bezeichnet werden, innerhalb der gegebenen Bereichsangabe liegt.
D.h. das Figurenpotential aller bezeichneten weißen Figuren minus dem
Figurenpotential aller bezeichneten schwarzen Figuren muß innerhalb der
Bereichsangabe liegen.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:powerdifference</keyword> U 4)
</verb>

<p>
Dies filtert Positionen, in denen das Potential der weißen Figuren genau
um 4 größer ist als das Potential der schwarzen Figuren.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;] -5 10)
</verb>

<p>
Diese filtert Positionen, in denen Weiß ein Potential zwischen einem Turm
Materialnachteil und zwei Türmen Materialvorteil besitzt.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;&B;&b;&N;&n;] unlimited -2)
</verb>

<p>
Dies filtert Positionen, in denen Schwarz mindestens eine Qualität Vorteil hat.
</p>

<verbatim>
(match
  (position
    <cql>match:result</cql> 1-0
    <cql>position:sequence</cql> (
      (position
        <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9
        <keyword>:powerdifference</keyword> U unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9))
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
Dieses Beispiel zeigt eine Möglichkeit auf, wie mit Hilfe von
<cql>:powerdifference</cql> nach Damenopfern gesucht wird. Eine Seite opfert
eine Dame, und verbleibt mindestens 12 Züge lang mit mindestens 9 Bauern
Materialnachteil, um letztendlich zu gewinnen.
</p>

<h3 id="position:ray">:ray&emsp;<n>(Strahl)</n></h3>

<p>
Ein Strahl bezeichnet eine Liste von Figurenbezeichnern. Es ist eine
zusammenhängende Menge von Feldern entweder auf einer Linie, einer Reihe,
oder einer Diagonalen auf dem Schachbrett.
</p>

<p>
Sei R ein Felderstrahl mit einer geordneten Menge von Feldern in einer
zusammenhängenden Linie, Reihe, oder Diagonalen <nobr>S<sub>1</sub>,</nobr>
<nobr>S<sub>2</sub>,</nobr> <nobr>...,</nobr> <nobr>S<sub>n</sub>.</nobr>
Gegeben sei eine Strahlendefinition <nobr>(G<sub>1</sub>,</nobr>
<nobr>G<sub>2</sub>,</nobr> <nobr>...,</nobr> <nobr>G<sub>k</sub>),</nobr>
wobei jedes G einen Figurenbezeichner definiert. Der Felderstrahl R ist
gültig in Bezug auf die gegebene Strahlendefinition wenn
<nobr>G<sub>1</sub></nobr> eine Figur auf dem Feld <nobr>S<sub>1</sub></nobr>
bezeichnet, <nobr>G<sub>k</sub></nobr> eine Figur auf dem Feld
<nobr>S<sub>n</sub></nobr> bezeichnet, und wenn alle anderen
<nobr>G<sub>i</sub></nobr> jeweils mit einem Feld einer Untermenge
des Felderstrahls gepaart werden können ohne die Reihenfolge zu verletzen,
so daß jedes <nobr>G<sub>i</sub></nobr> eine Figur auf dem zugeordneten Feld
bezeichnet, und alle ungepaarten Felder leer sind.
</p>

<p>
Das Schlüsselwort <cql>:ray</cql> erwartet eine Strahlendefinition und eine
optionale <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Wenn die
Bereichsangabe nicht vorhanden ist, so wird <nobr><code>1</code>
<code>unlimited</code></nobr> als Bereich angenommen. <cql>:ray</cql> filtert
eine Position wenn die Anzahl der Felderstrahlen in dieser Position, die in
Bezug auf die Strahlendefinition gültig sind, innerhalb der Bereichsangabe
liegen.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:ray</keyword> (&k; &Q;))
</verb>

<p>
Filtert eine Position, in der eine weiße Dame den schwarzen König attackiert.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &n; &k;[?4-8]))
</verb>

<p>
Filtert eine Position, in der eine weiße Dame auf der a-Linie einen schwarzen
Springer fesselt, und der schwarze König auf den letzten vier Reihen steht.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &Q;c? &Q;e? &k;g?))
</verb>

<p>
Filtert entweder eine Position, in der alle drei weißen Damen und der schwarze
König auf der gleichen Reihe stehen mit jeweils exakt einem Leerfeld zwischen
diesen Figuren, oder eine Position, in der alle drei weißen Damen und der
schwarze König eine Diagonale formen mit jeweils einem Leerfeld zwischen diesen
Figuren, und die Damen stehen in beiden Fällen auf den a, c, und e-Linien.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q; &n; &k;) 2 4)
</verb>

<p>
Zwei bis vier schwarze Springer sind gefesselt.
</p>

<p>
Siehe auch: <cql>position:rayattack</cql>.
</p>

<h3 id="position:rayattack">:rayattack&emsp;<n>(Strahlenangriff)</n></h3>

<p>
Hat die gleiche Syntax wie <cql>position:ray</cql>. Es hat auch die gleiche
Semantik, außer das nur orthogonale Strahlen, die auf einem Feld mit einer
Schwerfigur starten, sowie diagonale Strahlen, die auf einem Feld mit einer
Dame oder einem Läufer starten, eingeschlossen sind.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:rayattack</keyword> (A a &k;))
</verb>

<p>
Filtert eine Position, in der eine schwarze Figur gefesselt ist.
</p>

<verb>
(position <keyword>:rayattack</keyword> (Ad5 a [&r;&k;][a-h1-4]) 3)
</verb>

<p>
Filtert Positionen, in denen drei schwarze Figuren von einer weißen Figur auf
d5 gefesselt werden, wobei ein schwarzer Turm und der schwarze König auf den
ersten vier Reihen stehen.
</p>

<verb>
(position <cql>position:stalemate</cql> <keyword>:rayattack</keyword>
(A a &k;) 2 8 <cql>position:flipcolor</cql>)
</verb>

<p>
Findet Pattstellungen mit Mehrfachfesselungen auf.
</p>

<p>
Siehe auch: <cql>position:ray</cql>.
</p>

<h3 id="position:raydiagonal">:raydiagonal&emsp;<n>(Diagonalstrahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf diagonale Linien beschränkt sind.
</p>

<h3 id="position:rayhorizontal">:rayhorizontal&emsp;<n>(Horizontaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf horizontale Linien beschränkt sind.
</p>

<h3 id="position:rayorthogonal">:rayorthogonal&emsp;<n>(Othogonaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf vertikale und horizontale Linien beschränkt sind.
</p>

<h3 id="position:rayvertical">:rayvertical&emsp;<n>(Vertikaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf  vertikale Linien beschränkt sind.
</p>

<h2 id="move">Schlüsselwörter für die Zuganalyse</h2>

<p>
Ein Zug hat drei Ausprägungen: einen Herkunftsbezeichner, einen
Zielbezeichner, und einen Bauernumwandlungsbezeichner. Diese beziehen
sich auf die Figur und das Feld von der dieser Zug weggeht; die Figur und
das Feld wohin dieser Zug geht (aber bevor dieser Zug tatsächlich erfolgt),
und die Figur und das Feld wo eine Bauernumwandlung stattfindet, sofern eine
solche vorhanden. In den Schachformen %::mc::VariantName(Crazyhouse)% und
%::mc::VariantName(Bughouse)% hat ein Zug noch eine vierte Ausprägung: den
Figurenartbezeichner für die Einsetzfigur. Er bezieht sich auf die Figurenart die
eingesetzt wird, sofern es ein Einsetzzug ist.
</p>

<p>
Beispielsweise ist der Zielbezeichner für einen weißen Turm auf a4, der
einen schwarzen Springer auf d4 schlägt: <expr>&n;d4</expr>, und der
Herkunftsbezeichner ist <expr>&R;a4</expr>. Der Zielbezeichner eines
Zuges nach e4, der keine Figur schlägt, ist <expr>.e4</expr>.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveto">:moveto</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nopiecedrop">:nopiecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:promote">:promote</a></td></tr>
  </table>
</dir>

<h3 id="position:enpassant">:enpassant</h3>

<p>
Der nächste Zug ist ein en-passant Schlagzug.
</p>

<p>
Siehe auch: <cql>position:noenpassant</cql>
</p>

<h3 id="position:iscastling">:iscastling<extension/>&emsp;<n>(Rochadezug?)</n></h3>

<p>
Der nächste Zug ist eine Rochade.
</p>

<p>
Siehe auch: <cql>position:nocastling</cql>.
</p>

<h3 id="position:movefrom">:movefrom&emsp;<n>(Zug von)</n></h3>

<p>
Erwartet als Parameter eine Figurenbezeichner. Eine Position wird gefiltert,
wenn dieser Figurenbezeichner den Herkunftsbezeichner des nächsten Zuges
beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:movefrom</keyword> &R;a3)
</verb>

<p>
Filter eine Position, in der der nächste Zug ein Turmzug von a3 ist.
</p>

<verb>
(position <keyword>:movefrom</keyword> U?8)
</verb>

<p>
Filter eine Position, in der der nächste Zug mit einer Figur von der
achten Reihe geschieht.
</p>

<verb>
(position <keyword>:movefrom</keyword> .)
</verb>

<p>
Dies kann niemals gefiltert werden, auch keinen Einsetzzug
(%::mc::VariantName(Crazyhouse)%, %::mc::VariantName(Bughouse)%).
Zur Erkennung von Einsetzzügen sollte <cql>position:piecedrop</cql>
verwendet werden.
</p>

<h3 id="position:movenumber">:movenumber&emsp;<n>(Zugnummer)</n></h3>

<p>
<cql>:movenumber</cql> erwartet als Argument eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>, und filtert eine
Position nur dann, wenn die aktuelle Zugnummer innerhalb des gegebenen
Bereichs liegt. Die Zugnummernzählung geht von einem Anzugsrecht der
weißen Seite aus.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:movenumber</keyword> 10 20 <cql>position:check</cql>)
</verb>

<p>
Filtert eine Position, in der ein Schachgebot zwischen dem 10. und dem
20. Zug erfolgt.
</p>

<verb>
(position <keyword>:movenumber</keyword> 35 <cql>position:mate</cql>)
</verb>

<p>
Filtert eine Position, in der im 35. Zug mattgesetzt wird.
</p>

<h3 id="position:moveto">:moveto&emsp;<n>(Zug nach)</n></h3>

<p>
Erwartet als Argument einen Figurenbezeichner. <cql>:moveto</cql> filtert
einen Zug wenn dieses Argument den Zielbezeichner des Zuges beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:moveto</keyword> U)
</verb>

<p>
Filtert eine Position dessen nächster Zug ein Schlagzug ist.
</p>

<verb>
(position <keyword>:moveto</keyword> .)
</verb>

<p>
Filtert eine Position dessen nächster Zug kein Schlagzug ist.
</p>

<verb>
(position <keyword>:moveto</keyword> &R;[b1-8])
</verb>

<p>
Filtert eine Position, in der der nächste Zug einen weißen Turm auf der
b-Linie schlagen wird. Beachte daß dies sehr verschieden ist von der
Interpretation einer Zugbeschreibung im
<a href="http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm">PGN-Format</a>&#x2006;:
dort würde dies als ein Turmzug auf die b-Linie interpretiert werden.
Und dies wiederum geschieht in CQL auf diese Weise:
</p>

<verb>
(position <cql>position:movefrom</cql> &R; <keyword>:moveto</keyword> ?b?)
</verb>

<p>
Filtert einen Zug, in dem der weiße Turm auf die b-Linie zieht.
Doch zurück zum vorigen Beispiel:
</p>

<verb>
(position <keyword>:moveto</keyword> &R;[b1-8])
</verb>

<p>
Dies kann keinen Einsetzzug filtern (betrifft die Schachformen
%::mc::VariantName(Crazyhouse)% und %::mc::VariantName(Bughouse)%).
Soll aber auch ein Einsetzzug damit gefiltert werden, dann ist ein
erweiterter Ausdruck notwendig:
</p>

<verbatim>
(position
  <cql>position:or</cql> (
    (<keyword>:moveto</keyword> &R;[b1-8])
    (<cql>position:piecedrop</cql> &R;[b1-8])))
</verbatim>

<h3 id="position:nocastling">:nocastling<extension/>&emsp;<n>(kein Rochadezug?)</n></h3>

<p>
Der nächste Zug ist keine Rochade.
</p>

<p>
Siehe auch: <cql>position:iscastling</cql>.
</p>

<h3 id="position:noenpassant">:noenpassant&emsp;<n>(kein en-passant-Zug?)</n></h3>

<p>
Der nächste Zug ist kein en-passant Schlagzug.
</p>

<p>
Siehe auch: <cql>position:enpassant</cql>.
</p>

<h3 id="position:piecedrop">:piecedrop<extension/>&emsp;<n>(Einsetzzug)</n></h3>

<p>
Der nächste Zug ist ein Einsetzzug, wobei der im Argument gebenene
Figurenbezeichner den Figurenbezeichner für die Einsetzfigur des
nächsten Zuges beinhalten muß. Dies ist bei einem nichtleeren
Figurenbezeichner nur möglich in den Schachformen
%::mc::VariantName(Crazyhouse)% und %::mc::VariantName(Bughouse)%.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:piecedrop</keyword> [&N;&n;])
</verb>

<p>
Der nächste Zug ist ein Einsetzzug, der einen Springer einsetzen wird.
</p>

<verb>
(position <keyword>:piecedrop</keyword> [&Q;]f7)
</verb>

<p>
Der nächste Zug ist ein Einsetzzug, der eine weiße Dame auf f7 einsetzen wird.
</p>

<verb>
(position <keyword>:piecedrop</keyword> [])
</verb>

<p>
Der nächste Zug ist kein Einsetzzug (denn der Figurenartbezeichner ist leer).
</p>

<h3 id="position:promote">:promote&emsp;<n>(Bauernumwandlung)</n></h3>

<p>
Erwartet als Argument einen Figurenbezeichner. Ein Zug wird gefiltert wenn
es sich um eine Bauernumwandlung handelt, und der gegebene Figurenbezeichner
den Bauernumwandlungsbezeichner des Zuges beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:promote</keyword> [&R;&B;&N;])
</verb>

<p>
Filtert eine Position dessen nächster Zug eine weiße Unterverwandlung ist.
</p>

<verb>
(position <keyword>:promote</keyword> [&B;&N;]a8)
</verb>

<p>
Filtert eine Position dessen nächster Zug eine weiße Bauernumwandlung in
eine Leichtfigur ist.
</p>

<verb>
(position <keyword>:promote</keyword> [&R;e8]
<cql>position:movefrom</cql> &P;f7 <cql>position:moveto</cql> &q;)
</verb>

<p>
Filtert eine Position, in der der nächster Zug einen Bauern von f7 nach e8
zieht, wobei eine schwarze Dame geschlagen wird und eine Bauernumwandlung
in einen Turm geschieht.
</p>

<verb>
(position <keyword>:promote</keyword> [])
</verb>

<p>
Filtert eine Position, in der der nächster Zug keine Bauernumwandlung ist
(denn der Figurenartbezeichner ist leer).
</p>

<h2 id="sequence">Schlüsselwörter für Sequenzen</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sequence">:sequence</a></td></tr>
  </table>
</dir>

<h3 id="position:gappedsequence">:gappedsequence&emsp;<n>(Löchrige Folge)</n></h3>

<p>
Erwartet als Argument eine Liste von Positionslisten. Eine Positionsliste A
wird als eine Verfeinerung einer Positionsliste B definiert, wenn A aus B
geformt werden kann durch das Einfügen von beliebig vielen (einschließlich Null)
Listen der Form <expr>(position)</expr> auf oberster Ebene in B. Zum Beispiel:
</p>

<verb>
((position &N;a4) (position) (position &R;b2))
</verb>

<p>
verfeinert
</p>

<verb>
((position &N;a4) (position &R;b2))
</verb>

<p>
denn es wurde geformt durch das Einfügen einer einzelnen Position in die
letztere Liste.
</p>

<p>
Eine löchrige Folge (<cql>position:gappedsequence</cql>) mit Argument B
filtert eine Position genau dann, wenn es eine Verfeinerung A von B gibt, so
daß eine Folge (<cql>position:sequence</cql>) mit Argument A diese Position
filtern würde. D.h., <cql>:gappedsequence</cql> ist wie
<cql>position:sequence</cql>, außer das die Folge von filternden Positionen
dazwischenliegende Positionen der Partie enthalten kann.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
Diese wird jede Position filtern, die mit der ersten Position in der Liste
von <cql>:gappedsequence</cql> startet, und nach Null oder mehr weiteren
aufeinanderfolgenden Positionen in der Partie die zweite Position von
<cql>:gappedsequence</cql> auffindet. Dasselbe Ergebnis kann viel effektiver
auf folgende Weise ermittelt werden:
</p>

<p>
<img src="../images/gameflag-Illegal-Move.png" />
Das ist zu prüfen!
</p>

<verbatim>
(position
  <cql>position:initial</cql>
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
Die folgende Positionsliste filtert eine Position, in der ein Springer auf d4
steht in irgendeiner Partiestellung, aber nach der gefundenen Position:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position)
    (position &N;d4)))
</verbatim>

<p>
Die Gesamtzahl von <cql>:sequence</cql> und <cql>:gappedsequence</cql>
Positionslisten, die auf oberster Ebene einer Positionsliste auftreten
können, darf Eins nicht überschreiten. Um die Wirkung von beiden
Schlüsselwörtern in einer Positionsliste zu erhalten, wird mit dem
Gebrauch von <cql>position:and</cql> bewerkstelligt.
<br/><img src="../images/gameflag-Illegal-Move.png" />
Diese Einschränkung ist zu prüfen!
</p>

<h3 id="position:sequence">:sequence&emsp;<n>(Folge)</n></h3>

<p>
Erwartet als Argument eine Liste von Positionslisten. Eine Position wird
gefiltert, wenn sie und alle aufeinanderfolgenden Positionen von jedem
Element im Argument gefiltert werden.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  &R;e8
  <keyword>:sequence</keyword> (
    (position &Q;f3 .g2)
    (position .f3 &Q;g2)))
</verbatim>

<p>
Diese Positionsliste filtert exakt diejenigen Positionen mit einem weißen Turm
auf e8, so daß:
</p>

<ol>
  <li>in dieser Position hat Weiß eine Dame auf f3, das Feld g2 ist leer, und</li>
  <li>nach dem nächsten Zug ist das Feld f3 leer, und die weiße Dame befindet sich auf g2.</li>
</ol>

<p>
Diese Positionsliste ist offensichtlich identisch zu:
</p>

<verb>
(position &R;e8 <cql>position:movefrom</cql> &Q;f3 <cql>position:moveto</cql> .g2)
</verb>

<p>
Der folgende recht typische Gebrauch von <cql>:sequence</cql> sucht nach allen
Treppenschachmanövern mit einer Dame:
</p>

<verbatim>
(position
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <keyword>:sequence</keyword> (
    (position <cql>position:movefrom</cql> &Q;a2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c4)))
</verbatim>

<p>
Diese Positionsliste filtert eine Position mit einer weißen Dame auf a2,
die nacheinander auf die bezeichneten Felder zieht und dabei Schach bietet.
Die Schlüsselwörter <cql>position:shift</cql>, <cql>position:flip</cql>, und
<cql>position:flipcolor</cql> suchen nach den gespiegelten oder gedrehten
Manövern irgendwo auf dem Schachbrett.
</p>

<h2 id="game">Schlüsselwörter für die Partieinformationen</h2>

<p>
Diese Schlüsselwörter beziehen sich auf Partiemerkmale und werden nicht von
den Positionen beeinflußt; sie sind als Schlüsselwörter für die Positionsliste
verfügbar, damit die <cql>position:flipcolor</cql> Operation auf sie
angewendet werden kann; oder um Abfragen an die einzelnen
<a href="Chess-Variants.html">Schachformen</a> anzupassen.
</p>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    </tr>
    <tr>
      <td>              </td><td></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    </tr>
  <tr>
      <td>      &#x2022;</td><td><a href="#position:result">:result</a></td>
  </tr>
  <tr>
      <td>      &#x2022;</td><td><a href="#position:variant">:variant</a></td>
  </tr>
  </table>
</dir>

<h3 id="position:blackelo">:blackelo&emsp;<n>(ELO - Schwarz)</n></h3>

<p>
Dieses Schlüsselwort erwartet eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>; die ELO des schwarzen
Spielers muß innerhalb dieses Bereichs liegen.
</p>

<h3 id="position:blackrating">:blackrating<extension/>&emsp;<n>(Wertungszahl - Schwarz)</n></h3>

<p>
Filtert alle Partien, in denen die gegebene Wertungszahl des schwarzen Spielers
innerhalb der gebebenen <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>
liegt. Für eine detaillierte Beschreibung siehe <cql>match:rating (match)</cql>.
</p>

<h3 id="position:elo">:elo</h3>

<p>
Dieses Schlüsselwort erwartet eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>; die ELO von mindestens
einem Spieler muß innerhalb dieses Bereichs liegen.
</p>

<p>
Dieses Schlüsselwort wird nur unterstützt, um kompatibel mit dem CQL-Standard
zu sein. Es wird zur Verwendung des gleichnamigen Schlüsselworts
<cql>match:elo</cql> in der Suchliste geraten.
</p>

<h3 id="position:result">:result&emsp;<n>(Ergebnis)</n></h3>

<p>
Dieses Schlüsselwort erwartet das gleiche Argument wie das Schlüsselwort
<cql>match:result (match)</cql> in der Suchliste.
</p>

<p>
Beispiel:
</p>

<verbatim>
(match (
  (position
    <keyword>:result</keyword> 1-0
    <cql>position:whiteelo</cql> 0 2300
    <cql>position:blackelo</cql> 2600 unlimited
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
Suche nach Partien in denen ein Spieler mit ELO 2300 oder geringer einen
Spieler mit ELO 2600 oder höher besiegt.
</p>

<h3 id="position:variant">:variant</h3>

<p>
Für eine Beschreibung dieses Schlüsselwortes siehe beim gleichnamigen
Schlüsselwort <cql>match:variant (match)</cql> der Suchliste. Dieses
Schlüsselwort wird hier bereitgestellt, um bei einzelnen Positionslisten
eine Unterscheidung zwischen den
<a href="Chess-Variants.html">Schachformen</a> treffen zu können.
</p>

<h3 id="position:whiteelo">:whiteelo&emsp;<n>(ELO - Weiß)</n></h3>

<p>
Dieses Schlüsselwort erwartet eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>; die ELO des weißen
Spielers muß innerhalb dieses Bereichs liegen.
</p>

<h3 id="position:whiterating">:whiterating<extension/>&emsp;<n>(Wertungszahl - Weiß)</n></h3>

<p>
Filtert alle Partien, in denen die gegebene Wertungszahl des weißen Spielers
innerhalb der gebebenen <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>
liegt. Für eine detaillierte Beschreibung siehe <cql>match:rating (match)</cql>.
</p>

<h2 id="relation">Relationen zwischen den Positionen</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:relation">:relation</a></td></tr>
  </table>
</dir>

<h3 id="position:relation">:relation</h3>

<p>
Das Argument, eine Relationenbeschreibung, wird benutzt um nach Partien zu
suchen, in denen Positionenpaare P1 und P2 gewisse Eigenschaften erfüllen.
Siehe <a href="CQL-Relation-List.html">Relationsliste</a> für eine
Beschreibung von Relationen.
</p>

<h2 id="matching">Schlüsselwörter zur Zählung</h2>

<p>
Diese Schlüsselwörter zählen die Anzahl der Positionen, die von einer
Positionsliste gefiltert werden. Jedes von ihnen erwartet eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> als Argument.
Sie können nur in Positionslisten verwendet werden, die sich auf oberster
Ebene einer Suchliste befinden.
<br/><img src="../images/gameflag-Illegal-Move.png" />
Diese Einschränkung ist zu prüfen!
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td></tr>
  </table>
</dir>

<h3 id="position:matchcount">:matchcount&emsp;<n>(Übereinstimmungszähler)</n></h3>

<p>
Filtert nur dann wenn die Anzahl der Positionen in der Partie, die von dieser
Positionsliste gefunden werden, innerhalb der gegebenen
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> liegt.
</p>

<p>
Beispiel:
</p>

<verb>
(position <cql>position:moveto</cql> [&Q;&q;] <keyword>:matchcount</keyword> 4 unlimited)
</verb>

<p>
Filtert jede Partie in der mindestens vier Damen geschlagen wurden.
</p>

<h3 id="position:pretransformmatchcount">:pretransformmatchcount&emsp;<n>(Prä-Transformation-Übereinstimmungszähler)</n></h3>

<p>
Dieses Schlüsselwort hat die gleiche Syntax wie <cql>position:matchcount</cql>.
Zur Beschreibung dieses Schlüsselwortes nehmen wir folgende allgemeine Form
einer Positionsliste an:
</p>

<verbatim>
(position
  T<sub>1</sub> T<sub>2</sub> ... T<sub>k</sub>
  X<sub>1</sub> X<sub>2</sub> ... X<sub>n</sub>
  <keyword>:pretransformmatchcount</keyword> n<sub>1</sub> n<sub>2</sub>)
</verbatim>

<p>
Alle <expr>T<sub>i</sub></expr> sind die transformierenden Schlüsselwörter,
und alle anderen Elemente (nur keine Transformationsschlüsselwörter) sind mit
<expr>X<sub>i</sub></expr> bezeichnet. <expr>n<sub>1</sub></expr>
<expr>n<sub>2</sub></expr> ist die Bereichsangabe. Wir nehmen nun an, daß
<expr>Y<sub>i,j</sub></expr> ein Element bezeichnet das aus
<expr>X<sub>i</sub></expr> in einem der Transformationsschritte j ensteht
(möglicherweise identisch zu <expr>X<sub>i</sub></expr>, weil es
transformationsinvariant ist). m soll die Anzahl aller Transformationsschritte
bezeichnen. Nun bilden wir einen neuen Ausdruck:
</p>

<verbatim>
(position
  <cql>position:or</cql> (
    Y<sub>1,1</sub> Y<sub>2,1</sub> ... Y<sub>n,1</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    Y<sub>1,2</sub> Y<sub>2,2</sub> ... Y<sub>n,2</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    ...
    Y<sub>1,m</sub> Y<sub>2,m</sub> ... Y<sub>n,m</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)))
</verbatim>

<p>
Die Positionsliste mit <cql>:pretransformmatchcount</cql> filtert genau
diejenigen Positionen, die von der neugeformten Positionsliste gefiltert
werden. Mit anderen Worten: die Zählung erfolgt für jeden
Transformationsschritt einzeln.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <cql>position:moveto</cql> [Aa]d4
  <keyword>:pretransformmatchcount</keyword> 12 unlimited
  <cql>position:shift</cql>))
</verbatim>

<p>
Dies würde jede Partie finden in der mindestens 12 Figuren auf dem gleichen
Feld geschlagen wurden. Ersetzen wir <cql>:pretransformmatchcount</cql>
durch <cql>position:matchcount</cql>, dann würde diese Positionsliste Partien
auffinden in denen mindestens 12 Figuren irgendwo auf dem Schachbrett geschlagen
wurden.
</p>

<h2 id="evaluation">Schlüsselwörter für die Stellungsbeurteilung</h2>

<p>
Die folgenden Schlüsselwörter analyieren Positionen.
<cql>position:evaluation</cql> und <cql>position:moveevaluation</cql> sollten
mit Vorsicht verwendet werden, es sind sehr langsame Operationen. In einigen
Fällen mögen die Schlüsselwörter <cql>position:exchangeevaluation</cql> und
<cql>position:maxswapevaluation</cql> eine Alternative sein, diese Operationen
sind viel schneller, aber auch noch recht zeitverbrauchend.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td></tr>
  </table>
</dir>

<h3 id="position:evaluation">:evaluation<extension/>&emsp;<n>(Bewertung)</n></h3>

<annotation>
Diese ist eine sehr langsame Operation und sollte eingeschränkt verwendet werden.
</annotation>

<p>
Dieses Schlüsselwort bewertet die aktuelle Position mit Hilfe eines externen
Schachprogramms. Die ersten beide Parameter bestimmen den Berechnungsmodus: 
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "sd <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">suche nur &lt;d&gt; Halbzüge tief</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">suche exakt &lt;ms&gt; Millisekunden pro Zug</td>
    </tr>
  </table>
</dir>

<p>
Jetzt kann entweder eine Mattsuche oder eine Stellungsbewertungssuche
spezifiziert werden.
</p>

<p>
Eine Mattsuche erwartet einen weiteren Parameter: nämlich das Wort <i>mate</i>
(für Matt). Die Abfrage ist erfolgreich, wenn ein Matt aufgefunden wurde.
</p>

<p>
Die Stellungsbewertungssuche erfordert drei weitere Parameter.
Der erste davon bezeichnet die untere Grenze, der zweite bezeichnet die obere
Grenze, beide Werte werden in Bauerneinheiten angegeben. Die Abfrage ist
erfolgreich, wenn die Bewertung der Position innerhalb der gegebenen Grenzen
liegt (inklusive der Randwerte). Ist die untere Grenze mit <i>unlimited</i>
(unbeschränkt) spezifiziert, so wird sie als negativ unendlich interpretiert.
Ist die obere Grenze mit <i>unlimited</i> spezifiziert, so wird sie als positiv
unendlich angenommen. Der dritte Parameter ist entweder <i>sidetomove</i>
(Zugrecht) oder <i>absolute</i> (absolut). <i>sidetomove</i> bedeutet, daß die
Bewertungswerte vom Zugrecht abhängig sind, und mit <i>absolute</i> sind die
Bewertungswerte unabhängig davon.
</p>

<note>
Beachte daß im Modus <i>movetime</i> die Angabe der Millisekunden auf
Centisekunden aufgerundet wird, wenn das verwendete Schachprogramm auf das
Protokoll <nobr>WinBoard</nobr>/<nobr>XBoard</nobr> eingeschränkt ist.
Steht dem Schachprogramm das UCI-Protokoll zur Verfügung, so wird die exakte
Millisekundenangabe verwendet.
</note>

<p>
Beispiele:
</p>

<verb>
<keyword>:evaluation</keyword> depth 4 2.5 unlimited sidetomove
</verb>

<p>
Die Seite mit dem Zugrecht hat (wahrscheinlich) eine Gewinnstellung, denn sie
ist mit mindestens 2,5 Bauerneinheiten im Vorteil.
</p>

<verb>
<keyword>:evaluation</keyword> depth 4 unlimited -2.5 sidetomove
</verb>

<p>
Die Seite mit dem Zugrecht hat (wahrscheinlich) eine Verluststellung, denn sie
ist mit mindestens 2,5 Bauerneinheiten im Nachteil.
</p>

<verb>
<keyword>:evaluation</keyword> movetime 3000 unlimited -3.0 absolute
</verb>

<p>
Schwarz ist (wahrscheinlich) verloren, denn er ist mindestens 3,0
Bauerneinheiten im Nachteil.
</p>

<verb>
<keyword>:evaluation</keyword> depth 6 mate
</verb>

<p>
Eine der Seiten kann in spätestens 3 Zügen (6 Halbzüge) mattgesetzt werden.
</p>

<h3 id="position:exchangeevaluation">:exchangeevaluation<extension/>&emsp;<n>(Figurentauschbewertung)</n></h3>

<p>
Dieses Schlüsselwort analysiert Schlagzüge, um zu sehen ob sie profitabel
erscheinen.
</p>

<p>
Das Schlüsselwort filtert den aktuellen Zug, wenn der Wert innerhalb der
angegeben Grenzen liegt: ein unterer und ein oberer Wert in Bauerneinheiten.
Nur Schlagzüge werden bewertet. Ist der untere Wert mit <i>unlimited</i>
(unbeschränkt) spezifiziert, so bedeutet dies negativ unendlich. Ist der obere
Wert mit <i>unlimited</i> spezifiziert, so bedeutet dies positiv unendlich. Die
Bewertungsfunktion bezieht mit ein, daß Figuren gefesselt sein können, oder daß
sie von anderen Figuren gedeckt werden. Der Wert dieser Funktion hängt nicht
vom Zugrecht ab.
</p>

<p>
Bezüglich der Figurenwerte siehe <cql>position:power</cql>.
</p>

<p>
Beachte daß diese Funktion keine Stellungsbewertung vornimmt, stattdessen
wird nur der Schlagabtausch abgeschätzt.
</p>

<p>
Beispiel:
</p>

<verb>
<keyword>:exchangeevaluation</keyword> unlimited -3
</verb>

<p>
Dieser Schlagzug ist (wahrscheinlich) ein Patzer.
</p>

<h3 id="position:maxswapevaluation">:maxswapevaluation<extension/>&emsp;<n>(Maximum einer Schlagabtauschbewertung)</n></h3>

<p>
Dieses Schlüsselwort erlaubt die Abschätzung von Zügen. Es erwartet
als Argument zwei Figurenbezeichner, gefolgt von einer Bereichsangabe.
Das erste Argument spezifiziert die erlaubten Figuren und Felder des nächsten
Zuges, das zweite Argument spezifiziert die Zielfelder. Für jeden erlaubten
Zug wird ein Wert berechnet, der den materiellen Vorteil bzw. Verlust dieses
Zuges berechnet (in Bauerneinheiten), aufgrund möglicher Schlagabtäusche auf
dem Zielfeld. Abschliessend wird das Maximum alle berechneten Werte ausgewählt.
</p>

<p>
Das Schlüsselwort filtert eine Position wenn der berechnete Wert innerhalb des
gegebenen Bereichs liegt (ein unterer und ein oberer Wert). Ist der untere
Bereich mit dem speziellen Wert <i>unlimited</i> (unbeschränkt) spezifiziert,
so wird negativ unendlich angenommen. Ist der obere Wert mit <i>unlimited</i>
spezifiziert, so wird positiv unendlich angenommen. Die Bewertungsfunktion
bezieht mit ein, das Figuren gefesselt sein können, oder von anderen Figuren
gedeckt werden. Der Wert dieser Funktion hängt nicht vom Zugrecht ab.
</p>

<p>
Bezüglich der Figurenwerte siehe <cql>position:power</cql>.
</p>

<p>
Beachte daß diese Funktion keine Stellungsbewertung vornimmt, stattdessen
wird nur der Schlagabtausch abgeschätzt.
</p>

<note>
Dieses Schlüsselwort ist ähnlich dem Schlüsselwort <cql>:maxswapvalue</cql>
von Chess Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
aber auf sehr verschiedene Weise implementiert.
</note>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> A a 1 unlimited)
</verb>

<p>
Diese Abfrage filtert Positionen, in denen Weiß mit Materialgewinn droht.
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> &Q;?1-7 ??8 0 unlimited)
</verb>

<p>
Diese Abfrage filtert Positionen, in denen eine weiße Dame die achte Reihe
erobern kann ohne materiellen Verlust.
</p>

<h3 id="position:moveevaluation">:moveevaluation<extension/>&emsp;<n>(Zugbewertung)</n></h3>

<annotation>
Diese ist eine sehr langsame Operation und sollte eingeschränkt verwendet werden.
</annotation>

<p>
Dieses Schlüsselwort vergleicht die Differenz einer Stellungsbewertung der
aktuellen Position mit der nächsten Position. Die Bewertung wird mit
Einsatz eines externen Schachprogramm durchgeführt. Es werden sieben
Parameter erwartet. Die ersten beiden Parameter sind Figurenbezeichner. Der
erste davon spezifiziert die erlaubten Figuren und Felder des nächsten Zuges,
der zweite spezifiziert die Zielfelder. Der dritte und vierte Parameter
spezifizieren den Berechnungsmodus:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">suche nur &lt;d&gt; Halbzüge tief</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">suche exakt &lt;ms&gt; Millisekunden pro Zug</td>
    </tr>
  </table>
</dir>

<p>
Der fünfte Parameter bezeichnet die untere Grenze, der sechste Parameter
bezeichnet die obere Grenze, beide Werte werden in Bauerneinheiten
angegeben. Die Abfrage ist erfolgreich, wenn die Bewertung der Position
innerhalb der gegebenen Grenzen liegt (inklusive der Randwerte). Ist die untere
Grenze mit <i>unlimited</i> (unbeschränkt) spezifiziert, so wird sie als
negativ unendlich interpretiert. Ist die obere Grenze mit <i>unlimited</i>
spezifiziert, so wird sie als positiv unendlich angenommen. Der Wert des
letzten Zuges ist die Differenz zwischen der Bewertung der aktuellen
Position und der Bewertung der vorangegangenen Position. Im Falle von
Mattpositionen ist die Differenz immer größer als 10.000.
</p>

<p>
Der siebte Parameter ist entweder <i>sidetomove</i> (Zugrecht) oder
<i>absolute</i> (absolut). <i>sidetomove</i> bedeutet, daß die Bewertungswerte
vom Zugrecht abhängig sind, und mit <i>absolute</i> sind die Bewertungswerte
unabhängig davon.
</p>

<note>
Beachte daß im Modus <i>movetime</i> die Angabe der Millisekunden auf
Centisekunden aufgerundet wird, wenn das verwendete Schachprogramm auf das
Protokoll <nobr>WinBoard</nobr>/<nobr>XBoard</nobr> eingeschränkt ist.
Steht dem Schachprogramm das UCI-Protokoll zur Verfügung, so wird die exakte
Millisekundenangabe verwendet.
</note>

<p>
Beispiele:
</p>

<verb>
<keyword>:moveevaluation</keyword> U ? depth 4 3.0 unlimited sidetomove
</verb>

<p>
Filtere die erste Position mit einer Bewertungsdifferenz von mindestens 3,0
Bauerneinheiten. Dies heißt. das der letzte Zug (wahrscheinlich) ein Patzer
war.
</p>

<verb>
<keyword>:moveevaluation</keyword> A a depth 4 unlimited -3.0 absolute
</verb>

<p>
Filtere die erste Position, in der die Bewertungsdifferenz mindestens 3,0
Bauerneinheiten als Vorteil für Schwarz beträgt. Dies bedeutet, daß der letzte
weiße Zug (wahrscheinlich) ein Patzer war. Nur Schlagzüge werden bewertet.
</p>

<verbatim>
(match
  (position <keyword>:moveevaluation</keyword> [&P;&p;] ?[?1,?8]
             unlimited 0.0 movetime 5000 absolute)
  (position <cql>position:promotion</cql> U <cql>position:cut</cql>)))
</verbatim>

<p>
Suche nach Positionen, in denen sie Seite mit dem Zugrecht die erste
Bauernverwandlung in dieser Partie ausführt, aber keinen bessere
Stellungsbewertung dadurch erzielt. Wir stellten sicher, daß nur
Bauernumwandlungszüge bewertet werden.
</p>

<h2 id="accumulator">Schlüsselwörter für Akkumulationen</h2>

<p>
Es gibg hauptsächlich zwei Akkumulatorschlüsselwörter, <cql>:accumulate</cql>
und <cql>:sumrange</cql>. Diese werden verwendet um die Anzahl der
Transformationen einer Positionsliste zu zählen, die die aktuelle Position
filtern. Jedesmal wenn eine transformierte Positionsliste eine Position
filtert, wird der assoziierte Akkumulator inkrementiert. Jede Positionsliste
kann dann mit <cql>:sumrange</cql> testen, ob der akkumulierte Wert innerhalb
eines gewissen Bereichs liegt.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:reset">:reset</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td></tr>
  </table>
</dir>

<h3 id="position:accumulate">:accumulate&emsp;<n>(Akkumulieren)</n></h3>

<p>
Dies erwartet als Argument den Namen des Akkumulators. Jedesmal
wenn die Anwendung eines Elements auf die Menge der transformierten
Positionslisten eine Position filtert, wird der mit diesem Namen assoziierte
Akkumulator inkrementiert. Der Akkumulator wird wieder auf Null gesetzt,
sobald eine neue Position untersucht wird (nach einem Zug). Als Folge davon
sollte <cql>:accumulate</cql> nicht innerhalb von folgenden Schlüsselwörtern
verwendet werden: <cql>position:not</cql>, <cql>position:sequence</cql>,
und <cql>position:gappedsequence</cql>. Zu beachten ist daß
<cql>position:flipcolor</cql> in den meisten Fällen unerwartete Ergebnisse
hervorruft, wenn es zusammen mit <cql>:accumulate</cql> verwendet wird,
denn der Akkumulator wird nicht auf Null zurückgesetzt zwischen den
Farbwechseln.
</p>

<p>
Für Beispiele siehe:
<a href="CQL-Examples.html#accumulator">Benutzung von Akkumulatoren zur Zählung von Freibauern</a>.
</p>

<h3 id="position:reset">:reset<extension/>&emsp;<n>(Zurücksetzen)</n></h3>

<p>
Diese Schlüsselwort erwartet als Argument den Namen des Akkumulators. Es setzt
den mit diesen Namen assoziierten Akkumulator nach der Anwendung einer
Transformationen wieder auf Null zurück.
</p>

<p>
Beispiel:
</p>

<p>
Trippelbauern können auf folgende Weise aufgefunden werden:
</p>

<verbatim>
(position
  <keyword>:reset</keyword> akku
  &P;e2
  <cql>position:accumulate</cql> akku
  <cql>position:sumrange</cql> akku 3
  <cql>position:shiftvertical</cql>
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Beachte das dies nur ein Beispiel für eine Anwendung dieses Schlüsselwort ist
(aus <a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
es wird nicht geraten diese Abfrage für die Trippelbauersuche einzusetzen.
Eine viel bessere Abfrage dafür ist:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;d[2-7] 3 6
  <cql>position:shifthorizontal</cql>
  <cql>position:flipcolor</cql>))
</verbatim>

<h3 id="position:sumrange">:sumrange<extension/>&emsp;<n>(Ergebnisbereich)</n></h3>

<p>
Dies erwartet als Argument den Namen eines Akkumulator und eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert eine
Position, wenn der Wert des bezeichneten Akkumulators innerhalb des gegebenen
Bereichs liegt.
</p>

<p>
Für Beispiele siehe:
<a href="CQL-Examples.html#accumulator">Benutzung von Akkumulatoren zur Zählung von Freibauern</a>.
</p>

<h2 id="tagging">Schlüsselwörter für das Markieren</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td></tr>
  </table>
</dir>

<h3 id="position:tagmatch">:tagmatch<extension/>&emsp;<n>(Markierungsvergleich)</n></h3>

<p>
Das Schlüsselwort <cql>:tagmatch</cql> erwartet zwei Argumente, den Namen einer
Markierung und einen Figurenbezeichner. Es filtert nur dann wenn die an die
Markierung gebundene Figur vom zweiten Argument bezeichnet wird. Für weitere
Informationen siehe Abschnitt <a href="CQL-Tagging.html">Markierung</a>.
</p>

<h2 id="control">Schlüsselwörter für die Steuerung</h2>

<p>
Die folgenden steuernden Schlüsselwörter beeinflussen den Ablauf der Suche
bzw. das Suchergebnis. Tatsächlich erweitert keines dieser Schlüsselwörter
die Mächtigkeit von CQL, jedes von ihnen kann ersetzt werden, aber der
Gebrauch dieser Schlüsselwörter kann die Suchzeit beträchtlich verkürzen,
und der Suchausdruck ist möglicherweise klarer definiert.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:cut">:cut</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:endmost">:cut</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exclude">:exclude</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:following">:following</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:preceding">:preceding</a></td></tr>
  </table>
</dir>

<h3 id="position:cut">:cut<extension/>&emsp;<n>(beschneiden)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es in
einer Positionsliste enthalten, oder es hat eine Positionsliste als Parameter.
In der ersten Form wird die Positionssuche in der aktuellen Partie abgebrochen
sobald die Bedingung der Positionsliste aufgefunden wird. In der zweiten Form
bricht die Suche in der aktuellen Partie ab sobald die Bedingung des
Arguments aufgefunden wird. Dieses Schlüsselwort ist immer erfolgreich,
mit anderen Worten: es beeinflußt nicht das Resultat der anderen Filter.
</p>

<p>
Der <cql>:cut</cql>-Filter hat niedrigere Priorität als alle anderen Filter.
Das heißt, daß eine Position gefiltert wird, wenn alle anderen Filter diese
Position akzeptieren, unabhängig vom Resultat des <cql>:cut</cql>-Filters.
Soll der <cql>:cut</cql>-Filter höchste Priorität haben, dann ist das
Schlüsselwort <cql>position:preceding</cql> anzuwenden. In diesem Fall bricht
die Erfüllung der <cql>:cut</cql>-Bedingung mit einem negativen Resultat ab,
unanhängig vom Resultat aller anderen Bedingungen. Siehe dazu nachfolgende
Beispiele:
</p>

<verb>
(match (position &lt;A&gt; <keyword>:cut</keyword> (position &lt;B&gt;)))
</verb>

<p>
Wir nehmen an das &lt;A&gt; und &lt;B&gt; von einer Position erfüllt werden,
und beide Bedingungen zum ersten Mal. In diesem Fall ist die Suche in dieser
Partie erfolgreich.
</p>

<verb>
(match (position &lt;A&gt; <keyword>:cut</keyword> (position <cql>position:preceding</cql> &lt;B&gt;)))
</verb>

<p>
Wir nehmen an das &lt;A&gt; und &lt;B&gt; von einer Position erfüllt werden,
und beide Bedingungen zum erstem Mal. In diesem Fall ist die Suche in dieser
Partie negativ.
</p>

<p>
Beispiele:
</p>

<verbatim>
(match
  (position
    <cql>position:mate</cql>
    <keyword>:cut</keyword> (position <cql>position:check</cql>)))
</verbatim>

<p>
Suche nach Partien die mit einem Matt enden, und keine der beiden Seiten hat
jemals zuvor Schach geboten. Tatsächlich ist das Schlüsselwort <cql>:cut</cql>
für diese Suchkriterien nicht erforderlich, wie folgende Umformung zeigt:
</p>

<verbatim>
(match
  (position <cql>position:mate</cql>)
  (position <cql>position:check</cql> <cql>position:matchcount</cql> 1))
</verbatim>

<p>
Aber diese Version durchsucht die gesamte Partie, und die vorhergehende Version
mit <cql>:cut</cql> schlägt bereits fehl sobald das erste Schachgebot erfolgt.
In komplexen Fällen kann der Gebrauch des Schlüsselwortes <cql>:cut</cql> viel
effizienter sein als der Gebrauch von <cql>:matchcount</cql>.
</p>

<h3 id="position:endmost">:endmost<extension/>&emsp;<n>(letzte)</n></h3>

<p>
Dieses Schlüsselwort liefert das letzte Autreten einer aufgefundenen Stellung
in einer Partie. Dies könnte auch auf die folgende Weise erreicht werden:
</p>

<verbatim>
(position
  &lt;A&gt;
  <cql>position:not</cql> (
    <cql>position:gappedsequence</cql> (
      (position)
      (position &lt;A&gt;))))
</verbatim>

<p>
Wobei <expr>&lt;A&gt;</expr> die gesuchte Position repräsentiert. Der Gebrauch
von <cql>:endmost</cql> führt zu einem viel klareren Ausdruck:
</p>

<verb>
(position &lt;A&gt; <keyword>:endmost</keyword>)
</verb>

<h3 id="position:exclude">:exclude<extension/>&emsp;<n>(ausschliessen)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es in
einer Positionsliste enthalten, oder es hat eine Positionsliste als Parameter.
In der ersten Form wird die Partie ausgeschlossen wenn eine Position von
der Positionsliste gefiltert wird. In der zweiten Form wird eine Partie
ausgeschlossen, wenn das Resultat des Arguments positiv ist. Diese
Schlüsselwort beeinflußt nicht das Resultat der anderen Filter (siehe
dazu das Besipiel).
</p>

<p>
Dieses Schlüsselwort schließt selbst dann Partien aus, wenn eine Position
gefiltert wurde bevor die <cql>:exclude</cql>-Bedingungen erfüllt wurden. Kurz
gesagt: <cql>:exclude</cql> schließt unter gewissen Bedingungen Partien
vollständig aus der Suche aus.
</p>

<p>
Beispiel:
</p>

<verbatim>
(match
  (position
    &lt;A&gt;
    <keyword>:exclude</keyword> (position &lt;B&gt;)))
</verbatim>

<p>
Suche nach Partien die eine Position enthalten, die Bedingung
<expr>&lt;A&gt;</expr> erfüllen, aber nicht wenn es in dieser Partie
eine Position gibt, die die Bedingung <expr>&lt;B&gt;</expr> erfüllt.
Dieses Suchkrierium kann auch ohne den Gebrauch des Schlüsselwortes
<cql>:exclude</cql> formuliert werden:
</p>

<verbatim>
(match
  (position
    <cql>position:and</cql> (
      (position &lt;A&gt;)
      (position &lt;B&gt; <cql>position:matchcount</cql> 0))))
</verbatim>

<p>
Aber der Gebrauch von <cql>:exclude</cql> ist einfacher und klarer.
</p>

<h3 id="position:following">:following<extension/>&emsp;<n>(nachfolgende)</n></h3>

<p>
Dieses Schlüsselwort liefert die nachfolgende Position des Filters, sofern
ein Ergebnis vorliegt. Dies bedeutet daß die Endstellung einer Partie nicht
mehr aufgefunden sein kann, denn sie hat keinen Nachfolger. Dieses
Schlüsselwort kann nur auf oberster Ebene verwendet werden.
</p>

<p>
Beispiel:
</p>

<verb>
(position &N;d4 <keyword>:following</keyword>)
</verb>

<p>
Wird eine Position mit einem Springer auf d4 gefunden, dann wird die
nachfolgende Position als Ergebnis geliefert.
</p>

<h3 id="position:preceding">:preceding<extension/>&emsp;<n>(vorhergehende)</n></h3>

<p>
Dieses Schlüsselwort liefert die vorhergehende Position des Filters, sofern
ein Ergebnis vorliegt. Ist die Startposition gefiltert worden, dann wird
diese Position übergangen, und die Suche läuft weiter. Dises Schlüsselwort
kann nur auf oberster Ebene verwendet werden.
</p>

<p>
Dieses Schlüsselwort hat eine spezielle Bedeutung wenn es mit dem
Schlüsselwort <cql>position:cut</cql> kombiniert wird.
</p>

<p>
Beispiele:
</p>

<verb>
position <cql>position:check</cql> <keyword>:preceding</keyword>
</verb>

<p>
Das Resultat dieser Suche ist die Vorgängerposition der ersten gefundenen
Position, in der einer der Seiten Schach bietet. Dies kann auch ohne dieses
Schlüsselwort formuliert werden:
</p>

<verb>
position <cql>position:sequence</cql>
((position <cql>position:nocheck</cql>) (position <cql>position:check</cql>))
</verb>

<p>
Aber der Gebrauch von <cql>:preceding</cql> ist einfacher, und die Suche ist
effizienter.
</p>

END

<!-- vi:set ts=2 sw=2 et filetype=html fileencoding=latin1: -->
