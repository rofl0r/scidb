<!-- **********************************************************************
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
*********************************************************************** -->

<!-- **********************************************************************
* Copyright: (C) 2013 Gregor Cramer
*********************************************************************** -->

<!-- **********************************************************************
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*********************************************************************** -->

INDEX Positionsliste (CQL)
INDEX CQL Positionsliste

DEFINE <extension/> &ensp;<img src="../images/ft-scidb-tiny.png" />

TITLE CQL - Die Positionsliste

<p>
Das Symbol <img src="../images/ft-scidb-tiny.png" /> im Titel einer
Schlüsselwortdefinition kennzeichnet, daß dieses Schlüsselwort eine
Erweiterung ist, also nicht zum CQL-Standard gehört.
</p>

<p>
Die Schlüsselwörter <cql>position:castling</cql>, <cql>position:endgame</cql>,
<cql>position:inside</cql>, and <cql>position:reset</cql> sind von Chess
Assistant 9 entlehnt worden. Die Beschreibung dieser Schlüsselwörter entstammt
dem Dokument <a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#index">Index</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#logical">Schlüsselwörter für die Kontrolllogik</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#control">Schlüsselwörter für die Steuerung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#simple">Einfache Schlüsselwörter</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#transform">Transformierende Schlüsselwörter</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#piece">Schlüsselwörte für die Figurenanalyse</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#move">Schlüsselwörter für die Zuganalyse</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#sequence">Schlüsselwörter für Sequenzen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#game">Schlüsselwörter für die Partieinformationen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#relation">Relationen zwischen den Positionen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#matching">Schlüsselwörter zur Zählung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#evaluation">Schlüsselwörter für die Stellungsbeurteilung</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#accumulator">Schlüsselwörter für Akkumulationen</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#tagging">Schlüsselwörter für das Markieren</a></td></tr>
  </table>
</dir>

<h2 id="index">Index</h2>

<dir>
  <table>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:promote">:promote</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:and">:and</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rating">:rating</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:markall">:markall</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:ray">:ray</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:relation">:relation</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:moveto">:moveto</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:reset">:reset</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:cut">:cut</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:result">:result</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sequence">:sequence</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shift">:shift</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exclude">:exclude</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nolosing">:nolosing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flip">:flip</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:not">:not</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:or">:or</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:variant">:variant</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piececount">:piececount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:power">:power</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:preceding">:preceding</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:inside">:inside</a></td>
    </tr>
  </table>
</dir>

<h2 id="logical">Schlüsselwörter für die Kontrolllogik</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:and">:and</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:not">:not</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:or">:or</a></td></tr>
  </table>
</dir>

<h3 id="position:and">:and&emsp;<n>(und)</n></h3>

<p>
Erwartet eine Liste von Positionslisten, und filtert genau dann eine Position,
wenn jede von ihnen diese Position filtert.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position 
  <cql>position:wtm</cql>
  <cql>position:check</cql>
  <keyword>:and</keyword> (
    (position &K;e2 &k;g2 <cql>position:shift</cql> <cql>position:flip</cql>)
    (position &N;e2)))
</verbatim>

<p>
Filtert Positionen in denen die Könige in Opposition stehen, ein Springer auf
e2 platziert ist, und der weiße König steht im Schach.
</p>

<h3 id="position:not">:not&emsp;<n>(nicht)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es in
einer Positionsliste enthalten, oder es hat eine Positionsliste als Parameter.
Im ersten Fall filtert dieses Schlüsselwort, wenn die Positionsliste ohne dieses
Schlüsselwort nicht filtern würde. Im zweiten Fall: das Resultat des
Arguments wird negiert. Die erste Form ist konform mit dem CQL-Standard des
Schlüsselwortes :not, die zweite Form ist eine Erweiterung.
</p>

<p>
Beispiele:
</p>

<verbatim>
(match
  (position
    ; <comment>wir suchen für beide Seiten</comment>
    <cql>position:flipcolor</cql>
    <comment>; die Mattposition muß alle folgenden Kriterien erfüllen</comment>
    <cql>position:and</cql> (
      <comment>; der König ist von Leerfeldern umgeben, wird einmal</comment>
      <comment>; attackiert, und ist matt</comment>
      (position
        <cql>position:attackcount</cql> &k; . 8
        <cql>position:attackcount</cql> A &k; 1
        <cql>position:mate</cql>
        <cql>position:btm</cql>)
      <comment>; überprüfe daß kein Nachbar des schwarzen Königs</comment>
      <comment>; mehr als einmal attackiert wird</comment>
      (position
        <keyword>:not</keyword>
        <cql>position:attackcount</cql> &k; .e4 1
        <cql>position:attackcount</cql> A .e4 2 100
        <cql>position:shift</cql>))))
</verbatim>

<p>
Dies findet alle Mattpositionen, in denen der König von Leerfeldern umgeben ist.
</p>

<p>
Die folgende Positionsliste
</p>

<verb>
(position &R;a3 <keyword>:not</keyword>)
</verb>

<p>
ist equivalent zu
</p>

<verb>
(position [a&Q;&B;&N;&P;&K;.]a3)
</verb>

<h3 id="position:or">:or&emsp;<n>(oder)</n></h3>

<p>
Erwartet eine Liste von Positionslisten, und filter genau dann eine Position,
wenn mindestens eine von ihnen diese Position filtert.
</p>

<p>
Beispiel:
</p>

<verbatim>
(match
  (position
    <keyword>:or</keyword> (
      (position <cql>position:piececount</cql>
        &B;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9)
      (position <cql>position:piececount</cql>
        &B;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9))))
</verbatim>

<p>
Suche nach Partien, die Positionen mit entweder zwei weißfeldrigen weißen
Läufern, zwei schwarzfeldrigen weißen Läufern, zwei schwarzfeldrigen schwarzen
Läufern, oder aber zwei weißfeldrigen schwarzen Läufern haben.
</p>

<h2 id="control">Schlüsselwörter für die Steuerung</h2>

<p>
Mit Hilfe der steuernden Schlüsselwörter <cql>position:cut</cql> und
<cql>position:exclude</cql> können unerwünschte Positionen oder sogar
Partien ausgeschlossen werden. Das Schlüsselwörter
<cql>position:preceding</cql> liefert den Vorgänger einer aufgefundenen
Position.
</p>

<p>
Tatsächlich erweitern diese Schlüsselwörter die Mächtigkeit von CQL nicht,
jedes von ihnen kann ersetzt werden, aber der Gebrauch dieser Schlüsselwörter
kann die Suchzeit beträchtlich verkürzen, und der Suchausdruck ist
möglicherweise klarer definiert.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:cut">:cut</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exclude">:exclude</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:preceding">:preceding</a></td></tr>
  </table>
</dir>

<h3 id="position:cut">:cut<extension/>&emsp;<n>(beschneiden)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es in
einer Positionsliste enthalten, oder es hat eine Positionsliste als Parameter.
In der ersten Form wird die Positionssuche in der aktuellen Partie abgebrochen
sobald die Bedingung der Positionsliste aufgefunden wird. In der zweiten Form
bricht die Suche in der aktuellen Partie ab sobald die Bedingung des
Arguments aufgefunden wird. Dieses Schlüsselwort ist immer erfolgreich,
mit anderen Worten: es beeinflußt nicht das Resultat der anderen Filter.
</p>

<p>
Der :cut-Filter hat niedrigere Priorität als alle anderen Filter. Das heißt,
daß eine Position gefiltert wird, wenn alle anderen Filter diese Position
akzeptieren, unabhängig vom Resultat des :cut-Filters. Soll der :cut-Filter
höchste Priorität haben, dann ist das Schlüsselwort
<cql>position:preceding</cql> anzuwenden. In diesem Fall bricht die Erfüllung
der :cut-Bedingung mit einem negativen Resultat ab, unanhängig vom Resultat
aller anderen Bedingungen. Siehe dazu nachfolgende Beispiele:
</p>

<verb>
(match (position &lt;A&gt; <keyword>:cut</keyword> (position &lt;B&gt;))
</verb>

<p>
Wir nehmen an das &lt;A&gt; und &lt;B&gt; von einer Position erfüllt werden,
und beide Bedingungen zum erstem Mal. In diesem Fall ist die Suche in dieser
Partie erfolgreich.
</p>

<verb>
(match (position &lt;A&gt; <keyword>:cut</keyword> (position <cql>position:preceding</cql> &lt;B&gt;)))
</verb>

<p>
Wir nehmen an das &lt;A&gt; und &lt;B&gt; von einer Position erfüllt werden,
und beide Bedingungen zum erstem Mal. In diesem Fall ist die Suche in dieser
Partie negativ.
</p>

<p>
Beispiele:
</p>

<verbatim>
(match
  (position
    <cql>position:mate</cql>
    <keyword>:cut</keyword> (position <cql>position:check</cql>)))
</verbatim>

<p>
Suche nach Partien die mit einem Matt enden, und keine der beiden Seiten hat
jemals zuvor Schach geboten. Tatsächlich ist das Schlüsselwort :cut für
diese Suchkriterien nicht erforderlich, wie folgende Umformung zeigt:
</p>

<verbatim>
(match
  (position <cql>position:mate</cql>)
  (position <cql>position:check</cql> <cql>position:matchcount</cql> 1))
</verbatim>

<p>
Aber diese Version durchsucht die gesamte Partie, und die vorhergehende Version
mit :cut schlägt bereits fehl sobald das erste Schachgebot erfolgt. In
komplexen Fällen kann der Gebrauch des Schlüsselwortes :cut viel effizienter
sein als der Gebrauch von :matchcount.
</p>

<h3 id="position:exclude">:exclude<extension/>&emsp;<n>(ausschliessen)</n></h3>

<p>
Dieses Schlüsselwort kann in zwei Formen angewandt werden: entweder ist es in
einer Positionsliste enthalten, oder es hat eine Positionsliste als Parameter.
In der ersten Form wird die Partie ausgeschlossen wenn eine Position von
der Positionsliste gefiltert wird. In der zweiten Form wird eine Partie
ausgeschlossen, wenn das Resultat des Arguments positiv ist. Diese
Schlüsselwort beeinflußt nicht das Resultat der anderen Filter (siehe
dazu das Besipiel).
</p>

<p>
Dieses Schlüsselwort schließt selbst dann Partien aus, wenn eine Position
gefiltert wurde bevor die :exclude-Bedingungen erfüllt wurden. Kurz gesagt:
:exclude schließt unter gewissen Bedingungen Partien vollständig aus der Suche
aus.
</p>

<p>
Beispiel:
</p>

<verbatim>
(match
  (position
    &lt;A&gt;
    <keyword>:exclude</keyword> (position &lt;B&gt;)))
</verbatim>

<p>
Suche nach Partien die eine Position enthalten, die Bedingung
<expr>&lt;A&gt;</expr> erfüllen, aber nicht wenn es in dieser Partie
eine Position gibt, die die Bedingung <expr>&lt;B&gt;</expr> erfüllt.
Dieses Suchkrierium kann auch ohne den Gebrauch des Schlüsselwortes
:exclude formuliert werden:
</p>

<verbatim>
(match
  (position
    <cql>position:and</cql> (
      (position &lt;A&gt;)
      (position &lt;B&gt; <cql>position:matchcount</cql> 0))))
</verbatim>

<p>
Aber der Gebrauch von :exclude ist einfacher und klarer.
</p>

<h3 id="position:preceding">:preceding<extension/>&emsp;<n>(vorhergehende)</n></h3>

<p>
Dieses Schlüsselwort liefert die vorhergehende Position des Filters, sofern
ein Ergebnis vorliegt. Ist die Startposition gefiltert worden, dann wird
diese Position übergangen, und die Suche läuft weiter. Das Schlüsselwort
kann nur auf oberster Ebene verwendet werden.
</p>

<p>
Diese Schlüsselwort hat eine spezielle Bedeutung wenn es mit dem
Schlüsselwort <cql>position:cut</cql> kombiniert wird.
</p>

<p>
Beispiele:
</p>

<verb>
position <cql>position:check</cql> <keyword>:preceding</keyword>
</verb>

<p>
Das Resultat dieser Suche ist die Vorgängerposition der ersten gefundenen
Position, in der einer der Seiten Schach bietet. Dies kann auch ohne dieses
Schlüsselwort formuliert werden:
</p>

<verb>
position <cql>position:sequence</cql>
((position <cql>position:nocheck</cql>) (position <cql>position:check</cql>))
</verb>

<p>
Aber der Gebrauch von :preceding ist einfacher, und die Suche ist effizienter.
</p>

<h2 id="simple">Einfache Schlüsselwörter</h2>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:markall">:markall</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
  </table>
</dir>

<h3 id="position:blackcannotwin">:blackcannotwin<extension/>&emsp;<n>(Schwarz kann nicht gewinnen)</n></h3>

<p>
Filtere nur dann wenn der schwarze Spieler keine Gewinnmöglichkeit mehr hat.
</p>

<p>
Normalerweise ist dies equivalent zu folgender Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; nur schwarzer König</comment>
  (<cql>position:piececount</cql> a 1)
  <comment>; nur schwarzer König und schwarze Leichtfigur</comment>
  (<cql>position:piececount</cql> a 2 <cql>position:piececount</cql> i 1))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit :blackcannotwin nur dann, wenn Schwarz nur noch den König besitzt,
und in allen anderen Schachformen hat dieses Schlüsselwort keine
Bedeutung und ist immer erfolglos.
</p>

<p>
Siehe auch: <cql>position:whitecannotwin</cql>
</p>

<h3 id="position:btm">:btm&emsp;<n>(Schwarz am Zug)</n></h3>

<p>
Filtere nur wenn Schwarz am Zug ist.
</p>

<p>
Siehe auch: <cql>position:wtm</cql>.
</p>

<h3 id="position:check">:check&emsp;<n>(Schachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach.
</p>

<p>
Siehe auch: <cql>position:nocheck</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:checkcount">:checkcount<extension/>&emsp;<n>(Schachgebotszähler)</n></h3>

<p>
Ist der Parameter eine einzelner Wert (zwischen 0 und 3 ist erlaubt),
dann werden alle Position gefiltert in denen der letzte Zug der anderen
Seite zum n-ten mal Schach bot.
</p>

<p>
Hat der Parameter die Form <expr>+&lt;n&#x2081;&gt;+&lt;n&#x2082;&gt;</expr>,
wobei <expr>&lt;n&#x2093;&gt;</expr> ein Wert zwischen 0 und 3 ist, so wird
die erste Position gefiltert, in der Weiß dem Schwarzen n&#x2081; Schachgebote
gab, und Schwarz dem Weißen n&#x2082; Schachgebote.
</p>

<note>
Diese Abfrage ist nur sinnvoll in der Schachform %::mc::VariantName(ThreeCheck)%,
in allen anderen Schachformen schlägt diese Abfrage immer fehl (ausgenommen
alle Parameterwerte sind Null).
</note>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:checkcount</keyword> 2)
</verb>

<p>
Filtere sobald eine der Seiten dem anderen sein zweites Schach bot.
</p>

<verb>
(position <keyword>:checkcount</keyword> +0+3)
</verb>

<p>
Filtere wenn Schwarz dem weißen König zum dritten Mal Schach bot. Dies kann nur
eine Endstellung sein.
</p>

<verb>
(position <cql>position:not</cql> <keyword>:checkcount</keyword> +0+0)
</verb>

<p>
Dies isr tatsächlich eine sinnvolle Abfrage. Wir nehmen an, daß eine
der Partien mit folgender Position beginnt (beschrieben mit einer
<a href="FEN.html">FEN</a>):
</p>

<dir><code>
rnb1k1nr/pppp1ppp/8/4p3/3PP2q/2N5/PP3PPP/R1BQKBNR w KQkq - 1 5 +0+2
</code></dir>

<p>
Diese Partie würde gefiltert werden (das Schlüsselwort :not ist zu beachten),
denn Schwarz hat dem weißen König bereits zweimal Schach geboten. Mit anderen
Worten: diese Abfrage sucht nach Partien die mit einer fortgeschrittenen
Stellung beginnen, wobei eine Seite der anderen bereits ein Schachgebot gab.
</p>

<h3 id="position:castling">:castling<extension/>&emsp;<n>(Rochade)</n></h3>

<p>
Dieses Schlüsselwort spezifiziert die Rochademöglichkeiten beider Seiten.
Es erwartet als Argument einen Figurenartbezeichner, wobei die Figurenarten
folgende Bedeutung haben:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">Weiß besitzt das Recht zur kurzen Rochade</td>
    </tr>
    <tr>
      <td class="l"><expr>&Q;</expr></td>
      <td class="r">Weiß besitzt das Recht zur langen Rochade</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Schwarz besitzt das Recht zur kurzen Rochade</td>
    </tr>
    <tr>
      <td class="l"><expr>&q;</expr></td>
      <td class="r">Schwarz besitzt das Recht zur langen Rochade</td>
    </tr>
  </table>
</dir>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:castling</keyword> &K;)
</verb>

<p>
Weiß hast das Recht zu kurzen Rochade.
</p>

<verb>
(position <keyword>:castling</keyword> [&K;&Q;])
</verb>

<p>
Weiß has das Recht entweder für die kurze oder für die lange Rochade
(aber nicht für beide).
</p>

<verb>
(position <keyword>:castling</keyword> &K; <keyword>:castling</keyword> &Q;)
</verb>

<p>
Weiß hat das Recht für kurze und lange Rochade.
</p>

<h3 id="position:contactcheck">:contactcheck<extension/>&emsp;<n>(Kontaktschachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach, und es ist ein Kontaktschachgebot
(kein Zwischensetzen einer Figur möglich, auch nicht theoretisch).
</p>

<p>
Dies ist equivalent zu:
</p>

<verbatim>
(position
  <cql>position:check</cql> <comment>; um Schlagschachpartien auszufiltern</comment>
  <cql>position:or</cql> (
    (position <cql>position:doublecheck</cql>)
    (position <cql>position:attackcount</cql> [&N;&P;] &k; 1 <cql>position:flipcolor</cql>)
    (position [&Q;&R;]d4 &k;e4 <cql>position:flipcolor</cql> <cql>position:flip</cql>)
    (position [&Q;&B;]d4 &k;e5 <cql>position:flipcolor</cql> <cql>position:flip</cql>)))
</verbatim>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:doublecheck">:doublecheck<extension/>&emsp;<n>(Doppelschachgebot)</n></h3>

<p>
Eine Seite befindet sich im Schach, und es ist ein Doppelschachgebot.
</p>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:endgame">:endgame<extension/>&emsp;<n>(Endspiel)</n></h3>

<p>
Die Position ist eine Endspielposition. Dieses Schlüsselwort ist equivalent
zur folgenden Abfrage:
</p>

<verbatim>
  (position
    <cql>position:or</cql> (
      (position
      <cql>position:piececount</cql> [&Q;&q;] 0
      <cql>position:piececount</cql> [&R;&B;&N;] 0 3
      <cql>position:piececount</cql> [&r;&b;&n;] 0 3)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &q; 1
      <cql>position:piececount</cql> [&R;&r;] 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> i 0 1)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &R; 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> &q; 0
      <cql>position:power</cql> [&r;&b;&n;] 0 16
      <cql>position:flipcolor</cql>)))
</verbatim>

<p>
Siehe auch: <cql>position:noendgame</cql>.
</p>

<h3 id="position:fen">:fen<extension/></h3>

<p>
Die Position ist identisch zur beschriebenen Position im Argument. Dieses
Argument muß eine gültige <a href="FEN.html">FEN</a> sein.
</p>

<h3 id="position:fiftymoverule">:fiftymoverule<extension/>&emsp;<n>(Fünfzig-Züge-Regel)</n></h3>

<p>
Die erste Position in der Partie, in der in den letzten 50 aufeinanderfolgenden
Zügen kein Stein geschlagen und auch kein Bauer gezogen wurde.
</p>

<p>
Siehe auch: <cql>position:halfmoveclocklimit</cql>.
</p>

<h3 id="position:gameisover">:gameisover<extension/>&emsp;<n>(Partie ist beendet)</n></h3>

<p>
Dies ist eine Kurzschreibweise für:
</p>

<verbatim>
  <cql>position:or</cql> (
    (position <cql>position:mate</cql>)
    (position <cql>position:stalemate</cql>)
    (position <cql>position:losing</cql>)
    (position <cql>position:checkcount 3</cql>)
    (position <cql>position:nomatingmaterial</cql>))
</verbatim>

<h3 id="position:initial">:initial&emsp;<n>(Startposition)</n></h3>

<p>
Dies ist die erste Position in der Partie (vor dem ersten Zug).
</p>

<h3 id="position:halfmoveclocklimit">:halfmoveclocklimit<extension/>&emsp;<n>(Halbzugzähler)</n></h3>

<p>
Dieses Schlüsselwort filtert Positionen, in denen der Halbzugzähler kleiner
oder gleich dem gegebenen Limit ist.
</p>

<p>
Halbzugzähler: Das ist die Anzahl der Halbzüge seit dem letzten Zug, in dem
ein Bauer zog oder eine Figur geschlagen wurde. Dieser Zähler entscheidet
auch, ob eine Seite ein Remis reklamieren kann aufgrund der 50-Züge-Regel
(<see/> <cql>position:fiftymoverule</cql>).
</p>

<p>
Beispiel:
</p>

<verb>
<keyword>:halfmoveclocklimit</keyword> 30
</verb>

<p>
Schließe alle Positionen aus, in denen in den letzten 30 Halbzügen (15 Züge
auf jeder Seite) kein Bauernzug erfolgte und auch kein Stein geschlagen
wurde.
</p>

<p>
Siehe auch: <cql>position:fiftymoverule</cql>.
</p>

<h3 id="position:losing">:losing<extension/>&emsp;<n>(Verlust)</n></h3>

<p>
Filtere alle Endstellungen, in denen eine der Seiten alle Figuren verlor.
Dies ist nur in Schlagschachpartien möglich.
</p>

<p>
Siehe auch: <cql>position:nolosing</cql>.
</p>

<h3 id="position:markall">:markall&emsp;<n>(Alles markieren)</n></h3>

<p>
Dieses Schlüsselwort wird unterstützt um kompatibel mit dem CQL-Standard
zu sein, es hat jedoch keinerlei Bedeutung in Scidb.
</p>

<h3 id="position:mate">:mate&emsp;<n>(Schachmatt)</n></h3>

<p>
Filtere nur dann, wenn es eine Mattstellung ist.
</p>

<annotation>
Wenn nach Mattstellungen gesucht wird, dann sollte stets auch dieses
Schlüsselwort mitverwendet werden auch wenn es aufgrund anderer
Bedingungen überflüssig erscheint, denn es beschleunigt die Suche (nur
Endstellungen werden geprüft).  </annotation>

<p>
Beispiel:
</p>

<verb>
(position <keyword>:mate</keyword> <cql>position:movenumber</cql> 1 20)
</verb>

<p>
Filtere nur dann wenn eine Seite in den ersten 20 Zügen mattgesetzt wurde.
</p>

<p>
Siehe auch: <cql>position:nomate</cql>.
</p>

<h3 id="position:matingmaterial">:matingmaterial<extension/>&emsp;<n>(Mattmaterial)</n></h3>

<p>
Filtere Positionen, in denen einer der Spieler noch über Mattmaterial verfügt
(<see/> <cql>position:nomatingmaterial</cql>).
</p>

<p>
Siehe auch: <cql>position:nomatingmaterial</cql>.
</p>

<h3 id="position:noannotate">:noannotate&emsp;<n>(nicht kommentieren)</n></h3>

<p>
Dieses Schlüsselwort wird unterstützt um kompatibel mit dem CQL-Standard
zu sein, es hat jedoch keinerlei Bedeutung in Scidb.
</p>

<h3 id="position:nocheck">:nocheck&emsp;<n>(kein Schachgebot)</n></h3>

<p>
Keine Seite befindet sich im Schach.
</p>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:nocontactcheck">:nocontactcheck<extension/>&emsp;<n>(kein Kontaktschachgebot)</n></h3>

<p>
Keine Seite befindet sich im Schach, oder aber es ist kein
Kontaktschachgebot (<see/> <cql>position:contactcheck</cql>).
</p>

<p>
Siehe auch: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:contactcheck</cql>.
</p>

<h3 id="position:nodoublecheck">:nodoublecheck<extension/>&emsp;<n>(kein Doppelschachgebot)</n></h3>

<p>
Keine der Seiten befindet sich im Schach, oder aber es ist kein
Doppelschachgebot.
</p>

<h3 id="position:noendgame">:noendgame<extension/>&emsp;<n>(kein Endspiel)</n></h3>

<p>
Diese Position ist keine Endspielposition (<see/>
<cql>position:endgame</cql>).
</p>

<p>
Siehe auch: <cql>position:endgame</cql>.
</p>

<h3 id="position:nomate">:nomate<extension/>&emsp;<n>(kein Schachmatt)</n></h3>

<p>
Schließe alle Mattstellungen aus.
</p>

<p>
Siehe auch: <cql>position:mate</cql>.
</p>

<h3 id="position:nomatingmaterial">:nomatingmaterial<extension/>&emsp;<n>(kein Mattmaterial)</n></h3>

<p>
Filtere alle Position, in denen keiner der Spieler noch über Mattmaterial
verfügt.
</p>

<p>
Normalerweise ist dies equivalent zur folgenden Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; König gegen König</comment>
  (<cql>position:piececount</cql> U 2)
  <comment>; König und Leichtfigur gegen König</comment>
  (<cql>position:piececount</cql> U 3 <cql>position:piececount</cql> [Ii] 1)
  <comment>; king and Läufer gegen König und Läufer,</comment>
  <comment>; beide Läufer entweder weiß- oder schwarzfeldrig</comment>
  (<cql>position:piececount</cql> U 4 <cql>position:piececount</cql> [&B;&b;][a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,
     c7,d2,d4,d6,d8,e1,e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2)
  (<cql>position:piececount</cql> U 4 <cql>position:piececount</cql> [&B;&b;][a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,
     c8,d1,d3,d5,d7,e2,e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit :nomatingmaterial nur dann, wenn nur noch Könige auf dem Schachbrett
sind, und in allen anderen Schachformen hat dieses Schlüsselwort keine
Bedeutung und ist immer erfolglos.
</p>

<p>
Siehe auch: <cql>position:matingmaterial</cql>.
</p>

<h3 id="position:nostalemate">:nostalemate<extension/>&emsp;<n>(kein Patt)</n></h3>

<p>
Filtere nur Positionen in denen niemand patt ist.
</p>

<p>
Siehe auch: <cql>position:stalemate</cql>,
</p>

<h3 id="position:repetition">:repetition<extension/>&emsp;<n>(Stellungswiederholung)</n></h3>

<p>
Filtere die erste Position in der Hauptvariante, die zum dritten Mal in der
Partie wiederholt wurden, mit der gleichen Seite am Zug, und den gleichen
Rochade- und En-Passant-Rechten. Diese Wiederholung muß nicht aufeinanderfolgen.
Dies stimmt mit der FIDE-Regelung der
<a href="http://de.wikipedia.org/wiki/Stellungswiederholung">
Stellungswiederholung</a> überein.
</p>

<h3 id="position:stalemate">:stalemate&emsp;<n>(Patt)</n></h3>

<p>
Filtert alle Pattstellungen.
</p>

<p>
Siehe auch: <cql>position:nostalemate</cql>,
</p>

<h3 id="position:terminal">:terminal<extension/>&emsp;<n>(Endstellung)</n></h3>

<p>
Diese ist die letzte Position in der Partie.
</p>

<h3 id="position:variations">:variations&emsp;<n>(Varianten)</n></h3>

<p>
Ziehe die Untervarianten in die Suche mit ein. Ohne diese Angabe werden
die Untervarianten bei der Suche ausgelassen.
</p>

<h3 id="position:variationsonly">:variationsonly&emsp;<n>(nur die Varianten)</n></h3>

<p>
Suche nur in den Untervarianten, nicht in der Hauptvariante.
</p>

<h3 id="position:whitecannotwin">:whitecannotwin<extension/>&emsp;<n>(Weiß kann nicht gewinnen)</n></h3>

<p>
Filtert nur dann wenn Weiß keine Gewinnmöglichkeit mehr hat.
</p>

<p>
Normalerweise ist dies equivalent zur folgenden Abfrage:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; nur weißer König</comment>
  (<cql>position:piececount</cql> A 1)
  <comment>; nur weißer König und weiße Leichtfigur</comment>
  (<cql>position:piececount</cql> A 2 <cql>position:piececount</cql> I 1))
</verbatim>

<p>
In der Schachform %::mc::VariantName(ThreeCheck)% filtert die Suche
mit :whitecannotwin nur dann, wenn Weiß nur noch den König besitzt,
und in allen anderen Schachformen hat dieses Schlüsselwort keine
Bedeutung und ist immer erfolglos.
</p>

<p>
Siehe auch: <cql>position:blackcannotwin</cql>
</p>

<h3 id="position:wtm">:wtm&emsp;<n>(Weiß am Zug)</n></h3>

<p>
Filtert nur wenn Weiß am Zug ist.
</p>

<h2 id="transform">Transformierende Schlüsselwörter</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:flip">:flip</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:inside">:inside</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shift">:shift</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:flip">:flip&emsp;<n>(Spiegelung)</n></h3>

<p>
Dies ist identisch zu <cql>position:flipdihedral</cql> (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipcolor">:flipcolor&emsp;<n>(Farbwechsel)</n></h3>

<p>
Die Farbwecheseltransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipdiagonal">:flipdiagonal&emsp;<n>(Diagonale Spiegelung)</n></h3>

<p>
Die diagonale und gegendiagonale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipdihedral">:flipdihedral&emsp;<n>(Diedrische Transformation)</n></h3>

<p>
Alle diahedralen Transformationen (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:fliphorizontal">:fliphorizontal&emsp;<n>(Horizontale Spiegelung)</n></h3>

<p>
Die horizontale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:flipvertical">:flipvertical&emsp;<n>(Vertikale Spiegelung)</n></h3>

<p>
Dei vertikale Spiegelungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:inside">:inside<extension/>&emsp;<n>(innerhalb)</n></h3>

<p>
Dieses Schlüsselwort filtert Verschiebungstransformation, bei denen
die involvierten Figuren innerhalb einer bestimmten Region auf dem
Schachbrett verbleiben. Es werden zwei Argumente erwartet, ein
Figurenbezeichner und ein Felderbezeichner. Jegliche
Verschiebungstransformation beinflußt nur das erste Argument.
Eine Verschiebungstransformation wird von der :inside-Beschränkung
gefiltert, wenn mindestens eine Figur, die mit dem ersten Argument
bezeichnet wird (wobei die Transformation mit einbezogen ist), auf einem
Feld steht das vom zweiten Argument bezeichnet wird.
</p>

<p>
Beispiel:
</p>

<p>
Wir formulieren die folgende Abfrage um Trippelbauern aufzufinden:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Um Trippelbauern auf der Hauptdiagonalen (a1-h8) aufzufinden, erweitern
wir diese Abfrage:
</p>

<verbatim>
(position
  <keyword>:inside</keyword> &P;[b2-7] [b2,c3,d4,e5,f6,g7]
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<h3 id="position:shift">:shift&emsp;<n>(Verschiebungstransformation)</n></h3>

<p>
Die Verschiebungstransformationen (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftdiagonal">:shiftdiagonal&emsp;<n>(Diagonale Verschiebung)</n></h3>

<p>
Die (haupt-)diagonale und gegendiagonale Verschiebungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shifthorizontal">:shifthorizontal&emsp;<n>(Horizontale Verschiebung)</n></h3>

<p>
Die horizontale Verschiebungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftmaindiagonal">:shiftmaindiagonal&emsp;<n>(Hauptdiagonale Verschiebung)</n></h3>

<p>
Die (haupt-)diagonale Verschiebungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftoffdiagonal">:shiftoffdiagonal&emsp;<n>(Gegendiagonale Verschiebung)</n></h3>

<p>
Die gegendiagonale Verschiebungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h3 id="position:shiftvertical">:shiftvertical&emsp;<n>(Vertikale Verschiebung)</n></h3>

<p>
Die vertikale Verschiebungstransformation (<see/>
<a href="CQL-Transformations.html">Transformationen</a>).
</p>

<h2 id="piece">Schlüsselwörter für die Figurenanalyse</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piececount">:piececount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:power">:power</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:ray">:ray</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:attackcount">:attackcount&emsp;<n>(Angriffs-Zähler)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argumente zwei Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Der erste
ist der Figurenbezeichner der attackierenden Figuren, der zweite ist
der Figurenbezeichner der angegriffenen Figuren. Ein Angriff einer Figur
auf ein Feld liegt vor, wenn die bezeichnete Figur auf dieses Feld ziehen kann.
:attackcount zählt alle gültigen Züge (Angriffe), deren Ausgangsfeld vom ersten
Argument bezeichnet wird, und deren Zielfeld vom zweiten Argument bezeichnet
wird.
</p>

<p>
<img src="../images/gameflag-Illegal-Move.png">
<a href="http://www.rbnn.com/cql/">CQL Manual</a> sagt aus:
"disregarding any possible checks"; dies ergibt keinen Sinn.
</p>

<p>
Das Schlüsselwort :attackcount filtert eine Position, wenn dir Gesamtzahl
aller gültigen Angriffe in dieser Position innerhalb der gegebenen
Bereichsangabe liegt.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2)
</verb>

<p>
Filtert jede Position mit einem Doppelangriff weißer Figuren auf den
schwarzen König (jedoch sollte für diese Abfrage 
<cql>position:doublecheck</cql> in Verbindung mit <cql>position:btm</cql>
vorgezogen werden).
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2 <cql>position:flipcolor</cql>)
</verb>

<p>
Filtert jede Position mit einem Doppelangriff auf einen König
(auch hier sollte <cql>position:doublecheck</cql> vorgezogen werden).
</p>

<verb>
(position <keyword>:attackcount</keyword> A .h3 1)
</verb>

<p>
Filtert eine Position, in der genau eine weiße Figur auf das freie Feld h3
ziehen kann.
</p>

<verb>
(position <keyword>:attackcount</keyword> [&R;&B;][a-c8] ??1 5 9
</verb>

<p>
Filtert eine Position, in der die Anzahl der Möglichkeiten, daß ein weißer
Turm oder ein weißer Läufer auf den Feldern a8, b8, oder c8 auf ein Feld
der ersten Reihe ziehen kann, zwischen 5 und 9 liegt (inklusive).
</p>

<verb>
(position <keyword>:attackcount</keyword> &n; [&K;&R;&Q;] 3 100) 
</verb>

<p>
Filtert eine Position, in der es genau drei Möglichkeiten gibt, daß ein
schwarzer Springer den weißen König oder eine weiße Schwerfigur attackiert.
</p>

<h3 id="position:piececount">:piececount&emsp;<n>(Figurenzähler)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argument einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert
eine Position genau dann, wenn die Anzahl der Vorkommen einer bezeichneten
Figur in dieser Position innerhalb der gegebenen Bereichsangabe liegt.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:piececount</keyword> &R; 2)
</verb>

<p>
Dies wird jede Position filtern mit exakt zwei weißen Türmen - eine Position
mit drei weißen Türmen würde nicht gefiltert werden.
</p>

<verbatim>
(position 
  <keyword>:piececount</keyword> [&R;&r;][a1-8] 1 3 
  <keyword>:piececount</keyword> [&Q;&q;][a-h8] 4 
  &N;d4)
</verbatim>

<p>
Dies wird jede Position filtern mit einem weißen Springer auf d4, ein bis drei
Türmen auf eine Linie, und exakt vier Damen auf der achten Reihe. Ein alternative
Schreibweise dieser Abfrage ist:
</p>

<verbatim>
(position 
  &N;d4
  <keyword>:piececount</keyword> [&R;&r;][a?] 1 3 
  <keyword>:piececount</keyword> [&Q;&q;][?8] 4)
</verbatim>

<h3 id="position:power">:power&emsp;<n>(Figurenpotential)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argument einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es wird
jede Position gefiltert, in der das Gesamtfigurenpotential in dieser Position
innerhalb der gegebenen Bereichsangabe liegt. Das Potential einer Figur
ist sein Materialwert, abhängig von der Schachform:
</p>

<dir>
  <table cellpadding="3">
    <tr>
      <td align="right"></td>
      <td align="right">&King;</td>
      <td align="right">&Queen;</td>
      <td align="right">&Rook;</td>
      <td align="right">&Bishop;</td>
      <td align="right">&Knight;</td>
      <td align="right">&Pawn;</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Normal)%, %::mc::VariantName(ThreeCheck)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Crazyhouse)%, %::mc::VariantName(Bughouse)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Losers)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 4</td>
      <td align="right"> 3</td>
      <td align="right"> 4</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Suicide)%, %::mc::VariantName(Giveaway)%&emsp;</td>
      <td align="right">30</td>
      <td align="right"> 3</td>
      <td align="right"> 9</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 1</td>
    </tr>
  </table>
</dir>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:power</keyword> a 6)
</verb>

<p>
Dies wird Positionen finden deren Gesamtfigurenpotential aller schwarzen
Figuren genau den Wert 6 hat.
</p>

<verb>
(position <keyword>:power</keyword> A[a-h1-4] 10 25)
</verb>

<p>
Dies wird Positionen finden deren Gesamtfigurenpotential aller weißen
Figuren in der weißen Hälfte einen Wert zwischen 10 und 25 hat (inklusive).
</p>

<h3 id="position:powerdifference">:powerdifference&emsp;<n>(Figurenpotentialdifferenz)</n></h3>

<p>
Dieses Schlüsselwort erwartet als Argument einen Figurenbezeichner, gefolgt
von einer <a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Es filtert
Positionen in denen die Differenz des Figurenpotentials (<see/>
<cql>position:power</cql>) der weißen und schwarzen Figuren, die vom ersten
Argument bezeichnet werden, innerhalb der gegebenen Bereichsangabe liegt.
D.h. das Figurenpotential aller bezeichneten weißen Figuren minus dem
Figurenpotential aller bezeichneten schwarzen Figuren muß innerhalb der
Bereichsangabe liegen.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:powerdifference</keyword> U 4)
</verb>

<p>
Dies filtert Positionen, in denen das Potential der weißen Figuren genau
um 4 größer ist als das Potential der schwarzen Figuren.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;] -5 10)
</verb>

<p>
Diese filtert Positionen, in denen Weiß ein Potential zwischen einem Turm
Materialnachteil und zwei Türmen Materialvorteil besitzt (wobei diese
Formulierung nicht auf andere Schachformen zutrifft).
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;&B;&b;&N;&n;] unlimited -2)
</verb>

<p>
Dies filtert Positionen, in denen Schwarz mindestens eine Qualität Vorteil hat
(auch diese Formulierung trifft nicht auf andere Schachformen zu).
</p>

<verbatim>
(match
  (position
    <cql>match:result</cql> 1-0
    <cql>position:sequence</cql> (
      (position
        <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9
        <keyword>:powerdifference</keyword> U unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9))
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
Dieses Beispiel zeigt eine Möglichkeit auf, wie mit Hilfe von :powerdifference
nach Damenopfern gesucht wird. Eine Seite opfert eine Dame, und verbleibt
mindestens 12 Züge lang mit mindestens 9 Bauern Materialnachteil, um
letztendlich zu gewinnen.
</p>

<h3 id="position:ray">:ray&emsp;<n>(Strahl)</n></h3>

<p>
Ein Strahl bezeichnet eine Liste von Figurenbezeichnern. Es ist eine
zusammenhängende Menge von Feldern entweder auf einer Linie, einer Reihe,
oder einer Diagonalen auf dem Schachbrett.
</p>

<p>
Sei R ein Felderstrahl mit einer geordneten Menge von Feldern in einer
zusammenhängenden Linie, Reihe, oder Diagonalen
S&#x2081;, S&#x2082;,...,S&#x2090;. Gegeben sei eine Strahlendefinition
(G&#x2081;, G&#x2082;,...,G&#x2093;), wobei jedes G einen Figurenbezeichner
definiert. Der Felderstrahl R ist gültig in Bezug auf die gegebene
Strahlendefinition wenn G&#x2081; eine Figur auf dem Feld S&#x2081;
bezeichnet, G&#x2093; eine Figur auf dem Feld S&#x2090; bezeichnet, und wenn
alle anderen G's jeweils mit einem Feld einer Untermenge des Felderstrahls
gepaart werden können ohne die Reihenfolge zu verletzen, so daß jedes G eine
Figur auf dem zugeordneten Feld bezeichnet, und alle ungepaarten Felder leer
sind.
</p>

<p>
Das Schlüsselwort :ray erwartet eine Strahlendefinition und eine optionale
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>. Wenn die Bereichsangabe
nicht vorhanden ist, so wird <nobr><code>1</code>
<code>unlimited</code></nobr> als Bereich angenommen. :ray filtert eine Position
wenn die Anzahl der Felderstrahlen in dieser Position, die in Bezug auf die
Strahlendefinition gültig sind, innerhalb der Bereichsangabe liegen.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:ray</keyword> (&k; &Q;)) 
</verb>

<p>
Filtert eine Position, in der eine weiße Dame den schwarzen König attackiert.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &n; &k;[?4-8]))
</verb>

<p>
Filtert eine Position, in der eine weiße Dame auf der a-Linie einen schwarzen
Springer fesselt, und der schwarze König auf den letzten vier Reihen steht.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &Q;c? &Q;e? &k;g?))
</verb>

<p>
Filtert entweder eine Position, in der alle drei weißen Damen und der schwarze
König auf der gleichen Reihe stehen mit jeweils exakt einem Leerfeld zwischen
diesen Figuren, oder eine Position, in der alle drei weißen Damen und der
schwarze König eine Diagonale formen mit jeweils einem Leerfeld zwischen diesen
Figuren, und die Damen stehen in beiden Fällen auf den a, c, und e-Linien.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q; &n; &k;) 2 4)
</verb>

<p>
Zwei bis vier schwarze Springer sind gefesselt.
</p>

<p>
Siehe auch: <cql>position:rayattack</cql>.
</p>

<h3 id="position:rayattack">:rayattack&emsp;<n>(Strahlenangriff)</n></h3>

<p>
Hat die gleiche Syntax wie <cql>position:ray</cql>. Es hat auch die gleiche
Semantik, außer das nur orthogonale Strahlen, die auf einem Feld mit einer
Schwerfigur starten, sowie diagonale Strahlen, die auf einem Feld mit einer
diagonal ziehenden Figur (Dame oder Läufer) starten, eingeschlossen sind.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:rayattack</keyword> (A a &k;))
</verb>

<p>
Filtert eine Position, in der eine schwarze Figur gefesselt ist.
</p>

<verb>
(position <keyword>:rayattack</keyword> (Ad5 a [&r;&k;][a-h1-4]) 3)
</verb>

<p>
Filtert Positionen, in denen drei schwarze Figuren von einer weißen Figur auf
d5 gefesselt werden, wobei ein schwarzer Turm und der schwarze König auf den
ersten vier Reihen stehen.
</p>

<verb>
(position <cql>position:stalemate</cql> <keyword>:rayattack</keyword>
(A a &k;) 2 8 <cql>position:flipcolor</cql>)
</verb>

<p>
Findet Pattstellungen mit Mehrfachfesselungen auf.
</p>

<p>
Siehe auch: <cql>position:ray</cql>.
</p>

<h3 id="position:raydiagonal">:raydiagonal&emsp;<n>(Diagonalstrahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf diagonale Linien beschränkt sind. Ein diagonaler Strahl arbeitet
auf der Diagonalen.
</p>

<h3 id="position:rayhorizontal">:rayhorizontal&emsp;<n>(Horizontaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf horizontale Linien beschränkt sind. Ein horizontaler Strahl
arbeitet auf der Horizontalen.
</p>

<h3 id="position:rayorthogonal">:rayorthogonal&emsp;<n>(Othogonaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf vertikale und horizontale Linien beschränkt sind. Ein orthogonaler
Strahl arbeitet auf der Horizontalen und Vertikalen.
</p>

<h3 id="position:rayvertical">:rayvertical&emsp;<n>(Vertikaler Strahl)</n></h3>

<p>
Dieses Schlüsselwort arbeitet genauso wie <cql>position:ray</cql>, nur daß die
Strahlen auf  vertikale Linien beschränkt sind. Ein vertikaler Strahl arbeitet
auf der Vertikalen.
</p>

<h2 id="move">Schlüsselwörter für die Zuganalyse</h2>

<p>
Ein Zug hat drei Ausprägungen: einen Herkunftsbezeichner, einen
Zielbezeichner, und einen Bauernumwandlungsbezeichner. Diese beziehen
sich auf die Figur und das Feld von der dieser Zug weggeht; die Figur und
das Feld wohin dieser Zug geht (aber bevor dieser Zug tatsächlich erfolgt),
und die Figur und das Feld wo eine Bauernumwandlung stattfindet, sofern eine
solche vorhanden. In den Schachformen %::mc::VariantName(Crazyhouse)% und
%::mc::VariantName(Bughouse)% hat ein Zug noch eine vierte Ausprägung: den
Figurenartbezeichner für die Einsetzfigur. Er bezieht sich auf die Figurenart die
eingesetzt wird, sofern eine solche vorhanden.
</p>

<p>
Beispielsweise ist der Zielbezeichner für einen weißen Turm auf a4, der
einen schwarzen Springer auf d4 schlägt: <expr>&n;d4</expr>, und der
Herkunftsbezeichner ist <expr>&R;a4</expr>. Der Zielbezeichner eines
Zuges nach e4, der keine Figur schlägt, ist <expr>.e4</expr>.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveto">:moveto</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nopiecedrop">:nopiecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:promote">:promote</a></td></tr>
  </table>
</dir>

<h3 id="position:enpassant">:enpassant</h3>

<p>
Der nächste Zug ist ein en passant (Schlag-)Zug.
</p>

<p>
Siehe auch: <cql>position:noenpassant</cql>
</p>

<h3 id="position:iscastling">:iscastling<extension/>&emsp;<n>(Rochadezug?)</n></h3>

<p>
Der nächste Zug ist eine Rochade.
</p>

<p>
Siehe auch: <cql>position:nocastling</cql>.
</p>

<h3 id="position:movefrom">:movefrom&emsp;<n>(Zug von)</n></h3>

<p>
Erwartet als Parameter eine Figurenbezeichner. Eine Position wird gefiltert,
wenn dieser Figurenbezeichner den Herkunftsbezeichner des nächsten Zuges
beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:movefrom</keyword> &R;a3)
</verb>

<p>
Filter eine Position, in der der nächste Zug ein Turmzug von a3 ist.
</p>

<verb>
(position <keyword>:movefrom</keyword> U?8)
</verb>

<p>
Filter eine Position, in der die Figurenart des nächsten Zug einer Figurenart
auf der achten Reihe gleicht.
</p>

<h3 id="position:movenumber">:movenumber&emsp;<n>(Zugnummer)</n></h3>

<p>
:movenumber erwartet als Argument eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a>, und filtert eine
Position nur dann, wenn die aktuelle Zugnummer innerhalb des gegebenen
Bereichs liegt. Die Zugnummernzählung geht von einem Anzugsrecht der
weißen Seite aus, und könnte deshalb um eine Nummer niedriger sein, wenn
Scharz das Anzugsrecht hat.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:movenumber</keyword> 10 20 <cql>position:check</cql>)
</verb>

<p>
Filtert eine Position, in der ein Schachgebot zwischen dem 10. und dem
20. Zug erfolgt.
</p>

<verb>
(position <keyword>:movenumber</keyword> 35 <cql>position:mate</cql>)
</verb>

<p>
Filtert eine Position, in der im 35. Zug mattgesetzt wird.
</p>

<h3 id="position:moveto">:moveto&emsp;<n>(Zug nach)</n></h3>

<p>
Erwartet ale Argument einen Figurenbezeichner. Es filtert einen Zug
wenn dieses Argument den Zielbezeichner des Zuges beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:moveto</keyword> U)
</verb>

<p>
Filtert eine Position dessen nächster Zug ein Schlagzug ist.
</p>

<verb>
(position <keyword>:moveto</keyword> .)
</verb>

<p>
Filtert eine Position dessen nächster Zug kein Schlagzug ist.
</p>

<verb>
(position <keyword>:moveto</keyword> &R;[b1-8])
</verb>

<p>
Filtert eine Position, in der der nächste Zug einen weißen Turm auf der
f-Linie schlagen wird. Beachte das dies sehr verschieden ist von der
Interpretation einer Zugbeschreibung in
<a href="http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm">PGN</a>&#x2006;:
dort würde dies als ein Turmzug auf die b-Linie interpretiert werden.
Und dies wiederum geschieht in CQL auf diese Weise:
</p>

<verb>
(position <cql>position:movefrom</cql> &R; <keyword>:moveto</keyword> ?b?)
</verb>

<p>
Filtert einen Zug, in dem der weiße Turm auf die b-Linie zieht.
</p>

<h3 id="position:nocastling">:nocastling<extension/>&emsp;<n>(kein Rochadezug?)</n></h3>

<p>
Der nächste Zug ist keine Rochade.
</p>

<p>
Siehe auch: <cql>position:iscastling</cql>.
</p>

<h3 id="position:noenpassant">:noenpassant&emsp;<n>(kein En-Passant-Zug?)</n></h3>

<p>
Der nächste Zug ist kein en passant (Schlag-)Zug.
</p>

<p>
Siehe auch: <cql>position:enpassant</cql>.
</p>

<h3 id="position:piecedrop">:piecedrop<extension/>&emsp;<n>(Einsetzzug)</n></h3>

<p>
Der nächste Zug ist ein Einsetzzug, wobei der im Argument gebenene
Figurenartbezeichner den Figurenartbezeichner für die Einsetzfigur des
nächsten Zuges beinhalten muß. Dies ist bei einem nichtleeren
Figurenartbezeichner nur möglich in den Schachformen
%::mc::VariantName(Crazyhouse)% und %::mc::VariantName(Bughouse)%).
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:piecedrop</keyword> [&N;&n;])
</verb>

<p>
Der nächste Zug ist ein Einsetzzug, der einen Springer einsetzen wird.
</p>

<verb>
(position <keyword>:piecedrop</keyword> [])
</verb>

<p>
Der nächste Zug ist kein Einsetzzug (denn der Figurenartbezeichner ist
leer).
</p>

<h3 id="position:promote">:promote&emsp;<n>(Bauernumwandlung)</n></h3>

<p>
Erwartet als argument einen Figurenbezeichner. Ein Zug wird gefiltert wenn
es sich um eine Bauernumwandlung handelt, und der gegebene Figurenbezeichner
den Bauernumwandlungsbezeichner des Zuges beinhaltet.
</p>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:promote</keyword> [&R;&B;&N;])
</verb>

<p>
Filtert eine Position dessen nächster Zug eine weiße Unterverwandlung ist.
</p>

<verb>
(position <keyword>:promote</keyword> [&B;&N;]a8)
</verb>

<p>
Filtert eine Position dessen nächster Zug eine weiße Bauernumwandlung in
eine Leichtfigur ist.
</p>

<verb>
(position <keyword>:promote</keyword> [&R;e8]
<cql>position:movefrom</cql> &P;f7 <cql>position:moveto</cql> &q;)
</verb>

<p>
Filtert eine Position, in der der nächster Zug einen Bauern von f7 nach e8
zieht, wobei eine schwarze Dame geschlagen wird und eine Bauernumwandlung
in einen Turm geschieht.
</p>

<verb>
(position <keyword>:promote</keyword> [])
</verb>

<p>
Filtert eine Position, in der der nächster Zug keine Bauernumwandlung ist
(denn der Figurenbezeichner ist leer).
</p>

<h2 id="sequence">Schlüsselwörter für Sequenzen</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sequence">:sequence</a></td></tr>
  </table>
</dir>

<h3 id="position:gappedsequence">:gappedsequence&emsp;<n>(Folge)</n></h3>

<p>
Erwartet als Argument eine Liste von Positionslisten. Eine Positionsliste A
wird als eine Verfeinerung einer Positionsliste B definiert, wenn A aus B
geformt werden kann durch das Einfügen von beliebig vielen (einschließlich Null)
Listen der Form <expr>(position)</expr> auf oberster Ebene in B. Zum Beispiel:
</p>

<verb>
((position &N;a4) (position) (position &R;b2))
</verb>

<p>
verfeinert
</p>

<verb>
((position &N;a4) (position &R;b2))
</verb>

<p>
denn es wurde geformt durch das Einfügen einer einzelnen Position in die
letztere Liste.
</p>

<p>
Eine Folge (:gappedsequence) mit Argument B filtert eine Position genau dann,
wenn es eine Verfeinerung A von B gibt, so daß eine Aufeinanderfolge
(<cql>position:sequence</cql>) mit Argument A diese Position filtern würde.
D.h., :gappedsequence ist wie <cql>position:sequence</cql>, außer das die
Aufeinanderfolge von filternden Positionen dazwischenliegende Positionen
der Partie enthalten kann.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
Diese wird jede Position filtern, die mit der ersten Position in der Liste
von :gappedsequence startet, und nach Null oder mehr weiteren
aufeinanderfolgenden Positionen in der Partie die zweite Position von
:gappedsequence auffindet. Dasselbe Ergebnis kann viel effektiver auf
folgende Weise ermittelt werden:
</p>

<p>
<img src="../images/gameflag-Illegal-Move.png">
Das ist zu prüfen!
</p>

<verbatim>
(position 
  <cql>position:initial</cql>
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
Die folgende Positionsliste filtert eine Position, in der der Springer auf d4
steht in irgendeiner Partiestellung, aber nach der gefundenen Position:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position)
    (position &N;d4))) 
</verbatim>

<p>
Beachte daß das erste Element des Arguments von :gappedsequence, nämlich
<expr>(position)</expr>, nur benutzt wird, um zu erreichen das nur Springer
auf d4 in Positionen gefunden werden, die nach der gefilterten Position
liegen. Dazu ein vollständiges Beispiel:
</p>

<verbatim>
(match
  <comment>; iteriere über alle in Frage kommenden Springer</comment>
  <cql>position:forany</cql> knight [Nn]
  (position
    <comment>; die markierte Figur ist tatsächlich ein Springer</comment>
    <comment>; auf d4, kein umgewandelter Bauer</comment>
    <cql>position:tagmatch</cql> knight [Nn]d4
    <comment>; sorge dafür das es das letzte derartige Vorkommen ist</comment>
    <cql>position:not</cql> (position <keyword>:gappedsequence</keyword>
      ((position) (position $knight[d4])))
    <comment>; nun wiederhole mit anderen Feldern außer e4</comment>
    <cql>position:shift</cql>
    <comment>; filtere wenn mindestens 20 verschiedene Felder gefunden wurden</comment>
    <cql>position:matchcount</cql> 20 65))
</verbatim>

<p>
Finde Partien, in denen ein Springer mindestens 20 verschiedene Felder
besuchte. Dies wird bewerkstelligt durch das Zählen von Positionen, die vom
Springer nicht noch ein zweites Mal besucht werden. Felder die von einem
Bauern besucht werden, der später in einen Springer verwandelt, sind nicht
in der Zählung enthalten.
</p>

<p>
Die Gesamtzahl von <cql>position:sequence</cql> und :gappedsequence
Positionslisten, die auf oberster Ebene einer Positionsliste auftreten
können, darf Eins nicht überschreiten. Um die Wirkung von beiden
Schlüsselwörtern in einer Positionsliste zu erhalten, wird mit dem
Gebrauch von <cql>position:and</cql> bewerkstelligt.
</p>

<p>
<img src="../images/gameflag-Illegal-Move.png">
Diese Einschränkung ist zu prüfen!
</p>

<NEW>
<h3 id="position:sequence">:sequence&emsp;<n>(Aufeinanderfolge)</n></h3>

<p>
Takes a single argument that is a list of position lists. It matches a given
position if and only successive occurring positions, beginning with the
current position, match each corresponding element in its argument.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  &R;e8 
  <keyword>:sequence</keyword> (
    (position &Q;f3 .g2)
    (position .f3 &Q;g2)))
</verbatim>

This position list matches exactly those positions with a white rook on e8
such that:

<ol>
  <li>In that position, white has a queen on f3 and g2 is empty, and</li>
  <li>After the next move, f3 is empty and there is a white queen on g2.</li>
</ol>

<p>
In consequence, this position list is identical in effect to
</p>

<verb>
(position &R;e8 <cql>position:movefrom</cql> &Q;f3 <cql>position:moveto</cql> .g2)
</verb>

<p>
The following more typical usage of :sequence will search for all queen
staircase checking maneuvers by either side:
</p>

<verbatim>
(position 
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <keyword>:sequence</keyword> (
    (position <cql>position:movefrom</cql> &Q;a2) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;b2) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;b3) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;c3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c4)))
</verbatim>

<p>
This position list matches any position with a white queen on a2 for which
there are successively moves by queens on the indicated squares giving check;
the <cql>position:shift</cql>, <cql>position:flip</cql>, and
<cql>position:flipcolor</cql> search for this variation reflected or
rotated anywhere on the board.
</p>

<h2 id="game">Schlüsselwörter für die Partieinformationen</h2>

<p>
Several keywords relate to the game parameters and are not affected by the
contents of the position; they are included as position list keywords instead
of match list keywords so the <cql>position:flipcolor</cql> can be used with
them. these are:
</p>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:rating">:rating</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    </tr>
  <tr>
      <td>      &#x2022;</td><td><a href="#position:result">:result</a></td>
  </tr>
  <tr>
      <td>      &#x2022;</td><td><a href="#position:variant">:variant</a></td>
  </tr>
  </table>
</dir>

<h3 id="position:blackelo">:blackelo&emsp;<n>(ELO - Schwarz)</n></h3>

<p>
This parameter takes a range specifier; the ELO of the black player must lie
within its range (<see/> <a href="CQL-Range-Specifiers.html">range specifiers</a>).
</p>

<h3 id="position:blackrating">:blackrating<extension/>&emsp;<n>(Wertungszahl - Schwarz)</n></h3>

<p>
Match all games where the specified rating score of black player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h3 id="position:elo">:elo</h3>

<p>
This parameter expects a range specifer; the ELO of at least one of the
players must lie within the specified range (<see/>
<a href="CQL-Range-Specifiers.html">range specifiers</a>)
</p>

<h3 id="position:rating">:rating<extension/>&emsp;<n>(Wertungszahl)</n></h3>

<p>
Match all games where the specified rating score of one player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h3 id="position:result">:result&emsp;<n>(Ergebnis)</n></h3>

<p>
This keyword takes one argument, the same as the argument to
<cql>match:result (match)</cql> in a match list.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position 
  <keyword>:result</keyword> 1-0 
  <cql>position:whiteelo</cql> 0 2300
  <cql>position:blackelo</cql> 2600 3000
  <cql>position:flipcolor</cql>)
</verbatim>

<p>
Searches for positions in which a 2300 player or below defeated a 2600 player
or above.
</p>

<h3 id="position:variant">:variant</h3>

<p>
Für eine Beschreibung dieses Schlüsselwortes siehe beim gleichnamigen
Schlüsselwort <cql>match:variant (match)</cql> der Suchliste. Dieses
Schlüsselwort wird hier bereitgestellt, um bei einzelnen Positionslisten
eine Unterscheidung zwischen den Schachformen treffen zu können.
</p>

<h3 id="position:whiteelo">:whiteelo&emsp;<n>(ELO - Weiß)</n></h3>

<p>
This parameter takes a range specifier; the ELO of the white player must lie
within its range (<see/> <a href="CQL-Range-Specifiers.html">range specifiers</a>).
</p>

<h3 id="position:whiterating">:whiterating<extension/>&emsp;<n>(Wertungszahl - Weiß)</n></h3>

<p>
Match all games where the specified rating score of white player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h2 id="relation">Relationen zwischen den Positionen</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:relation">:relation</a></td></tr>
  </table>
</dir>

<h3 id="position:relation">:relation</h3>

<p>
Takes one argument, a relation specification. is used to search for games with
pairs of positions P1 and P2 that satisfy certain properties. See
<a href="CQL-Relation-List.html">relation list</a> for a desription of
the relation specification keywords.
</p>

<h2 id="matching">Schlüsselwörter zur Zählung</h2>

<p>
Two keywords pertain to the number of positions which a position list matches.
These each take a range specifier as parameter. They can only be used in a
position list at the top level of a match list.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td></tr>
  </table>
</dir>

<h3 id="position:matchcount">:matchcount&emsp;<n>(Übereinstimmungszähler)</n></h3>

<p>
Matches if and only if the number of times this position list matches a
position in the current game lies within the range specifier.
</p>

<p>
Beispiel:
</p>

<verb>
(position <cql>position:moveto</cql> [&Q;&q;] <keyword>:matchcount</keyword> 4 100)
</verb>

<p>
Matches any game in which at least four queen captures have occurred.
</p>

<h3 id="position:pretransformmatchcount">:pretransformmatchcount&emsp;<n>(Transformationsinvarianter Übereinstimmungszähler)</n></h3>

<p>
Has the same syntax as <cql>position:matchcount</cql>. It matches a position if
and only if there is some transform in the transformation set associated with
the position list in which it occurs such that, were the position list
replaced by a new position list formed from the first by deleting all
transformation keywords, applying the transform to that position list, and
changing this keyword to <cql>position:matchcount</cql>, then the position
list would match the position.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <cql>position:movetoy</cql> [Aa]d4 
  <keyword>:pretransformmatchcount</keyword> 12 unlimited
  <cql>position:shift</cql>))
</verbatim>

<p>
This would match any game in which at least 12 captures occur on the same
square. Were the :pretransformmatchcount replaced by
<cql>position:matchcount</cql>, the position list would match games in which
at least 12 captures occurred.
</p>

<h2 id="evaluation">Schlüsselwörter für die Stellungsbeurteilun</h2>

<p>
The following keywords are analyzing positions. <cql>position:evaluation</cql> and
<cql>position:moveevaluation</cql> should be used with care, these are very slow
operations. In some cases the keywords <cql>position:exchangeevaluation</cql> and
<cql>position:maxswapevaluation</cql> might be an alternative, these functions are
quite faster, although quite time consuming.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td></tr>
  </table>
</dir>

<h3 id="position:evaluation">:evaluation<extension/>&emsp;<n>(Bewertung)</n></h3>

<annotation>
This is a very slow operation and should be restricted.
</annotation>

<p>
This keyword is evaluating the current position with the help of an
external chess engine. The number of parameters depends on the search mode.
There are three search modes:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>

    <!-- UCI:  "go mate <x>" -->
    <tr>
      <td class="l"><expr>mate &lt;n&gt;</expr></td>
      <td class="r">search for a mate in &lt;n&gt; moves</td>
    </tr>
  </table>
</dir>

<p>
The modes "depth" and "movetime" are taking three additional parameters.
The third parameter denotes the lower bound, the fourth parameter
denotes the upper bound, both scores are in centi-pawns. The query succeeds
if the estimation is within the specified bounds (inclusive the ranges). If
the lower-bound value is specified with <i>unlimited</i>, it means negative
unlimited. If the upper-bound value is specified with <i>unlimited</i>, it means
positive unlimited. The fifth parameter is either <i>sidetomove</i> or <i>absolute</i>.
<i>sidetomove</i> means that the evaluation value depends on side to move, and
<i>absolute</i> means that the evaluation value is independent from side to move.
</p>

<note>
Please note that the modes "depth" and "mate" are available only if the engine
supports the UCI protocol. An engine restricted to the WinBoard/XBoard protocol
does only support the "movetime" mode.
</note>

<p>
Beispiele:
</p>

<verb>
<keyword>:evaluate</keyword> depth 4 2.5 unlimited sidetomove
</verb>

<p>
Side to move has (possibly) a winning position, because he is
at least 2.5 pawn units ahead.
</p>

<verb>
<keyword>:evaluate</keyword> depth 4 unlimited -2.5 sidetomove
</verb>

<p>
Side to move has (possibly) a losing position, because he is
at least 2.5 pawn units behind.
</p>

<verb>
<keyword>:evaluate</keyword> movetime 3000 unlimited -3.0 absolute
</verb>

<p>
Black is (possibly) losing, because he is at least 3 pawn units behind.
</p>

<verb>
<keyword>:evaluate</keyword> mate 3
</verb>

<p>
Either side is mate in maximal 3 moves.
</p>

<h3 id="position:exchangeevaluation">:exchangeevaluation<extension/>&emsp;<n>(Figurentauschbewertung)</n></h3>

<p>
This keyword is analyzing capture moves to see whether or not they appear
to be profitable.
</p>

<p>
The keyword match the current move if this value is in the specified range
(a lower and an upper value). Only capture moves will be evaluated.
If lower range is specified with <i>unlimited</i>, it means negative unlimited.
If the lower range is specified with <i>unlimited</i>, it means positive unlimited.
The exchange function is taking into account that exchanged pieces may be
pinned or defended by other pieces. The value of the function does not depend
on which side is to move.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<p>
Beispiele:
</p>

<verb>
<keyword>:exchangeevaluation</keyword> unlimited 3
</verb>

<p>
This move is (possibly) a blunder.
</p>

<h3 id="position:maxswapevaluation">:maxswapevaluation<extension/>&emsp;<n>(Maximum einer Schlagabtauschbewertung)</n></h3>

<p>
This keyword allows to estimate exchange values of possible moves. It takes
as arguments two piece designators followed by a range specifier. The first
argument specifies moving pieces, the second one specifies target squares.
For each possible moves we compute an integer value that is a material benefit
of the move (in pawns, like in case of the <cql>position:power</cql> keyword)
according to possible piece exchanges on the target square after the move.
After that the maximum of all computed values will be selected.
</p>

<p>
The keyword match the position if this value lies in the specified range
(a lower and an upper value). If lower range is specified with <i>unlimited</i>,
it means negative unlimited. If the lower range is specified with <i>unlimited</i>,
it means positive unlimited. The exchange function is taking into account that
exchanged pieces may be pinned or defended by other pieces. The value of the
function does not depend on which side is to move.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<note>
This keyword is alike the keyword <expr>:maxswapvalue</expr> from Chess
Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
but quite different implemented.
</note>

<p>
Beispiele:
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> A a 1 unlimited)
</verb>

<p>
This query selects positions in which white threatens with
winning some material:
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> &Q;?1-7 ??8 0 unlimited)
</verb>

<p>
This query selects positions in which a white queen can invade rank 8
without a material loss.
</p>

<h3 id="position:moveevaluation">:moveevaluation<extension/>&emsp;<n>(Zugbewertung)</n></h3>

<annotation>
This is a very slow operation and should be restricted.
</annotation>

<p>
This keyword is matching the difference between the evaluation of the current
position and the evaluation of the preceding position. The evaluation will be
done with the help of an external chess engine. It takes seven parameters.
The first and second parameter are piece designators. The former is specifies
moving pieces, the second one specifies target squares.  The third and fourth
are depending on the search mode:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>
  </table>
</dir>

<p>
The fifth parameter denotes the lower bound score, the sixth parameter denotes
the upper bound score, both scores are in centi-pawns. If the lower-bound value
is specified with <i>unlimited</i>, it means negative unlimited. If the upper-bound
value is specified with <i>unlimited</i>, it means positive unlimited. The query
succeeds if the scoring of this move is within the given bounds (inclusive the
ranges). The score of this move is the difference between the score of the
current board and the score of the last board. In case of mating positions
the difference will be always greater than 10.000.
</p>

<note>
Please note that the mode "depth" is available only if the engine suppoprts the
UCI protocol. An engine restricted to the WinBoard/XBoard protocol does only
support the "movetime" mode.
</note>

<p>
The seventh parameter is either <i>sidetomove</i> or <i>absolute</i>.
<i>sidetomove</i> means that the evaluation value depends on side to move, and
<i>absolute</i> means that the evaluation value is independent from side to move.
</p>

<p>
Beispiel:
</p>

<verb>
<keyword>:moveevaluation</keyword> U ? depth 4 3.0 unlimited sidetomove
</verb>

<p>
Match first position were the evaluation score is at least 3.0 pawn units.
This means that last move was (possibly) a blunder.
</p>

<verb>
<keyword>:moveevaluation</keyword> A a depth 4 unlimited -3.0 absolute
</verb>

<p>
Match first position were the evaluation score is at least 3.0 pawn units
better for black. This means that last white move was (possibly) a blunder.
Only capture moves will be evaluated.
</p>

<verbatim>
(match
  (position <keyword>:moveevaluation</keyword> [&P;&p;] ?[a-h1,a-h8]
             unlimited 0.0 movetime 5000 absolute)
  (position <cql>position:promotion</cql> U <cql>position:cut</cql>)))
</verbatim>

<p>
Search for positions where side to move is doing first promotion in game, but
without gaining a better score. We are ensuring that only promoting moves will
be evaluated.
</p>

<h2 id="accumulator">Schlüsselwörter für Akkumulationen</h2>

<p>
There are mainly two accumulator keywords, :accumulate and :sumrange. These
are used to accumulate and to test the number of transforms of the enclosing
position list that match the current position. Each time a transform of a
position list matches a position, the accumulator associated with that position
is incremented. Any position with a sum range can then test if the accumulator
is within a certain range.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:reset">:reset</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td></tr>
  </table>
</dir>

<h3 id="position:accumulate">:accumulate&emsp;<n>(Akkumulieren)</n></h3>

<p>
This takes one parameter, the name of an accumulator. Each time the application
of some element of the transform set of the position list matches a position,
the accumulator associated with this name is incremented. The accumulator is
cleared when a new position is reached (and in consequence :accumulate should
not be used inside of <cql>position:not</cql>, or the
<cql>position:sequence</cql>, and <cql>position:gappedsequence</cql> keywords).
This keyword inhibits short-circuiting of logical keywords
<cql>position:and</cql>, and <cql>position:or</cql>. Note that
<cql>position:flipcolor</cql> likely has unexpected results when used with
:accumulate, because the accumulator is not cleared between color flips.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h3 id="position:reset">:reset<extension/>&emsp;<n>(Zurücksetzen)</n></h3>

<p>
This keyword takes as a parameter the name of an accumulator. It clears the
accumulator associated with this name after applying a transformation.
</p>

<p>
Beispiel:
</p>

<p>
Tripled pawns can be found by the query:
</p>

<verbatim>
(position
  <keyword>:reset</keyword> acc
  &P;e2
  <cql>position:accumulate</cql> acc
  <cql>position:sumrange</cql> acc 3
  <cql>position:shiftvertical</cql>
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Note that this is only an example for this keyword (taken from
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
it is not recommended to use this statement for triple pawn search.
A much better way is:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;a[3-7] 3 6
  <cql>position:shifthorizontal</cql>
  <cql>position:flipcolor</cql>))
</verbatim>

<h3 id="position:sumrange">:sumrange<extension/>&emsp;<n>(Ergebnisbereich)</n></h3>

<p>
This takes as parameter the name of an accumulator and a range specifer.
It matches a position if the value of the given accumulator lies within
the range specifier.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h2 id="tagging">Schlüsselwörter für das Markieren</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td></tr>
  </table>
</dir>

<h3 id="position:tagmatch">:tagmatch<extension/>&emsp;<n>(Markierungsvergleich)</n></h3>

<p>
The :tagmatch keyword takes two parameters, the name of a tag and a piece
designator. It matches only if the piece corresonding to the named tag
matches the given piece designator. For more information, see the section
on <a href="CQL-Tagging.html">tagging</a>.
</p>
</NEW>

END

<!-- vi:set ts=2 sw=2 et filetype=html fileencoding=latin1: -->
