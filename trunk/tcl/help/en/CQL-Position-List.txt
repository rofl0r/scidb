<!-- **********************************************************************
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
*********************************************************************** -->

<!-- **********************************************************************
* Copyright: (C) 2013 Gregor Cramer
*********************************************************************** -->

<!-- **********************************************************************
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*********************************************************************** -->

INDEX Position List (CQL)
INDEX CQL Position List

DEFINE <extension/> &ensp;<img src="../images/ft-scidb-tiny.png" />

TITLE CQL - The position list

<p>
The symbol <img src="../images/ft-scidb-tiny.png" /> in the title denotes that
this keyword is an extension, it is not part of the CQL standard.
</p>

<p>
The keywords <cql>position:castling</cql>, <cql>position:endgame</cql>,
<cql>position:inside</cql>, and <cql>position:reset</cql> are borrowed from
Chess Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>).
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#index">Index</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#logical">Logical keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#control">Controlling keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#simple">Simple keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#transform">Transformation keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#piece">Piece configuration keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#move">Move keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#sequence">Logical keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#game">Game related keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#relation">Relation between positions</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#matching">Matching count keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#evaluation">Analyzing keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#accumulator">Accumulator keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#tagging">Tagging keywords</a></td></tr>
  </table>
</dir>

<h2 id="index">Index</h2>

<dir>
  <table>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:inside">:inside</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:and">:and</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:promote">:promote</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rating">:rating</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:markall">:markall</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:ray">:ray</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:relation">:relation</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:cut">:cut</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:moveto">:moveto</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:reset">:reset</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:result">:result</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sequence">:sequence</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shift">:shift</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exclude">:exclude</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nolosing">:nolosing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flip">:flip</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:not">:not</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:or">:or</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piececount">:piececount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:power">:power</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:preceding">:preceding</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
  </table>
</dir>

<h2 id="logical">Logical keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:and">:and</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:not">:not</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:or">:or</a></td></tr>
  </table>
</dir>

<h3 id="position:and">:and</h3>

<p>
Takes a list of position lists and matches a position only if each of them
match the position.
</p>

<p>
Example:
</p>

<verbatim>
(position 
  <cql>position:wtm</cql>
  <cql>position:check</cql>
  <keyword>:and</keyword> (
    (position &K;e2 &k;g2 <cql>position:shift</cql> <cql>position:flip</cql>)
    (position &N;e2)))
</verbatim>

<p>
Matches positions in which the kings are in opposition, there is a white knight
on e2, and white is in check.
</p>

<h3 id="position:not">:not</h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
match if the containing match list would not match without the :not. In
latter case negate the result of the sub-position list match. The former
case is conform with CQL standard of keyword <cql>position:not</cql>,
the second form is an extension.
</p>

<p>
Examples:
</p>

<verbatim>
(match
  (position
    ; <comment>we are searching for both colors</comment>
    <cql>position:flipcolor</cql>
    <comment>; the mating position must match each criterion below</comment>
    <cql>position:and</cql> (
      <comment>; the black king is surrounded by empty squares and</comment>
      <comment>; is attacked once and is in mate</comment>
      (position
        <cql>position:attackcount</cql> &k; . 8
        <cql>position:attackcount</cql> A &k; 1
        <cql>position:mate</cql>
        <cql>position:btm</cql>)
      <comment>; check that no neighbor of the black king is</comment>
      <comment>; attacked more than once</comment>
      (position
        <keyword>:not</keyword>
        <cql>position:attackcount</cql> &k; .e4 1
        <cql>position:attackcount</cql> A .e4 2 100
        <cql>position:shift</cql>))))
</verbatim>

<p>
This finds all mating positions in which the king is surrounded by empty squares.
</p>

<p>
The follwing position match
</p>

<verb>
(position &R;a3 <keyword>:not</keyword>)
</verb>

<p>
is equivalent to
</p>

<verb>
(position [a&Q;&B;&N;&P;&K;.]a3)
</verb>

<h3 id="position:or">:or</h3>

<p>
Takes a list of position lists and matches a position only if at least one of them matches the position.
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position
    <keyword>:or</keyword> (
      (position <cql>position:piececount</cql>
        &B;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9)
      (position <cql>position:piececount</cql>
        &B;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9))))
</verbatim>

<p>
Searching for games with that have either two light-squared white
bishops, two dark-squared white bishops, two dark-square black
bishops. or two light-square black bishops.
</p>

<h2 id="control">Controlling keywords</h2>

<p>
With the help of the controlling keywords <cql>position:cut</cql> or
<cql>position:exclude</cql> unwanted positions or even games can be
excluded. Keyword <cql>position:preceding</cql> gives the predecessing
position of a match.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:cut">:cut</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exclude">:exclude</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:preceding">:preceding</a></td></tr>
  </table>
</dir>

<h3 id="position:cut">:cut<extension/></h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
stop position search as soon as the match of containing position list succeeeds.
In latter case stop position search as soon as the match of the sub-position
list succeeeds. This keyword is never failing, with other words: it is not
influencing the result of all other position lists (see example).
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position &lt;query&gt;)
  (position <keyword>:cut</keyword> <cql>position:check</cql>))
</verbatim>

<p>
We are not interested in consequent positions as soon as one side has
given a check. This means: as soon as a check is given stop the search, but
don't exclude current position if &lt;query&gt; is matching.
<expr>&lt;query&gt;</expr> has higher precedence than the :cut expression.
</p>

<p>
If even the :cut position should be excluded, use keyword
<cql>position:preceding</cql>:
</p>

<verbatim>
(match
  (position &lt;query&gt;)
  (position <keyword>:cut</keyword> <cql>:preceding</cql> <cql>position:check</cql>))
</verbatim>

<h3 id="position:exclude">:exclude<extension/></h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
exclude this game if the match of containing position list succeeeds.
In latter case exclude this game if the match of the sub-position list
succeeeds. This keyword is not influencing the result of the position
match (see example).
</p>

<p>
This keyword will exclude games even if one of the position matches
has succeeded.
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position ...)
  (position <keyword>:exclude</keyword> <cql>position:check</cql> <cql>position:not</cql>))
</verbatim>

<p>
Exclude this game if neither side is given a check in whole game, independent
from the result of <expr>(position ...)</expr>. But the query succeeds if
<expr>(position ...)</expr> succeeds, and if the :exclude expression is never
matching (this means: if either side is giving a check in this game).
</p>

<h3 id="position:preceding">:preceding<extension/></h3>

<p>
This keyword gives the preceding position of a match, if any. If the start
position is matching, the match of this position will be ignored, and the
search is continuing. The keyword :preceding can be used only on top level.
</p>

<p>
If this keyword is used combined with <cql>position:cut</cql>, the result
of the first position where the :cut condition succeeds will be ignored
(see example of keyword <cql>position:cut</cql>).
</p>

<p>
Examples:
</p>

<verb>
position <cql>position:check</cql> <keyword>:preceding</keyword>
</verb>

<p>
The result of this match is the predecessor of first position where one
side has given a check. Of course this can be expressed without this keyword:
</p>

<verb>
position <cql>position:sequence</cql>
((position <cql>position:nocheck</cql>) (position <cql>position:check</cql>))
</verb>

<p>
But the usage of :preceding is easier and the search is faster.
</p>

<h2 id="simple">Simple keywords</h2>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:markall">:markall</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
  </table>
</dir>

<h3 id="position:blackcannotwin">:blackcannotwin<extension/></h3>

<p>
Match only if black cannot win in this position.
</p>

<p>
Normally this is equivalent to following query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; black king only</comment>
  (<cql>position:piececount</cql> a 1)
  <comment>; black king and black minor piece only</comment>
  (<cql>position:piececount</cql> a 2 <cql>position:piececount</cql> i 1))
</verbatim>

<p>
In chess variant %::mc::VariantName(ThreeCheck)% this query succeeds only if
black has no more pieces than the king, and in all other chess variants this
query has no meaning and is always failing.
</p>

<p>
See also: <cql>position:whitecannotwin</cql>
</p>

<h3 id="position:btm">:btm</h3>

<p>
Match only if black is to move.
</p>

<p>
See also: <cql>position:wtm</cql>.
</p>

<h3 id="position:check">:check</h3>

<p>
One side is in check.
</p>

<p>
See also: <cql>position:nocheck</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:checkcount">:checkcount<extension/></h3>

<p>
If the parameter is a single number (between 0 and 3 is allowed), it is
matching all positions where last move is giving n-th check to other side.
</p>

<p>
If the parameter has the form <expr>+&lt;n&#x2081;&gt;+&lt;n&#x2082;&gt;</expr>,
where <expr>&lt;n&#x2093;&gt;</expr> is a number between 0 and 3,
it is matching all positions where white has given n&#x2081;-th check
to black, and black has given n&#x2082;-th check to white.
</p>

<note>
This query is working only in chess variant %::mc::VariantName(ThreeCheck)%,
in other chess variants it fails always.
</note>

<p>
Examples:
</p>

<verb>
(position <keyword>:checkcount</keyword> 2)
</verb>

<p>
Match if any side has given second check.
</p>

<verb>
(position <keyword>:checkcount</keyword> +0+3)
</verb>

<p>
Match if black has given third check to white. This must be a final position.
</p>

<verb>
(position <cql>position:not</cql> <keyword>:checkcount</keyword> +0+0)
</verb>

<p>
This is in fact a useful match. Assume that a game is starting with the
following position (described with <a href="FEN.html">FEN</a>):
</p>

<dir><code>
rnb1k1nr/pppp1ppp/8/4p3/3PP2q/2N5/PP3PPP/R1BQKBNR w KQkq - 1 5 +0+2
</code></dir>

<p>
This game would match (note keyword :not), because black has already
given second check to white in first position of the game. With other
words, this example is searching for games starting with an advanced
position, where one side has already given a check.
</p>

<h3 id="position:castling">:castling<extension/></h3>

<p>
This keyword specifies castling availabilities for both sides. It takes as an
argument a piecetype designator, letters of which have the following meanings:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">White has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&Q;</expr></td>
      <td class="r">White has queenside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Black has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&q;</expr></td>
      <td class="r">Black has queenside castling availability</td>
    </tr>
  </table>
</dir>

<p>
Examples:
</p>

<verb>
(position <keyword>:castling</keyword> &K;)
</verb>

<p>
White has kingside castling availability.
</p>

<verb>
(position <keyword>:castling</keyword> [&K;&Q;])
</verb>

<p>
White has either kingside or queenside castling availability.
</p>

<verb>
(position <keyword>:castling</keyword> &K; <keyword>:castling</keyword> &Q;)
</verb>

<p>
White has both kingside and queenside castling availabilities.
</p>

<h3 id="position:contactcheck">:contactcheck<extension/></h3>

<p>
One side is in check, and it is a contact check.
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:doublecheck">:doublecheck<extension/></h3>

<p>
One side is in check, and it is a double check.
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:endgame">:endgame<extension/></h3>

<p>
The position is an endgame position. The keyword is equivalent to the following
query:
</p>

<verbatim>
  (position
    <cql>position:or</cql> (
      (position
      <cql>position:piececount</cql> [&Q;&q;] 0
      <cql>position:piececount</cql> [&R;&B;&N;] 0 3
      <cql>position:piececount</cql> [&r;&b;&n;] 0 3)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &q; 1
      <cql>position:piececount</cql> [&R;&r;] 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> i 0 1)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &R; 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> &q; 0
      <cql>position:power</cql> [&r;&b;&n;] 0 16
      <cql>position:flipcolor</cql>)))
</verbatim>

<p>
See also: <cql>position:noendgame</cql>.
</p>

<h3 id="position:fen">:fen<extension/></h3>

<p>
The position is equal to the described position in given
<a href="FEN.html">FEN</a>.
</p>

<h3 id="position:fiftymoverule">:fiftymoverule<extension/></h3>

<p>
First position in game where no capture has been made and no pawn has been
moved in previous fifty consecutive moves.
</p>

<p>
See also: <cql>position:halfmoveclocklimit</cql>.
</p>

<h3 id="position:gameisover">:gameisover<extension/></h3>

<p>
This is an abbreviation for:
</p>

<verbatim>
  <cql>position:or</cql> (
    (position <cql>position:mate</cql>)
    (position <cql>position:stalemate</cql>)
    (position <cql>position:losing</cql>)
    (position <cql>position:checkcount 3</cql>)
    (position <cql>position:nomatingmaterial</cql>))
</verbatim>

<h3 id="position:initial">:initial</h3>

<p>
This is the first position in the game.
</p>

<h3 id="position:halfmoveclocklimit">:halfmoveclocklimit<extension/></h3>

<p>
This keyword is matching a position where the halfmove clock is equal
or less given limit.
</p>

<p>
Halfmove clock: This is the number of halfmoves since the last pawn
advance or capture. This is also used to determine if a draw can be
claimed under the fifty-move rule (<see/> <cql>position:fiftymoverule</cql>).
</p>

<p>
Example:
</p>

<verb>
<keyword>:halfmoveclocklimit</keyword> 30
</verb>

<p>
Exclude all positions where no capture has been made and no pawn has been
moved in previous thirty halfmoves (15 moves by each side).
</p>

<p>
See also: <cql>position:fiftymoverule</cql>.
</p>

<h3 id="position:losing">:losing<extension/></h3>

<p>
Matches the final position if one side has lost all pieces.
This is possible only in Antichess games.
</p>

<p>
See also: <cql>position:nolosing</cql>.
</p>

<h3 id="position:markall">:markall</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in Scidb.
</p>

<h3 id="position:mate">:mate</h3>

<p>
Match only if the position is a mate.
</p>

<annotation>
If searching for mate positions this keyword should always be used even if
this keyword might be superfluous because other conditions are ensuring a
mate position, it is accelerating the search (only testing final positions).
</annotation>

<p>
Example:
</p>

<verb>
(position <keyword>:mate</keyword> <cql>position:movenumber</cql> 1 20)
</verb>

<p>
Only matches if one side is mated in first 20 moves.
</p>

<p>
See also: <cql>position:nomate</cql>.
</p>

<h3 id="position:matingmaterial">:matingmaterial<extension/></h3>

<p>
Match a position if either player has mating material (<see/>
<cql>position:nomatingmaterial</cql>).
</p>

<p>
See also: <cql>position:nomatingmaterial</cql>.
</p>

<h3 id="position:noannotate">:noannotate</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in Scidb.
</p>

<h3 id="position:nocheck">:nocheck</h3>

<p>
Neither side is in check.
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:nocontactcheck">:nocontactcheck<extension/></h3>

<p>
Neither side is in check, or it is not a contact check.
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:contactcheck</cql>.
</p>

<h3 id="position:nodoublecheck">:nodoublecheck<extension/></h3>

<p>
Neither side is in check, or it is not a double check.
</p>

<h3 id="position:noendgame">:noendgame<extension/></h3>

<p>
The position is not an endgame position (<see/>
<cql>position:endgame</cql>).
</p>

<p>
See also: <cql>position:endgame</cql>.
</p>

<h3 id="position:nomate">:nomate<extension/></h3>

<p>
Match only if the position is not mate.
</p>

<p>
See also: <cql>position:mate</cql>.
</p>

<h3 id="position:nomatingmaterial">:nomatingmaterial<extension/></h3>

<p>
Match a position if neither player has mating material.
</p>

<p>
Normally this is equivalent to this query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; king versus king</comment>
  (<cql>position:piececount</cql> U 2)
  <comment>; king and minor piece versus king</comment>
  (<cql>position:piececount</cql> U 3 <cql>position:piececount</cql> [Ii] 1)
  <comment>; king and bishop versus king and bishop with the bishops on the same color</comment>
  (<cql>position:piececount</cql> U 4 <cql>position:piececount</cql> [&B;&b;][a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,
                      d6,d8,e1,e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2)
  (<cql>position:piececount</cql> U 4 <cql>position:piececount</cql> [&B;&b;][a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,
                      d5,d7,e2,e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2))
</verbatim>

<p>
In variant %::mc::VariantName(ThreeCheck)% this query only succeeds if only
kings are on board, and in all other chess variants this keyword has no
meaning and is always failing.
</p>

<p>
See also: <cql>position:matingmaterial</cql>.
</p>

<h3 id="position:nostalemate">:nostalemate<extension/></h3>

<p>
Match only if the position is not a stalemate.
</p>

<p>
See also: <cql>position:stalemate</cql>,
</p>

<h3 id="position:repetition">:repetition<extension/></h3>

<p>
Matches positions which occurred the third time in this game, with same
player to move, and each player has the same castling and en passant
capturing rights. The repeated positions need not occur in succession. This
accords with the <a href="http://en.wikipedia.org/wiki/Threefold_repetition">
threefold repetition rule</a>.
</p>

<h3 id="position:stalemate">:stalemate</h3>

<p>
Match only if the position is a stalemate.
</p>

<p>
See also: <cql>position:nostalemate</cql>,
</p>

<h3 id="position:terminal">:terminal<extension/></h3>

<p>
This is the last position in the game.
</p>

<h3 id="position:variations">:variations</h3>

<p>
Look in the variations to find matches.
</p>

<h3 id="position:variationsonly">:variationsonly</h3>

<p>
Look only in the variations to find matches, not in the main line.
</p>

<h3 id="position:whitecannotwin">:whitecannotwin<extension/></h3>

<p>
Match only if white cannot win in this position.
</p>

<p>
Normally this is equivalent to following query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; white king only</comment>
  (<cql>position:piececount</cql> A 1)
  <comment>; white king and white minor piece only</comment>
  (<cql>position:piececount</cql> A 2 <cql>position:piececount</cql> I 1))
</verbatim>

<p>
In chess variant %::mc::VariantName(ThreeCheck)% this query succeeds only if
white has no more pieces than the king, and in all other chess variants this
query has no meaning and is always failing.
</p>

<p>
See also: <cql>position:blackcannotwin</cql>
</p>

<h3 id="position:wtm">:wtm</h3>

<p>
Match only if white is to move.
</p>

<h2 id="transform">Transformation keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:flip">:flip</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:inside">:inside</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shift">:shift</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:flip">:flip</h3>

<p>
Same as <cql>position:flipdihedral</cql> (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipcolor">:flipcolor</h3>

<p>
The color flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipdiagonal">:flipdiagonal</h3>

<p>
The diagonal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipdihedral">:flipdihedral</h3>

<p>
All dihedral transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:fliphorizontal">:fliphorizontal</h3>

<p>
The horizontal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipvertical">:flipvertical</h3>

<p>
The vertical flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:inside">:inside<extension/></h3>

<p>
This keyword filters shift transformations in order to some matching pieces
will stay inside a specified region of the board. It takes two arguments, a
piece designator and a square designator. Any shift transformation affects
only the first argument. A shift transformation match :inside limitation if
at least one piece matching the first argument (taking into account the
transformation) is placed on a square matching the second argument.
</p>

<p>
Example:
</p>

<p>
We use the following query to find tripled pawns:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
To find one of tripled pawns placed on the main diagonal we design the query
</p>

<verbatim>
(position
  <keyword>:inside</keyword> &P;[b2-7] [b2,c3,d4,e5,f6,g7]
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<h3 id="position:shift">:shift</h3>

<p>
The shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftdiagonal">:shiftdiagonal</h3>

<p>
The off-diagonal and main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shifthorizontal">:shifthorizontal</h3>

<p>
The horizontal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftmaindiagonal">:shiftmaindiagonal</h3>

<p>
The main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftoffdiagonal">:shiftoffdiagonal</h3>

<p>
The off-diagonal shift transformations. (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftvertical">:shiftvertical</h3>

<p>
The vertical shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h2 id="piece">Piece configuration keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piececount">:piececount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:power">:power</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:ray">:ray</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:attackcount">:attackcount</h3>

<p>
This keyword takes as arguments two piece designators followed by a range
specifier. The first piece designator is the attacker piece designator.
The second piece designator is the attacked piece designator. An attack by
a piece to a square occurs if the piece could move to that square were it
empty and disregarding any possible checks. A valid attack is an attack by
a piece on a square that matches the attacker piece designator to a square
on which is a piece that matches the attacking piece designator.
</p>

<p>
The :attackcount keyword matches a position if the total number
of valid attacks in the position lies with the range given by its range
specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2)
</verb>

<p>
Matches any position in which white has a double attack on the black king.
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2 <cql>position:flipcolor</cql>)
</verb>

<p>
Matches any position in which a king is under double attack.
</p>

<verb>
(position <keyword>:attackcount</keyword> A .h3 1)
</verb>

<p>
Matches a position in which exactly one white piece attacks an empty h3 square.
</p>

<verb>
(position <keyword>:attackcount</keyword> [&R;&B;][a-c8] ??1 5 9
</verb>

<p>
Matches a position in which the number of times a white rook or white bishop
on a8, b8, or c8 attacks a square on the first rank is between 5 and 9
inclusive.
</p>

<verb>
(position <keyword>:attackcount</keyword> &n; [&K;&R;&Q;] 3 100) 
</verb>

<p>
Matches position for which the number of times a black knight attacks a white
King or white major piece is at least 3.
</p>

<h3 id="position:piececount">:piececount</h3>

<p>
This keyword takes a piece designator argument followed by a range specifier.
It matches the position if and only if the number of occurrences of the piece
designator in the position is given by the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:piececount</keyword> &R; 2)
</verb>

<p>
This will match any position with exactly two white rooks - a position with
three white rooks would fail to match.
</p>

<verbatim>
(position 
  <keyword>:piececount</keyword> [&R;&r;][a1-8] 1 3 
  <keyword>:piececount</keyword> [&Q;&q;][a-h8] 4 
  &N;d4)
</verbatim>

<p>
This will match any position with a white knight on d4, between one and three
rooks on the a file, and exactly four queens on the eight rank. Another way
to write this position list is:
</p>

<verbatim>
(position 
  &N;d4
  <keyword>:piececount</keyword> [&R;&r;][a?] 1 3 
  <keyword>:piececount</keyword> [&Q;&q;][?8] 4)
</verbatim>

<h3 id="position:power">:power</h3>

<p>
This keyword takes as argument a piece designator followed by a range
specifier. It matches positions for which the total power of all pieces
in the position matching the piece designator lies within the range specifier.
The power of a piece is their chess material power, depending on the chess
variant:
</p>

<dir>
  <table cellpadding="3">
    <tr>
      <td align="right"></td>
      <td align="right">&King;</td>
      <td align="right">&Queen;</td>
      <td align="right">&Rook;</td>
      <td align="right">&Bishop;</td>
      <td align="right">&Knight;</td>
      <td align="right">&Pawn;</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Normal)%, %::mc::VariantName(ThreeCheck)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Crazyhouse)%, %::mc::VariantName(Bughouse)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Losers)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 4</td>
      <td align="right"> 3</td>
      <td align="right"> 4</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Suicide)%, %::mc::VariantName(Giveaway)%&emsp;</td>
      <td align="right">30</td>
      <td align="right"> 3</td>
      <td align="right"> 9</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 1</td>
    </tr>
  </table>
</dir>

<p>
Examples:
</p>

<verb>
(position <keyword>:power</keyword> a 6)
</verb>

<p>
This will match positions in which the total power of the black pieces on the
board equals 6.
</p>

<verb>
(position <keyword>:power</keyword> A[a-h1-4] 10 25)
</verb>

<p>
This will match positions in which the total power of the white pieces on the
white half of the board is between 10 and 25 inclusive.
</p>

<h3 id="position:powerdifference">:powerdifference</h3>

<p>
This keyword takes as argument a piece designator followed by a range
specifier. It matches positions in which the difference in power (<see/>
<cql>position:power</cql>) between the white and black pieces matching the
piece designator (that is, the numeric value of the power of the matching
black pieces subtracted from the power of the matching white pieces) lies
within the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:powerdifference</keyword> U 4)
</verb>

<p>
This matches positions in which the white pieces have power precisely 4
greater than the black pieces.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;] -5 10)
</verb>

<p>
This matches positions in which white has between one fewer and two more
rooks than black.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;&B;&b;&N;&n;] unlimited -2)
</verb>

<p>
This matches positions in which black is up at least an exchange.
</p>

<verbatim>
(match
  (position
    <cql>match:result</cql> 1-0
    <cql>position:sequence</cql> (
      (position
        <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9
        <keyword>:powerdifference</keyword> U unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9))
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
This example shows how to search for queen sacrifices using
<code>:powerdifference</code>. One side sacrifices a queen, and remains at
least 9 points down in material for at least 12 moves, and then wins.
</p>

<h3 id="position:ray">:ray</h3>

<p>
A ray specifier is a list of piece designators. A ray is a contiguous set of
squares on a straight line on the chessboard parallel to an axis, the a1-h1
diagonal, or the a8-h8 diagonal.
</p>

<p>
Let R by a ray with ordered set of squares in a contiguous line
S&#x2081;, S&#x2082;,...,S&#x2090;. Suppose spec is a ray specifier
(G&#x2081;, G&#x2082;,...,G&#x2093;) where each G&#x2081;,...,G&#x2093;
is a piece designator. The ray R is valid with respect to the ray specifier
if G&#x2081; matches the piece on S&#x2081;, and if G&#x2093; matches the
piece on S&#x2090;, and if the remaining G's can be paired to some subset
of the squares in the ray in an order-preserving way such that each G matches
the piece on its corresponding square and such that all unpaired squares in
the ray are empty.
</p>

<p>
The :ray keyword takes a ray specifier and an optional range
specifier. If the range specifier is absent, it is taken to be
<expr>1 unlimited</expr>.  Otherwise, :ray matches a position if the number
of rays in the position valid with respect to the ray specifier lies within
the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:ray</keyword> (&k; &Q;)) 
</verb>

<p>
Matches a position in which a white queen attacks the black king.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &n; &k;[?4-8]))
</verb>

<p>
Matches a position in which a white queen on the a file pins a black knight
to the black king on the last four ranks.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &Q;c? &Q;e? &k;g?))
</verb>

<p>
Matches a position in which either three queens and the black king are on the
same rank, with exactly one empty square between them, and one of the queens
is on the a-file, or a position in which the three queens and king form a
diagonal with one empty squares between successive pieces and the queens on
the a, c, and e files.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q; &n; &k;) 2 4)
</verb>

<p>
Between two and for black knights are pinned to the black king.
</p>

<p>
See also: <cql>position:rayattack</cql>.
</p>

<h3 id="position:rayattack">:rayattack</h3>

<p>
Has the same syntax as <cql>position:ray</cql>. It has the semantics of
<cql>position:ray</cql>, except that only orthogonal rays that start on
a square containing a rook or queen are included, and only diagonal rays
starting on a square containing a bishop or queen are included.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:rayattack</keyword> (A a &k;))
</verb>

<p>
Matches a position in which a black piece is pinned to the black king.
</p>

<verb>
(position <keyword>:rayattack</keyword> (Ad5 a [&r;&k;][a-h1-4]) 3)
</verb>

<p>
Matches positions in which there are three black pinned by a white piece on
d5 against either a black rook or king in the first four ranks.
</p>

<verb>
(position <cql>position:stalemate</cql> <keyword>:rayattack</keyword>
(A a &k;) 2 8 <cql>position:flipcolor</cql>)
</verb>

<p>
Finds multiple-pin stalemates.
</p>

<p>
See also: <cql>position:ray</cql>.
</p>

<h3 id="position:raydiagonal">:raydiagonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being diagonal. A diagonal ray is a ray that is not vertical
or horizontal.
</p>

<h3 id="position:rayhorizontal">:rayhorizontal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being horizontal. A horizontal ray is a ray that is horizontal.
</p>

<h3 id="position:rayorthogonal">:rayorthogonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being orthogonal. A orthogonal ray is a ray that is not
diagonal.
</p>

<h3 id="position:rayvertical">:rayvertical</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being vertical. A vertical ray is a ray that is vertical.
</p>

<h2 id="move">Move keywords</h2>

<p>
In a position, the next move is the move about to be played, if any. A move has
three charactistics: its from designator, its to designator and its promotion
designator. These refer respectively to the piece and square from which the
piece moves; to the piece and square to which it is going to move (but before
it actually moves there), and to the piece and square to which it promotes,
if any.
</p>

<p>
For example, the to designation of a white rook on a4 capturing a black knight
on d4 is <expr>&n;d4</expr>, and its from designation is <expr>&R;a4</expr>. The
to designation of a move to e4 that is not a capture is <expr>.e4</expr>. 
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveto">:moveto</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nopiecedrop">:nopiecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:promote">:promote</a></td></tr>
  </table>
</dir>

<h3 id="position:enpassant">:enpassant</h3>

<p>
The next move is an en-passant capture.
</p>

<p>
See also: <cql>position:noenpassant</cql>
</p>

<h3 id="position:iscastling">:iscastling<extension/></h3>

<p>
The next move is a castling move.
</p>

<p>
See also: <cql>position:nocastling</cql>.
</p>

<h3 id="position:movefrom">:movefrom</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose from
designator matches that piece designator.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:movefrom</keyword> &R;a3)
</verb>

<p>
Matches a position in which the next move is of a white rook on a3.
</p>

<verb>
(position <keyword>:movefrom</keyword> U?8)
</verb>

<p>
Matches a position in the next move is of some piece on the 8th rank.
</p>

<h3 id="position:movenumber">:movenumber</h3>

<p>
:movenumber takes a range specifier as parameter and matches positions only
if the current move number is within the specified range. The move number
computation assumes white moves first, and might be one off otherwise.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:movenumber</keyword> 10 20 <cql>position:check</cql>)
</verb>

<p>
Matches a position in which there is a check between moves 10 and 20.
</p>

<verb>
(position <keyword>:movenumber</keyword> 35 <cql>position:mate</cql>)
</verb>

<p>
matches a position in which move 35 is mate.
</p>

<h3 id="position:moveto">:moveto</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose
to designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:moveto</keyword> U)
</verb>

<p>
Is matching a position where next move is a capture move.
</p>

<verb>
(position <keyword>:moveto</keyword> .)
</verb>

<p>
Is matching a position where next move is not a capture move.
</p>

<verb>
(position <keyword>:moveto</keyword> &R;[b1-8])
</verb>

<p>
Matches a position in which the next move is to capture a white rook on
the b file. Note that this is quite different from the natural
<a href="http://de.wikipedia.org/wiki/Portable_Game_Notation">PGN</a>
interpration of its being a move of a white rook to the b file. That
would be done via:
</p>

<verb>
(position <cql>position:movefrom</cql> &R; <keyword>:moveto</keyword> ?b?)
</verb>

<p>
Matches a move of the white rook to the b file.
</p>

<h3 id="position:nocastling">:nocastling<extension/></h3>

<p>
The next move is not a castling move.
</p>

<p>
See also: <cql>position:iscastling</cql>.
</p>

<h3 id="position:noenpassant">:noenpassant</h3>

<p>
The next move is not an en-passant capture.
</p>

<p>
See also: <cql>position:enpassant</cql>.
</p>

<h3 id="position:piecedrop">:piecedrop<extension/></h3>

<p>
The next move is a piece drop, if dropping a piece matching the
given piece designator (possible only in chess variants
%::mc::VariantName(Crazyhouse)%, and %::mc::VariantName(Bughouse)%).
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:piecedrop</keyword> [&N;&n;])
</verb>

<p>
The next move is a piece drop which is dropping a knight.
</p>

<verb>
(position <keyword>:piecedrop</keyword> [])
</verb>

<p>
The next move is not a piece drop (because the piece designator
is empty).
</p>

<h3 id="position:promote">:promote</h3>

<p>
Takes a single parameter, a piece designator. It matches a move if that move
is a promotion whose promotion designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:promote</keyword> [&R;&B;&N;])
</verb>

<p>
Matches a position whose next move is a white underpromotion.
</p>

<verb>
(position <keyword>:promote</keyword> [&B;&N;]a8)
</verb>

<p>
Matches a position whose next move is a white promotion to bishop or knight.
</p>

<verb>
(position <keyword>:promote</keyword> [&R;e8]
<cql>position:movefrom</cql> &P;f7 <cql>position:moveto</cql> &q;)
</verb>

<p>
Matches a position in which the next move is of a pawn on f7 capturing a black
queen on e8 and promoting to a rook.
</p>

<verb>
(position <keyword>:promote</keyword> [])
</verb>

<p>
Matches a position in which the next move is not a promotion (because the
piece designator is empty).
</p>

<h2 id="sequence">Sequence keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sequence">:sequence</a></td></tr>
  </table>
</dir>

<h3 id="position:gappedsequence">:gappedsequence</h3>

<p>
Takes one argument, a list of position lists. A position list A is said to be
a refinement of a position list B if A may be formed from B by inserting zero or
more position lists of the form (position) into the top level of B. For
example:
</p>

<verb>
((position &N;a4) (position) (position &R;b2))
</verb>

<p>
refines
</p>

<verb>
((position &N;a4) (position &R;b2))
</verb>

<p>
because it was formed by inserting a single position list into the latter list.
</p>

<p>
A :gappedsequence with argument B matches a position if and only if there is a
refinement A of B such that a <cql>position:sequence</cql> with argument A
would match that position. That is, :gappedsequence is like
<cql>position:sequence</cql> except that the sequence of matching positions
may include intervening positions from the game.
</p>

<p>
Examples:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
This will match any position for which the positions that occur successively
in the game starting with that position comprise zero or more positions,
followed by a position from which a white rook on a3 moves, followed by zero
or more positions, followed by a position from which a white rook on b4 moves.
In consequence the same effect can be obtained much more efficiently via:
</p>

<verbatim>
(position 
  <cql>position:initial</cql>
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
The following position list matches a position in which a knight is on d4 at
some point in the game after that position:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position)
    (position &N;d4))) 
</verbatim>

<p>
Note that the first element of the argument to :gappedsequence,
<expr>(position)</expr>, is used to ensure that only knights on d4 in
positions that occur after the position to be matched are considered.
</p>

<p>
This fragment is used here, to find all games in which some knight has
visited at least twenty different squares.
</p>

<p>
The total number of <cql>position:sequence</cql> and :gappedsequence position
lists that can occur at the top level of a position list cannot exceed one. To
get the effect of both a :gappedequence and <cql>position:sequence</cql>
keywords in one position list, use <cql>position:and</cql>.
</p>

<h3 id="position:sequence">:sequence</h3>

<p>
Takes a single argument that is a list of position lists. It matches a given
position if and only successive occurring positions, beginning with the
current position, match each corresponding element in its argument.
</p>

<p>
Example:
</p>

<verbatim>
(position
  &R;e8 
  <keyword>:sequence</keyword> (
    (position &Q;f3 .g2)
    (position .f3 &Q;g2)))
</verbatim>

This position list matches exactly those positions with a white rook on e8
such that:

<ol>
  <li>In that position, white has a queen on f3 and g2 is empty, and</li>
  <li>After the next move, f3 is empty and there is a white queen on g2.</li>
</ol>

<p>
In consequence, this position list is identical in effect to
</p>

<verb>
(position &R;e8 <cql>position:movefrom</cql> &Q;f3 <cql>position:moveto</cql> .g2)
</verb>

<p>
The following more typical usage of :sequence will search for all queen
staircase checking maneuvers by either side:
</p>

<verbatim>
(position 
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <keyword>:sequence</keyword> (
    (position <cql>position:movefrom</cql> &Q;a2) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;b2) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;b3) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;c3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c4)))
</verbatim>

<p>
This position list matches any position with a white queen on a2 for which
there are successively moves by queens on the indicated squares giving check;
the <cql>position:shift</cql>, <cql>position:flip</cql>, and
<cql>position:flipcolor</cql> search for this variation reflected or
rotated anywhere on the board.
</p>

<h2 id="game">Game related keywords</h2>

<p>
Several keywords relate to the game parameters and are not affected by the
contents of the position; they are included as position list keywords instead
of match list keywords so the <cql>position:flipcolor</cql> can be used with
them. these are:
</p>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:rating">:rating</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:result">:result</a></td>
    </tr>
  </table>
</dir>

<h3 id="position:blackelo">:blackelo</h3>

<p>
This parameter takes a range specifier; the ELO of the black player must lie
within its range (<see/> <a href="CQL-Range-Specifiers.html">range specifiers</a>).
</p>

<h3 id="position:blackrating">:blackrating<extension/></h3>

<p>
Match all games where the specified rating score of black player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h3 id="position:elo">:elo</h3>

<p>
This parameter expects a range specifer; the ELO of at least one of the
players must lie within the specified range (<see/>
<a href="CQL-Range-Specifiers.html">range specifiers</a>)
</p>

<h3 id="position:rating">:rating<extension/></h3>

<p>
Match all games where the specified rating score of one player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h3 id="position:result">:result</h3>

<p>
This keyword takes one argument, the same as the argument to
<cql>match:result (match)</cql> in a match list.
</p>

<p>
Example:
</p>

<verbatim>
(position 
  <keyword>:result</keyword> 1-0 
  <cql>position:whiteelo</cql> 0 2300
  <cql>position:blackelo</cql> 2600 3000
  <cql>position:flipcolor</cql>)
</verbatim>

<p>
Searches for positions in which a 2300 player or below defeated a 2600 player
or above.
</p>

<h3 id="position:whiteelo">:whiteelo</h3>

<p>
This parameter takes a range specifier; the ELO of the white player must lie
within its range (<see/> <a href="CQL-Range-Specifiers.html">range specifiers</a>).
</p>

<h3 id="position:whiterating">:whiterating<extension/></h3>

<p>
Match all games where the specified rating score of white player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h2 id="relation">Relation between positions</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:relation">:relation</a></td></tr>
  </table>
</dir>

<h3 id="position:relation">:relation</h3>

<p>
Takes one argument, a relation specification. is used to search for games with
pairs of positions P1 and P2 that satisfy certain properties. See
<a href="CQL-Relation-List.html">relation list</a> for a desription of
the relation specification keywords.
</p>

<h2 id="matching">Matching count keywords</h2>

<p>
Two keywords pertain to the number of positions which a position list matches.
These each take a range specifier as parameter. They can only be used in a
position list at the top level of a match list.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td></tr>
  </table>
</dir>

<h3 id="position:matchcount">:matchcount</h3>

<p>
Matches if and only if the number of times this position list matches a
position in the current game lies within the range specifier.
</p>

<p>
Example:
</p>

<verb>
(position <cql>position:moveto</cql> [&Q;&q;] <keyword>:matchcount</keyword> 4 100)
</verb>

<p>
Matches any game in which at least four queen captures have occurred.
</p>

<h3 id="position:pretransformmatchcount">:pretransformmatchcount</h3>

<p>
Has the same syntax as <cql>position:matchcount</cql>. It matches a position if
and only if there is some transform in the transformation set associated with
the position list in which it occurs such that, were the position list
replaced by a new position list formed from the first by deleting all
transformation keywords, applying the transform to that position list, and
changing this keyword to <cql>position:matchcount</cql>, then the position
list would match the position.
</p>

<p>
Example:
</p>

<verbatim>
(position
  <cql>position:movetoy</cql> [Aa]d4 
  <keyword>:pretransformmatchcount</keyword> 12 unlimited
  <cql>position:shift</cql>))
</verbatim>

<p>
This would match any game in which at least 12 captures occur on the same
square. Were the :pretransformmatchcount replaced by
<cql>position:matchcount</cql>, the position list would match games in which
at least 12 captures occurred.
</p>

<h2 id="evaluation">Analyzing keywords</h2>

<p>
The following keywords are analyzing positions. <cql>position:evaluation</cql> and
<cql>position:moveevaluation</cql> should be used with care, these are very slow
operations. In some cases the keywords <cql>position:exchangeevaluation</cql> and
<cql>position:maxswapevaluation</cql> might be an alternative, these functions are
quite faster, although quite time consuming.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td></tr>
  </table>
</dir>

<h3 id="position:evaluation">:evaluation<extension/></h3>

<p>
This keyword is evaluating the current position with the help of an
external chess engine (with UCI protocol). The number of parameters
depends on the search mode. There are three search modes:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>

    <!-- UCI:  "go mate <x>" -->
    <tr>
      <td class="l"><expr>mate &lt;n&gt;</expr></td>
      <td class="r">search for a mate in &lt;n&gt; moves</td>
    </tr>
  </table>
</dir>

<p>
The first two modes (depth and movetime) are taking three additional parameters.
The third parameter denotes the lower bound, the fourth parameter
denotes the upper bound, both scores are in centi-pawns. The query succeeds
if the estimation is within the specified bounds (inclusive the ranges). If
the lower-bound value is specified with <i>unlimited</i>, it means negative
unlimited. If the upper-bound value is specified with <i>unlimited</i>, it means
positive unlimited. The fifth parameter is either <i>sidetomove</i> or <i>absolute</i>.
<i>sidetomove</i> means that the evaluation value depends on side to move, and
<i>absolute</i> means that the evaluation value is independent from side to move.
</p>

<annotation>
This is a very slow operation and should be restricted; for example to
terminal positions.
</annotation>

<p>
Examples:
</p>

<verb>
<keyword>:evaluate</keyword> depth 4 2.5 unlimited sidetomove
</verb>

<p>
Side to move has (possibly) a winning position, because he is
at least 2.5 pawn units ahead.
</p>

<verb>
<keyword>:evaluate</keyword> depth 4 unlimited -2.5 sidetomove
</verb>

<p>
Side to move has (possibly) a losing position, because he is
at least 2.5 pawn units behind.
</p>

<verb>
<keyword>:evaluate</keyword> movetime 3000 unlimited -3.0 absolute
</verb>

<p>
Black is (possibly) losing, because he is at least 3 pawn units behind.
</p>

<verb>
<keyword>:evaluate</keyword> mate 3
</verb>

<p>
Either side is mate in maximal 3 moves.
</p>

<h3 id="position:exchangeevaluation">:exchangeevaluation<extension/></h3>

<p>
This keyword is analyzing capture moves to see whether or not they appear
to be profitable.
</p>

<p>
The keyword match the current move if this value is in the specified range
(a lower and an upper value). Only capture moves will be evaluated.
If lower range is specified with <i>unlimited</i>, it means negative unlimited.
If the lower range is specified with <i>unlimited</i>, it means positive unlimited.
The exchange function is taking into account that exchanged pieces may be
pinned or defended by other pieces. The value of the function does not depend
on which side is to move.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<p>
Examples:
</p>

<verb>
<keyword>:exchangeevaluation</keyword> unlimited 3
</verb>

<p>
This move is (possibly) a blunder.
</p>

<h3 id="position:maxswapevaluation">:maxswapevaluation<extension/></h3>

<p>
This keyword allows to estimate exchange values of possible moves. It takes
as arguments two piece designators followed by a range specifier. The first
argument specifies moving pieces, the second one specifies target squares.
For each possible moves we compute an integer value that is a material benefit
of the move (in pawns, like in case of the <cql>position:power</cql> keyword)
according to possible piece exchanges on the target square after the move.
After that the maximum of all computed values will be selected.
</p>

<p>
The keyword match the position if this value lies in the specified range
(a lower and an upper value). If lower range is specified with <i>unlimited</i>,
it means negative unlimited. If the lower range is specified with <i>unlimited</i>,
it means positive unlimited. The exchange function is taking into account that
exchanged pieces may be pinned or defended by other pieces. The value of the
function does not depend on which side is to move.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<note>
This keyword is alike the keyword <expr>:maxswapvalue</expr> from Chess
Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
but quite different implemented.
</note>

<p>
Examples:
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> A a 1 unlimited)
</verb>

<p>
This query selects positions in which white threatens with
winning some material:
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> &Q;?1-7 ??8 0 unlimited)
</verb>

<p>
This query selects positions in which a white queen can invade rank 8
without a material loss.
</p>

<h3 id="position:moveevaluation">:moveevaluation<extension/></h3>

<p>
This keyword is matching the difference between the evaluation of the current
position and the evaluation of the preceding position. The evaluation will be
done with the help of an external chess engine (with UCI protocol). It takes
seven parameters. The first and second parameter are piece designators. The
former is specifies moving pieces, the second one specifies target squares.
The third and fourth are depending on the search mode:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>
  </table>
</dir>

<p>
The fifth parameter denotes the lower bound score, the sixth parameter denotes
the upper bound score, both scores are in centi-pawns. If the lower-bound value
is specified with <i>unlimited</i>, it means negative unlimited. If the upper-bound
value is specified with <i>unlimited</i>, it means positive unlimited. The query
succeeds if the scoring of this move is within the given bounds (inclusive the
ranges). The score of this move is the difference between the score of the
current board and the score of the last board. In case of mating positions
the difference will be always greater than 10.000.
</p>

<p>
The seventh parameter is either <i>sidetomove</i> or <i>absolute</i>.
<i>sidetomove</i> means that the evaluation value depends on side to move, and
<i>absolute</i> means that the evaluation value is independent from side to move.
</p>

<annotation>
This is a very slow operation and should not be used with huge databases,
or the moving pieces and the target squares should be restricted.
</annotation>

<p>
Example:
</p>

<verb>
<keyword>:moveevaluation</keyword> U ? depth 4 3.0 unlimited sidetomove
</verb>

<p>
Match first position were the evaluation score is at least 3.0 pawn units.
This means that last move was (possibly) a blunder.
</p>

<verb>
<keyword>:moveevaluation</keyword> A a depth 4 unlimited -3.0 absolute
</verb>

<p>
Match first position were the evaluation score is at least 3.0 pawn units
better for black. This means that last white move was (possibly) a blunder.
Only capture moves will be evaluated.
</p>

<verbatim>
(match
  (position <keyword>:moveevaluation</keyword> [&P;&p;] ?[a-h1,a-h8]
             unlimited 0.0 movetime 5000 absolute)
  (position <cql>position:promotion</cql> U <cql>position:cut</cql>)))
</verbatim>

<p>
Search for positions where side to move is doing first promotion in game, but
without gaining a better score. We are ensuring that only promoting moves will
be evaluated.
</p>

<h2 id="accumulator">Accumulator keywords</h2>

<p>
There are mainly two accumulator keywords, :accumulate and :sumrange. These
are used to accumulate and to test the number of transforms of the enclosing
position list that match the current position. Each time a transform of a
position list matches a position, the accumulator associated with that position
is incremented. Any position with a sum range can then test if the accumulator
is within a certain range.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:reset">:reset</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td></tr>
  </table>
</dir>

<h3 id="position:accumulate">:accumulate</h3>

<p>
This takes one parameter, the name of an accumulator. Each time the application
of some element of the transform set of the position list matches a position,
the accumulator associated with this name is incremented. The accumulator is
cleared when a new position is reached (and in consequence :accumulate should
not be used inside of <cql>position:not</cql>, or the
<cql>position:sequence</cql>, and <cql>position:gappedsequence</cql> keywords).
This keyword inhibits short-circuiting of logical keywords
<cql>position:and</cql>, and <cql>position:or</cql>. Note that
<cql>position:flipcolor</cql> likely has unexpected results when used with
:accumulate, because the accumulator is not cleared between color flips.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h3 id="position:reset">:reset<extension/></h3>

<p>
This keyword takes as a parameter the name of an accumulator. It clears the
accumulator associated with this name after applying a transformation.
</p>

<p>
Example:
</p>

<p>
Tripled pawns can be found by the query:
</p>

<verbatim>
(position
  <keyword>:reset</keyword> acc
  &P;e2
  <cql>position:accumulate</cql> acc
  <cql>position:sumrange</cql> acc 3
  <cql>position:shiftvertical</cql>
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Note that this is only an example for this keyword (taken from
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
it is not recommended to use this statement for triple pawn search.
A much better way is:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;a[3-7] 3 6
  <cql>position:shifthorizontal</cql>
  <cql>position:flipcolor</cql>))
</verbatim>

<h3 id="position:sumrange">:sumrange<extension/></h3>

<p>
This takes as parameter the name of an accumulator and a range specifer.
It matches a position if the value of the given accumulator lies within
the range specifier.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h2 id="tagging">Tagging keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td></tr>
  </table>
</dir>

<h3 id="position:tagmatch">:tagmatch<extension/></h3>

<p>
The :tagmatch keyword takes two parameters, the name of a tag and a piece
designator. It matches only if the piece corresonding to the named tag
matches the given piece designator. For more information, see the section
on <a href="CQL-Tagging.html">tagging</a>.
</p>

END

<!-- vi:set ts=2 sw=2 et filetype=html: -->
