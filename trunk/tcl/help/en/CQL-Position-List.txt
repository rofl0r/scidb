<!-- **********************************************************************
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
*********************************************************************** -->

<!-- **********************************************************************
* Copyright: (C) 2013 Gregor Cramer
*********************************************************************** -->

<!-- **********************************************************************
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*********************************************************************** -->

INDEX Position List (CQL)
INDEX CQL Position List

DEFINE <nonstd/> <note>This keyword is not part of the CQL standard.</note>

DEFINE <ca9/>  <note>This keyword is borrowed from Chess Assistant 9 (<see/> <a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>).
</note>

TITLE CQL - The position list

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#index">Index</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#logical">Logical keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#simple">Simple keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#transform">Transformation keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#piece">Piece configuration keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#move">Move keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#sequence">Logical keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#game">Game related keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#relation">Relation between positions</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#matching">Matching count keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#accumulator">Accumulator keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#tagging">Tagging keywords</a></td></tr>
  </table>
</dir>

<h2 id="index">Index</h2>

<dir>
  <table>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:and">:and</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:markall">:markall</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:maxswapvalue">:maxswapvalue</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:ray">:ray</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:relation">:relation</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:moveto">:moveto</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:reset">:reset</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:result">:result</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sequence">:sequence</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shift">:shift</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:not">:not</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:or">:or</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piececount">:piececount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:power">:power</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flip">:flip</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:promote">:promote</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:inside">:inside</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rating">:rating</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td>
      <td></td><td></td>
    </tr>
  </table>
</dir>

<h2 id="logical">Logical keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:and">:and</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:not">:not</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:or">:or</a></td></tr>
  </table>
</dir>

<h3 id="position:and">:and</h3>

<p>
Takes a list of position lists and matches a position only if each of them
match the position.
</p>

<p>
Example:
</p>

<verbatim>
(position 
  <cql>position:wtm</cql>
  <cql>position:check</cql>
  <keyword>:and</keyword> (
    (position &K;e2 &k;g2 <cql>position:shift</cql> <cql>position:flip</cql>)
    (position &N;e2)))
</verbatim>

<p>
Matches positions in which the kings are in opposition, there is a white knight
on e2, and white is in check.
</p>

<h3 id="position:not">:not</h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
match if the containing match list would not match without the :not. In
latter case negate the result of the sub-position list match. The former
case is conform with CQL standard of keyword <cql>position:not</cql>,
the second form is an extension.
</p>

<p>
Examples:
</p>

<verbatim>
(match
  (position
    ; <comment>we are searching for both colors</comment>
    <cql>position:flipcolor</cql>
    <comment>; the mating position must match each criterion below</comment>
    <cql>position:and</cql> (
      <comment>; the black king is surrounded by empty squares and</comment>
      <comment>; is attacked once and is in mate</comment>
      (position
        <cql>position:attackcount</cql> &k; . 8
        <cql>position:attackcount</cql> A &k; 1
        <cql>position:mate</cql>
        <cql>position:btm</cql>)
      <comment>; check that no neighbor of the black king is</comment>
      <comment>; attacked more than once</comment>
      (position
        <keyword>:not</keyword>
        <cql>position:attackcount</cql> &k; .e4 1
        <cql>position:attackcount</cql> A .e4 2 100
        <cql>position:shift</cql>))))
</verbatim>

<p>
This finds all mating positions in which the king is surrounded by empty squares.
</p>

<p>
The follwing position match
</p>

<verb>
(position &R;a3 <keyword>:not</keyword>)
</verb>

<p>
is equivalent to
</p>

<verb>
(position [a&Q;&B;&N;&P;&K;.]a3)
</verb>

<h3 id="position:or">:or</h3>

<p>
Takes a list of position lists and matches a position only if at least one of them matches the position.
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position
    <keyword>:or</keyword> (
      (position <cql>position:piececount</cql>
        &B;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9 )
      (position <cql>position:piececount</cql>
        &b;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9)
      (position <cql>position:piececount</cql>
        &B;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9))))
</verbatim>

<p>
Searching for games with that have either two light-squared white
bishops, two dark-squared white bishops, two dark-square black
bishops. or two light-square black bishops.
</p>

<h2 id="simple">Simple keywords</h2>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:markall">:markall</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:mate">:mate</a></td>
    </tr>
  </table>
</dir>

<h3 id="position:btm">:btm</h3>

<p>
Match only if black is to move.
</p>

<p>
See also: <cql>position:wtm</cql>.
</p>

<h3 id="position:check">:check</h3>

<p>
One side is in check.
</p>

<p>
See also: <cql>position:nocheck</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:checkcount">:checkcount</h3>

<p>
If the parameter is a single number (between 0 and 3 is allowed), it is
matching all positions where last move is giving n-th check to other side.
</p>

<p>
If the parameter has the form <expr>+&lt;n&#x2081;&gt;+&lt;n&#x2082;&gt;</expr>,
where <expr>&lt;n&#x2093;&gt;</expr> is a number between 0 and 3,
it is matching all positions where white has given n&#x2081;-th check
to black, and black has given n&#x2082;-th check to white.
<p>

<note>
This search is working only in chess variant %::mc::VariantName(ThreeCheck)%,
it is ignored in other chess variants.
</note>

<nonstd/>

<p>
Examples:
</p>

<verb>
(position <keyword>:checkcount</keyword> 2)
</verb>

<p>
Match if any side has given second check.
</p>

<verb>
(position <keyword>:checkcount</keyword> +0+3)
</verb>

<p>
Match if black has given third check to white. This must be a final position.
</p>

<verb>
(position <cql>position:not</cql> <keyword>:checkcount</keyword> +0+0)
</verb>

<p>
This is in fact a useful match. Assume that a game is starting with the
following position (described with <a href="FEN.html">FEN</a>):
</p>

<dir><code>
rnb1k1nr/pppp1ppp/8/4p3/3PP2q/2N5/PP3PPP/R1BQKBNR w KQkq - 1 5 +0+2
</code></dir>

<p>
This game would match (note keyword :not), because black has already
given second check to white in first position of the game. With other
words, this example is searching for games starting with an advanced
position, where one side has already given a check.
</p>

<h3 id="position:castling">:castling</h3>

<p>
This keyword specifies castling availabilities for both sides. It takes as an
argument a piecetype designator, letters of which have the following meanings:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">White has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&Q;</expr></td>
      <td class="r">White has queenside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Black has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&q;</expr></td>
      <td class="r">Black has queenside castling availability</td>
    </tr>
  </table>
</dir>

<nonstd/>
<ca9/>

<p>
Examples:
</p>

<verb>
(position <keyword>:castling</keyword> &K;)
</verb>

<p>
White has kingside castling availability.
</p>

<verb>
(position <keyword>:castling</keyword> [&K;&Q;])
</verb>

<p>
White has either kingside or queenside castling availability.
</p>

<verb>
(position <keyword>:castling</keyword> &K; <keyword>:castling</keyword> &Q;)
</verb>

<p>
White has both kingside and queenside castling availabilities.
</p>

<h3 id="position:contactcheck">:contactcheck</h3>

<p>
One side is in check, and it is a contact check.
</p>

<nonstd/>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:doublecheck">:doublecheck</h3>

<p>
One side is in check, and it is a double check.
</p>

<nonstd/>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:endgame">:endgame</h3>

<p>
The position is an endgame position. The keyword is equivalent to the following
query:
</p>

<verbatim>
  (position
    <cql>position:or</cql> (
      (position
      <cql>position:piececount</cql> [&Q;&q;] 0
      <cql>position:piececount</cql> [&R;&B;&N;] 0 3
      <cql>position:piececount</cql> [&r;&b;&n;] 0 3)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &q; 1
      <cql>position:piececount</cql> [&R;&r;] 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> i 0 1)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &R; 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> &q; 0
      <cql>position:power</cql> [rbn] 0 16
      <cql>position:flipcolor</cql>)))
</verbatim>

<nonstd/>
<ca9/>

<p>
See also: <cql>position:noendgame</cql>.
</p>

<h3 id="position:fen">:fen</h3>

<p>
The position is equal to the described position in given
<a href="FEN.html">FEN</a>.
</p>

<nonstd/>

<h3 id="position:fiftymoverule">:fiftymoverule</h3>

<p>
First position in game where no capture has been made and no pawn has been
moved in previous fifty consecutive moves.
</p>

<nonstd/>

<h3 id="position:initial">:initial</h3>

<p>
This is the first position in the game.
</p>

<h3 id="position:losing">:losing</h3>

<p>
Matches the final position if one side has lost all pieces.
This is possible only in Antichess games.
</p>

<nonstd/>

<h3 id="position:markall">:markall</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in Scidb.
</p>

<h3 id="position:mate">:mate</h3>

<p>
Match only if the position is a mate.
</p>

<p>
Example:
</p>

<verb>
(position <keyword>:mate</keyword> <cql>position:movenumber</cql> 1 20)
</verb>

<p>
Only matches if one side is mated in first 20 moves.
</p>

<h3 id="position:noannotate">:noannotate</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in Scidb.
</p>

<h3 id="position:nocheck">:nocheck</h3>

<p>
Neither side is in check.
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:nocontactcheck">:nocontactcheck</h3>

<p>
Neither side is in check, or it is not a contact check.
</p>

<nonstd/>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:contactcheck</cql>.
</p>

<h3 id="position:nodoublecheck">:nodoublecheck</h3>

<p>
Neither side is in check, or it is not a double check.
</p>

<nonstd/>

<h3 id="position:noendgame">:noendgame</h3>

<p>
The position is not an endgame position (<see/>
<cql>position:noendgame</cql>).
</p>

<nonstd/>

<h3 id="position:nostalemate">:nostalemate</h3>

<p>
Match only if the position is not a stalemate.
</p>

<nonstd/>

<p>
See also: <cql>position:stalemate</cql>,
</p>

<h3 id="position:repetition">:repetition</h3>

<p>
Matches positions which occurred the third time in this game.
The repeated positions need not occur in succession. This accords
with the <a href="http://en.wikipedia.org/wiki/Threefold_repetition">
threefold repetition rule</a>.
</p>

<nonstd/>

<h3 id="position:stalemate">:stalemate</h3>

<p>
Match only if the position is a stalemate.
</p>

<p>
See also: <cql>position:nostalemate</cql>,
</p>

<h3 id="position:terminal">:terminal</h3>

<p>
This is the last position in the game.
</p>

<nonstd/>

<h3 id="position:variations">:variations</h3>

<p>
Look in the variations to find matches.
</p>

<h3 id="position:variationsonly">:variationsonly</h3>

<p>
Look only in the variations to find matches, not in the main line.
</p>

<h3 id="position:wtm">:wtm</h3>

<p>
Match only if white is to move.
</p>

<h2 id="transform">Transformation keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:flip">:flip</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:inside">:inside</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shift">:shift</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal*">:shifthorizontal*</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:flip">:flip</h3>

<p>
Same as <cql>position:flipdihedral</cql> (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipcolor">:flipcolor</h3>

<p>
The color flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipdiagonal">:flipdiagonal</h3>

<p>
The diagonal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipdihedral">:flipdihedral</h3>

<p>
All dihedral transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:fliphorizontal">:fliphorizontal</h3>

<p>
The horizontal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipvertical">:flipvertical</h3>

<p>
The vertical flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:inside">:inside</h3>

<p>
This keyword filters shift transformations in order to some matching pieces
will stay inside a specified region of the board. It takes two arguments, a
piece designator and a square designator. Any shift transformation affects
only the first argument. A shift transformation match :inside limitation if
at least one piece matching the first argument (taking into account the
transformation) is placed on a square matching the second argument.
</p>

<nonstd/>
<ca9/>

<p>
Example:
</p>

<p>
We use the following query to find tripled pawns:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
To find one of tripled pawns placed on the main diagonal we design the query
</p>

<verbatim>
(position
  <keyword>:inside</keyword> &P;[b2-7] [b2,c3,d4,e5,f6,g7]
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<h3 id="position:shift">:shift</h3>

<p>
The shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftdiagonal">:shiftdiagonal</h3>

<p>
The off-diagonal and main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shifthorizontal">:shifthorizontal</h3>

<p>
The horizontal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftmaindiagonal">:shiftmaindiagonal</h3>

<p>
The main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftoffdiagonal">:shiftoffdiagonal</h3>

<p>
The off-diagonal shift transformations. (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftvertical">:shiftvertical</h3>

<p>
The vertical shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h2 id="piece">Piece configuration keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:maxswapvalue">:maxswapvalue</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piececount">:piececount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:power">:power</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:ray">:ray</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:attackcount">:attackcount</h3>

<p>
This keyword takes as arguments two piece designators followed by a range
specifier. The first piece designator is the attacker piece designator.
The second piece designator is the attacked piece designator. An attack by
a piece to a square occurs if the piece could move to that square were it
empty and disregarding any possible checks. A valid attack is an attack by
a piece on a square that matches the attacker piece designator to a square
on which is a piece that matches the attacking piece designator.
</p>

<p>
The :attackcount keyword matches a position if the total number
of valid attacks in the position lies with the range given by its range
specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2)
</verb>

<p>
Matches any position in which white has a double attack on the black king.
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2 <cql>position:flipcolor</cql>)
</verb>

<p>
Matches any position in which a king is under double attack.
</p>

<verb>
(position <keyword>:attackcount</keyword> A .h3 1)
</verb>

<p>
Matches a position in which exactly one white piece attacks an empty h3 square.
</p>

<verb>
(position <keyword>:attackcount</keyword> [&R;&B;][a-c8] ??1 5 9
</verb>

<p>
Matches a position in which the number of times a white rook or white bishop
on a8, b8, or c8 attacks a square on the first rank is between 5 and 9
inclusive.
</p>

<verb>
(position <keyword>:attackcount</keyword> &n; [&K;&R;&Q;] 3 100) 
</verb>

<p>
Matches position for which the number of times a black knight attacks a white
King or white major piece is at least 3.
</p>

<h3 id="position:maxswapvalue">:maxswapvalue</h3>

<p>
This keyword allows to estimate exchange values of possible moves. It takes
as arguments two piece designators followed by a range specifier. The first
argument specifies moving pieces, the second one specifies target squares.
For each possible moves we compute an integer value that is a material benefit
of the move (in pawns, like in case of the <cql>position:power</cql> keyword)
according to possible piece exchanges on the target square after the move.
After that we
select the maximum of all computed values.
</p>

<p>
The keyword match the position if this value lies in the specified range. The
exchange function is taking into account that exchanged pieces may be pinned
or defended by other pieces. The value of the function depends on which side
is to move.
</p>

<nonstd/>

<note>This keyword is borrowed from Chess Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
but implemented in a different way, so it is not conform to the
implementation of Chess Assistant.
</note>

<p>
Examples:
</p>

<p>
The following query selects positions in which white threatens with
winning some material:
</p>

<verb>
(position <keyword>:maxswapvalue</keyword> A a 1 1000)
</verb>

<p>
The following query selects positions in which a white queen can invade rank 8
without a material loss.
</p>

<verb>
(position <keyword>:maxswapvalue</keyword> &Q;?1-7 ??8 0 1000)
</verb>

<h3 id="position:piececount">:piececount</h3>

<p>
This keyword takes a piece designator argument followed by a range specifier.
It matches the position if and only if the number of occurrences of the piece
designator in the position is given by the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:piececount</keyword> &R; 2)
</verb>

<p>
This will match any position with exactly two white rooks - a position with
three white rooks would fail to match.
</p>

<verbatim>
(position 
  <keyword>:piececount</keyword> [&R;&r;][a1-8] 1 3 
  <keyword>:piececount</keyword> [&Q;&q;][a-h8] 4 
  &N;d4)
</verbatim>

<p>
This will match any position with a white knight on d4, between one and three
rooks on the a file, and exactly four queens on the eight rank. Another way
to write this position list is:
</p>

<verbatim>
(position 
  &N;d4
  <keyword>:piececount</keyword> [&R;&r;][a?] 1 3 
  <keyword>:piececount</keyword> [&Q;&q;][?8] 4)
</verbatim>

<h3 id="position:power">:power</h3>

<p>
This keyword takes as argument a piece designator followed by a range
specifier. It matches positions for which the total power of all pieces
in the position matching the piece designator lies within the range specifier.
The power of a piece is their chess material power, depending on the chess
variant:
</p>

<dir>
  <table cellpadding="3px">
    <tr>
      <td align="right"></td>
      <td align="right">&King;</td>
      <td align="right">&Queen;</td>
      <td align="right">&Rook;</td>
      <td align="right">&Bishop;</td>
      <td align="right">&Knight;</td>
      <td align="right">&Pawn;</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Normal)%, %::mc::VariantName(ThreeCheck)%</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
      <td>%::mc::VariantName(Crazyhouse)%, %::mc::VariantName(Bughouse)%</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Losers)%</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 4</td>
      <td align="right"> 3</td>
      <td align="right"> 4</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Suicide)%, %::mc::VariantName(Giveaway)%</td>
      <td align="right">30</td>
      <td align="right"> 3</td>
      <td align="right"> 9</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 1</td>
    </tr>
  </table>
</dir>

<p>
Examples:
</p>

<verb>
(position <keyword>:power</keyword> a 6)
</verb>

<p>
This will match positions in which the total power of the black pieces on the
board equals 6.
</p>

<verb>
(position <keyword>:power</keyword> Aa-h1-4 10 25)
</verb>

<p>
This will match positions in which the total power of the white pieces on the
white half of the board is between 10 and 25 inclusive.
</p>

<h3 id="position:powerdifference">:powerdifference</h3>

<p>
This keyword takes as argument a piece designator followed by a range
specifier. It matches positions in which the difference in power (<see/>
<cql>position:power</cql>) between the white and black pieces matching the
piece designator (that is, the numeric value of the power of the matching
black pieces subtracted from the power of the matching white pieces) lies
within the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:powerdifference</keyword> U 4)
</verb>

<p>
This matches positions in which the white pieces have power precisely 4
greater than the black pieces.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;] -5 10)
</verb>

<p>
This matches positions in which white has between one fewer and two more
rooks than black.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;&B;&b;&N;&n;] -1000 -2)
</verb>

<p>
This matches positions in which black is up at least an exchange.
</p>

<verbatim>
(match
  (position
    <cql>match:result</cql> 1-0
    <cql>position:sequence</cql> (
      (position
        <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9
        <keyword>:powerdifference</keyword> U -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] -1000 -9))
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
This example shows how to search for queen sacrifices using
<code>:powerdifference</code>.
</p>

<h3 id="position:ray">:ray</h3>

<p>
A ray specifier is a list of piece designators. A ray is a contiguous set of
squares on a straight line on the chessboard parallel to an axis, the a1-h1
diagonal, or the a8-h8 diagonal.
</p>

<p>
Let R by a ray with ordered set of squares in a contiguous line
S&#x2081;, S&#x2082;,...,S&#x2090;. Suppose spec is a ray specifier
(G&#x2081;, G&#x2082;,...,G&#x2093;) where each G&#x2081;,...,G&#x2093;
is a piece designator. The ray R is valid with respect to the ray specifier
if G&#x2081; matches the piece on S&#x2081;, and if G&#x2093; matches the
piece on S&#x2090;, and if the remaining G's can be paired to some subset
of the squares in the ray in an order-preserving way such that each G matches
the piece on its corresponding square and such that all unpaired squares in
the ray are empty.
</p>

<p>
The :ray keyword takes a ray specifier and an optional range
specifier. If the range specifier is absent, it is taken to be 1 1000.
Otherwise, :ray matches a position if the number of rays in the
position valid with respect to the ray specifier lies within the range
specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:ray</keyword> (&k; &Q;)) 
</verb>

<p>
Matches a position in which a white queen attacks the black king.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &n; &k;[?4-8]))
</verb>

<p>
Matches a position in which a white queen on the a file pins a black knight
to the black king on the last four ranks.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &Q;c? &Q;e? &k;g?))
</verb>

<p>
Matches a position in which either three queens and the black king are on the
same rank, with exactly one empty square between them, and one of the queens
is on the a-file, or a position in which the three queens and king form a
diagonal with one empty squares between successive pieces and the queens on
the a, c, and e files.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q; &n; &k;) 2 4)
</verb>

<p>
Between two and for black knights are pinned to the black king.
</p>

<p>
See also: <cql>position:rayattack</cql>.
</p>

<h3 id="position:rayattack">:rayattack</h3>

<p>
Has the same syntax as <cql>position:ray</cql>. It has the semantics of
<cql>position:ray</cql>, except that only orthogonal rays that start on
a square containing a rook or queen are included, and only diagonal rays
starting on a square containing a bishop or queen are included.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:rayattack</keyword> (A a &k;))
</verb>

<p>
Matches a position in which a black piece is pinned to the black king.
</p>

<verb>
(position <keyword>:rayattack</keyword> (Ad5 a [&r;&k;][a-h1-4]) 3)
</verb>

<p>
Matches positions in which there are three black pinned by a white piece on
d5 against either a black rook or king in the first four ranks.
</p>

<verb>
(position <cql>position:stalemate</cql> <keyword>:rayattack</keyword>
(A a &k;) 2 8 <cql>position:flipcolor</cql>)
</verb>

<p>
Finds multiple-pin stalemates.
</p>

<p>
See also: <cql>position:ray</cql>.
</p>

<h3 id="position:raydiagonal">:raydiagonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being diagonal. A diagonal ray is a ray that is not vertical
or horizontal.
</p>

<h3 id="position:rayhorizontal">:rayhorizontal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being horizontal. A horizontal ray is a ray that is horizontal.
</p>

<h3 id="position:rayorthogonal">:rayorthogonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being orthogonal. A orthogonal ray is a ray that is not
diagonal.
</p>

<h3 id="position:rayvertical">:rayvertical</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being vertical. A vertical ray is a ray that is vertical.
</p>

<h2 id="move">Move keywords</h2>

<p>
In a position, the next move is the move about to be played, if any. A move has
three charactistics: its from designator, its to designator and its promotion
designator. These refer respectively to the piece and square from which the
piece moves; to the piece and square to which it is going to move (but before
it actually moves there), and to the piece and square to which it promotes,
if any.
</p>

<p>
For example, the to designation of a white rook on a4 capturing a black knight
on d4 is &n;d4, and its from designation is &R;a4. The to designation of a move to
e4 that is not a capture is .e4. 
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveto">:moveto</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nopiecedrop">:nopiecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:promote">:promote</a></td></tr>
  </table>
</dir>

<h3 id="position:enpassant">:enpassant</h3>

<p>
The next move is an en-passant capture.
</p>

<p>
See also: <cql>position:noenpassant</cql>
</p>

<h3 id="position:iscastling">:iscastling</h3>

<p>
The next move is a castling move.
</p>

<nonstd/>

<p>
See also: <cql>position:nocastling</cql>.
</p>

<h3 id="position:movefrom">:movefrom</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose from
designator matches that piece designator.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:movefrom</keyword> &R;a3)
</verb>

<p>
Matches a position in which the next move is of a white rook on a3.
</p>

<verb>
(position <keyword>:movefrom</keyword> U?8)
</verb>

<p>
Matches a position in the next move is of some piece on the 8th rank.
</p>

<h3 id="position:movenumber">:movenumber</h3>

<p>
:movenumber takes a range specifier as parameter and matches positions only
if the current move number is within the specified range. The move number
computation assumes white moves first, and might be one off otherwise.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:movenumber</keyword> 10 20 <cql>position:check</cql>)
</verb>

<p>
Matches a position in which there is a check between moves 10 and 20.
</p>

<verb>
(position <keyword>:movenumber</keyword> 35 <cql>position:mate</cql>)
</verb>

<p>
matches a position in which move 35 is mate.
</p>

<h3 id="position:moveto">:moveto</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose
to designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:moveto</keyword> .a3)
</verb>

<p>
Matches a position in which the next move is to an empty square on a3.
</p>

<verb>
(position <keyword>:moveto</keyword> &R;[b1-8])
</verb>

<p>
Matches a position in which the next move is to capture a white rook on
the b file. Note that this is quite different from the natural
<a href="http://de.wikipedia.org/wiki/Portable_Game_Notation">PGN</a>
interpration of its being a move of a white rook to the b file. That
would be done via:
</p>

<verb>
(position <cql>position:movefrom</cql> &R; <keyword>:moveto</keyword> ?b?)
</verb>

<p>
which matches a move of the white rook to the b file.
</p>

<h3 id="position:nocastling">:nocastling</h3>

<p>
The next move is not a castling move.
</p>

<nonstd/>

<p>
See also: <cql>position:iscastling</cql>.
</p>

<h3 id="position:noenpassant">:noenpassant</h3>

<p>
The next move is not an en-passant capture.
</p>

<p>
See also: <cql>position:enpassant</cql>.
</cql>

<h3 id="position:piecedrop">:piecedrop</h3>

<p>
The next move is a piece drop (possible only in chess variants
%::mc::VariantName(Crazyhouse)%, and %::mc::VariantName(Bughouse)%).
</p>

<nonstd/>

<p>
Examples:
</p>

<verb>
(position <keyword>:piecedrop</keyword> [&N;&n;])
</verb>

<p>
The next move is a piece drop which is dropping a knight.
</p>

<verb>
(position <keyword>:piecedrop</keyword> [])
</verb>

<p>
The next move is not a piece drop (because the piece designator
is empty).
</p>

<h3 id="position:promote">:promote</h3>

<p>
Takes a single parameter, a piece designator. It matches a move if that move
is a promotion whose promotion designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:promote</keyword> [&R;&B;&N;])
</verb>

<p>
Matches a position whose next move is a white underpromotion.
</p>

<verb>
(position <keyword>:promote</keyword> [&B;&N;]a8)
</verb>

<p>
Matches a position whose next move is a white promotion to bishop or knight.
</p>

<verb>
(position <keyword>:promote</keyword> [&R;e8]
<cql>position:movefrom</cql> &P;f7 <cql>position:moveto</cql> &q;)
</verb>

<p>
Matches a position in which the next move is of a pawn on f7 capturing a black
queen on e8 and promoting to a rook.
</p>

<verb>
(position <keyword>:promote</keyword> [])
</verb>

<p>
Matches a position in which the next move is not a promotion (because the
piece designator is empty).
</p>

<h2 id="sequence">Sequence keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sequence">:sequence</a></td></tr>
  </table>
</dir>

<h3 id="position:gappedsequence">:gappedsequence</h3>

<p>
Takes one argument, a list of position lists. A position list A is said to be
a refinement of a position list B if A may be formed from B by inserting zero or
more position lists of the form (position) into the top level of B. For
example:

<verb>
((position &N;a4) (position) (position &R;b2))
</verb>

<p>
refines
</p>

<verb>
((position &N;a4) (position &R;b2))
</verb>

<p>
because it was formed by inserting a single position list into the latter list.
</p>

<p>
A :gappedsequence with argument B matches a position if and only if there is a
refinement A of B such that a <cql>position:sequence</cql> with argument A
would match that position. That is, :gappedsequence is like
<cql>position:sequence</cql> except that the sequence of matching positions
may include intervening positions from the game.
</p>

<p>
Examples:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
This will match any position for which the positions that occur successively
in the game starting with that position comprise zero or more positions,
followed by a position from which a white rook on a3 moves, followed by zero
or more positions, followed by a position from which a white rook on b4 moves.
In consequence the same effect can be obtained much more efficiently via:
</p>

<verbatim>
(position 
  <cql>position:initial</cql>
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
The following position list matches a position in which a knight is on d4 at
some point in the game after that position:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position)
    (position &N;d4))) 
</verbatim>

<p>
Note that the first element of the argument to :gappedsequence,
<expr>(position)</expr>, is used to ensure that only knights on d4 in
positions that occur after the position to be matched are considered.
</p>

<p>
This fragment is used here, to find all games in which some knight has
visited at least twenty different squares.
</p>

<p>
The total number of <cql>position:sequence</cql> and :gappedsequence position
lists that can occur at the top level of a position list cannot exceed one. To
get the effect of both a :gappedequence and <cql>position:sequence</cql>
keywords in one position list, use <cql>position:and</cql>.
</p>

<h3 id="position:sequence">:sequence</h3>

<p>
Takes a single argument that is a list of position lists. It matches a given
position if and only successive occurring positions, beginning with the
current position, match each corresponding element in its argument.
</p>

<p>
Example:
</p>

<verbatim>
(position
  &R;e8 
  <keyword>:sequence</keyword> (
    (position &Q;f3 .g2)
    (position .f3 &Q;g2)))
</verbatim>

This position list matches exactly those positions with a white rook on e8
such that:

<ol>
  <li>In that position, white has a queen on f3 and g2 is empty, and</li>
  <li>After the next move, f3 is empty and there is a white queen on g2.</li>
</ol>

<p>
In consequence, this position list is identical in effect to
</p>

<verb>
(position &R;e8 <cql>position:movefrom</cql> &Q;f3 <cql>position:moveto</cql> .g2)
</verb>

<p>
The following more typical usage of :sequence will search for all queen
staircase checking maneuvers by either side:
</p>

<verbatim>
(position 
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <keyword>:sequence</keyword> (
    (position <cql>position:movefrom</cql> &Q;a2) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;b2) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;b3) 
    (position <cql>position:check</cql>) 
    (position <cql>position:movefrom</cql> &Q;c3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c4)))
</verbatim>

<p>
This position list matches any position with a white queen on a2 for which
there are successively moves by queens on the indicated squares giving check;
the <cql>position:shift</cql>, <cql>position:flip</cql>, and
<cql>position:flipcolor</cql> search for this variation reflected or
rotated anywhere on the board.
<p>

<h2 id="game">Game related keywords</h2>

<p>
Several keywords relate to the game parameters and are not affected by the
contents of the position; they are included as position list keywords instead
of match list keywords so the <cql>position:flipcolor</cql> can be used with
them. these are:
</p>

<dir>
  <table>
    <tr><td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
        <td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
        <td>&emsp;&#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td></tr>
    <tr><td>      &#x2022;</td><td><a href="#position:rating">:rating</a></td>
        <td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
        <td>&emsp;&#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td></tr>
    <tr><td>      &#x2022;</td><td><a href="#position:result">:result</a></td></tr>
  </table>
</dir>

<h3 id="position:blackelo">:blackelo</h3>

<p>
This parameter takes a range specifier; the ELO of the black player must lie
within its range (<see/> <a href="CQL-Range-Specifiers.html">range specifiers</a>).
</p>

<h3 id="position:blackrating">:blackrating</h3>

<p>
Match all games where the specified rating score of black player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h3 id="position:elo">:elo</h3>

<p>
This parameter expects a range specifer; the ELO of at least one of the
players must lie within the specified range (<see/>
<a href="CQL-Range-Specifiers.html">range specifiers</a>)
</p>

<h3 id="position:rating">:rating</h3>

<p>
Match all games where the specified rating score of one player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h3 id="position:result">:result</h3>

<p>
This keyword takes one argument, the same as the argument to
<cql>match:result (match)</cql> in a match list.
</p>

<p>
Example:
</p>

<verbatim>
(position 
  <keyword>:result</keyword> 1-0 
  <cql>position:whiteelo</cql> 0 2300
  <cql>position:blackelo</cql> 2600 3000
  <cql>position:flipcolor</cql>)
</verbatim>

<p>
Searches for positions in which a 2300 player or below defeated a 2600 player
or above.
</p>

<h3 id="position:whiteelo">:whiteelo</h3>

<p>
This parameter takes a range specifier; the ELO of the white player must lie
within its range (<see/> <a href="CQL-Range-Specifiers.html">range specifiers</a>).
</p>

<h3 id="position:whiterating">:whiterating</h3>

<p>
Match all games where the specified rating score of white player is between
given range.  For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h2 id="relation">Relation between positions</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:relation">:relation</a></td></tr>
  </table>
</dir>

<h3 id="position:relation">:relation</h3>

<p>
Takes one argument, a relation specification. is used to search for games with
pairs of positions P1 and P2 that satisfy certain properties. See
<a href="CQL-Relation-List.html">relation list</a> for a desription of
the relation specification keywords.
</p>

<h2 id="matching">Matching count keywords</h2>

<p>
Two keywords pertain to the number of positions which a position list matches.
These each take a range specifier as parameter. They can only be used in a
position list at the top level of a match list.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td></tr>
  </table>
</dir>

<h3 id="position:matchcount">:matchcount</h3>

<p>
Matches if and only if the number of times this position list matches a
position in the current game lies within the range specifier.
</p>

<p>
Example:
</p>

<verb>
(position <cql>position:moveto</cql> [&Q;&q;] <keyword>:matchcount</keyword> 4 100)
</verb>

<p>
Matches any game in which at least four queen captures have occurred.
</p>

<h3 id="position:pretransformmatchcount">:pretransformmatchcount</h3>

<p>
Has the same syntax as <cql>position:matchcount</cql>. It matches a position if
and only if there is some transform in the transformation set associated with
the position list in which it occurs such that, were the position list
replaced by a new position list formed from the first by deleting all
transformation keywords, applying the transform to that position list, and
changing this keyword to <cql>position:matchcount</cql>, then the position
list would match the position.
</p>

<p>
Example:
</p>

<verbatim>
(position
  <cql>position:movetoy</cql> [Aa]d4 
  <keyword>:pretransformmatchcount</keyword> 12 1000
  <cql>position:shift</cql>))
</verbatim>

<p>
This would match any game in which at least 12 captures occur on the same
square. Were the :pretransformmatchcount replaced by
<cql>position:matchcount</cql>, the position list would match games in which
at least 12 captures occurred.
</p>

<h2 id="accumulator">Accumulator keywords</h2>

<p>
There are mainly two accumulator keywords, :accumulate and :sumrange. These
are used to accumulate and to test the number of transforms of the enclosing
position list that match the current position. Each time a transform of a
position list matches a position, the accumulator associated with that position
is incremented. Any position with a sum range can then test if the accumulator
is within a certain range.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:reset">:reset</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td></tr>
  </table>
</dir>

<h3 id="position:accumulate">:accumulate</h3>

<p>
This takes one parameter, the name of an accumulator. Each time the application
of some element of the transform set of the position list matches a position,
the accumulator associated with this name is incremented. The accumulator is
cleared when a new position is reached (and in consequence :accumulate should
not be used inside of <cql>position:not</cql>, or the
<cql>position:sequence</cql>, and <cql>position:gappedsequence</cql> keywords).
This keyword inhibits short-circuiting of logical keywords
<cql>position:and</cql>, and <cql>position:or</cql>. Note that
<cql>position:flipcolor</cql> likely has unexpected results when used with
:accumulate, because the accumulator is not cleared between color flips.
</p>

<p>
For examples see:
<a href="CQL-Examples#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h3 id="position:reset">:reset</h3>

<p>
This keyword takes as a parameter the name of an accumulator. It clears the
accumulator associated with this name after applying a transformation.
</p>

<nonstd/>
<ca9/>

<p>
Example:
</p>

</p>
Tripled pawns can be found by the query:
</p>

<verbatim>
(position
  <keyword>:reset</keyword> acc
  &P;e2
  <cql>position:accumulate</cql> acc
  <cql>position:sumrange</cql> acc 3
  <cql>position:shiftvertical</cql>
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Note that this is only an example for this keyword (taken from
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
it is not recommended to use this statement for triple pawn search.
A much better way is:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;a[3-7] 3 6
  <cql>position:shifthorizontal</cql>
  <cql>position:flipcolor</cql>))
</verbatim>

<h3 id="position:sumrange">:sumrange</h3>

<p>
This takes as parameter the name of an accumulator and a range specifer.
It matches a position if the value of the given accumulator lies within
the range specifier.
</p>

<p>
For examples see:
<a href="CQL-Examples#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h2 id="tagging">Tagging keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td></tr>
  </table>
</dir>

<h3 id="position:tagmatch">:tagmatch</h3>

<p>
The :tagmatch keyword takes two parameters, the name of a tag and a piece
designator. It matches only if the piece corresonding to the named tag
matches the given piece designator. For more information, see the section
on <a href="CQL-Tagging.html">tagging</a>.
</p>

END

<!-- vi:set ts=2 sw=2 et filetype=html: -->
