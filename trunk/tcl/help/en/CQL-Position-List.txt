<!-- ======================================================================
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
======================================================================= -->

<!-- ======================================================================
* Copyright: (C) 2013 Gregor Cramer
======================================================================= -->

<!-- ======================================================================
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
======================================================================= -->

HEAD

<style type="text/css">

  #tooltip1 {
    outline: none;
    cursor: help;
    margin-top: 0;
    margin-bottom: 0;
    position: relative;
  }
  #tooltip1 a {
    color: #000000;
  }
  #tooltip1 a:hover {
    color: #000000;
    background: #ffff00;
    text-decoration: none;
  }
  #tooltip1 a img {
    display: none;
  }
  #tooltip1 a:hover img {
    display: block;
    position: absolute;
    left: 10em;
    top: 2em;
    z-index: 99;
  }
  </style>

END

INDEX Position List (CQL)
INDEX CQL Position List

DEFINE <extension/> &ensp;<img src="../images/ft-scidb-tiny.png" />

TITLE CQL - The position list

<p>
The symbol <img src="../images/ft-scidb-tiny.png" /> in the title of a
keyword description denotes that this keyword is an extension, it is not
part of the CQL standard.
</p>

<p>
The keywords <cql>position:castling</cql>, <cql>position:endgame</cql>, and
<cql>position:inside</cql> are borrowed from Chess Assistant 9. The description
of these keywords are taken from
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>.
</p>

<p>
Some of the keywords can be negated with a preceding exclamation, then this is
an abbreviation; e.g.
</p>

<verb>
(position <cql>!position:check</cql>)
</verb>

<p>
is an abbreviation for
</p>

<verb>
(position <cql>position:not</cql> (position <cql>position:check</cql>))
</verb>

<p>
The keywords <cql>:nocheck</cql>, and <cql>:noenpassant</cql> are not
used anymore in <nobr>CQL-S</nobr> &ndash; the expressions
<cql>!:check</cql>, and <cql>!:enpassant</cql> should be used instead
&ndash; but will be recognized and transformed accordingly when importing
CQL scripts.
</p>

<dir>
  <table style="white-space:nowrap">
    <tr><td>&#x2022;</td><td><a href="#index">Index</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#logical">Logical keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#simple">Simple keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#transform">Transformation keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#piece">Piece configuration keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#move">Move keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#sequence">Sequence keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#game">Game related keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#relation">Relation between positions</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#matching">Matching count keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#evaluation">Analyzing keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#accumulator">Accumulator keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#tagging">Tagging keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#control">Controlling keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#meaningless">Meaningless keywords</a></td></tr>
  </table>
</dir>

<!-- ############################################################################## -->
<h2 id="index">Index</h2>
<!-- ############################################################################## -->

INCLUDE ../CQL-Position-List-Index.txt

<!-- ############################################################################## -->
<h2 id="logical">Logical keywords</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:and">:and</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:cond">:cond</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:not">:not</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:or">:or</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:xor">:xor</a></td></tr>
</table>

<h3 id="position:and">:and</h3>

<p>
Takes a list of position lists and matches a position only if each of them
match the position.
</p>

<p>
Example:
</p>

<verbatim>
(position
  <cql>position:wtm</cql>
  <cql>position:check</cql>
  <keyword>position:and</keyword> (
    (position &K;e2 &k;g2 <cql>position:shift</cql> <cql>position:flip</cql>)
    (position &N;e2)))
</verbatim>

<p>
Will match positions in which the kings are in direct opposition, there is a white
knight on e2, and white is in check.
</p>

<h3 id="position:cond">:cond<extension/></h3>

<p>
This keyword will be used in the following general form:
</p>

<verbatim>
<keyword>position:cond</keyword>
  (position &lt;Condition<sub>1</sub>&gt;) (position &lt;Expression<sub>1</sub>&gt;)
  (position &lt;Condition<sub>2</sub>&gt;) (position &lt;Expression<sub>2</sub>&gt;)
  ...
  (position &lt;Condition<sub>k</sub>&gt;) (position &lt;Expression<sub>k</sub>&gt;)
</verbatim>

<p>
<cql>:cond</cql> expects an arbitrary number of arguments. Each argument
<expr>&lt;Condition<sub>i</sub>&gt;</expr> will be called a clause, and each
argument <expr>&lt;Expression<sub>i</sub>&gt;</expr> is an association.
Successively each clause will be evaluated until a matching clause is found,
the associated expression is the result of the whole <cql>:cond</cql> expression.
A game cannot match if no clause is matching. This means that the order of the
lists inside an <cql>:cond</cql> is important. A position cannot match if none of
the clauses is matching. It is not allowed that an argument contains a position list.
</p>

<p>
Often the final pair will be expressed in the following form:
</p>

<verbatim>
(position) (position &lt;Expression&gt;)
</verbatim>

<p>
The empty list is matching any position. This case can be expressed in an
abbreviated form, by omiting the second last argument <expr>(position)</expr>.
Then the result of the last expression will be evaluated if no clause is
succeeding.
</p>

<p>
In fact the keyword <cql>:cond</cql> is not redundant, because the conversion
with the use of keyword <cql>:or</cql> is not equivalent in all cases (the
use of <cql>position:cut</cql>, <cql>position:exclude</cql>, or
<cql>position:skip</cql> is breaking the equivalence). Moreover the order
inside of <cql>:cond</cql> is significant.
</p>

<verbatim>
(position <cql>position:or</cql> (
  (position &lt;Condition<sub>1</sub>&gt; &lt;Expression<sub>1</sub>&gt;)
  (position &lt;Condition<sub>2</sub>&gt; &lt;Expression<sub>2</sub>&gt;)
  ...
  (position &lt;Condition<sub>k</sub>&gt; &lt;Expression<sub>k</sub>&gt;)))
</verbatim>

<p>
Furthermore the <cql>:cond</cql> expression will be executed quite more
efficient (consider the case that <expr>&lt;Condition<sub>1</sub>&gt;</expr>
will match, but not <expr>&lt;Expression<sub>1</sub>&gt;</expr>, then the
<cql>:or</cql> form will proceed with next list, while the <cql>:cond</cql>
form is delivering the result of <expr>&lt;Expression<sub>1</sub>&gt;</expr>
immediately).
</p>

<p>
However the <cql>:or</cql> form shows why the <cql>:cond</cql> form
is also using the association for marking the matches (this is another
difference to the <cql>:or</cql> form). To give an example:
</p>

<verbatim>
(match
  (position <keyword>position:cond</keyword> (
    (position &P;e7) (position &p;e2))))
</verbatim>

<p>
If a position has a white pawn on square e7, and a black pawn on square e2,
both squares will be marked in any matching position.
</p>

<p>
See <cql>position:exclude</cql> for a real example showing the usage
of <cql>:cond</cql>.
</p>

<h3 id="position:not">:not</h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
match if the containing match list would not match without the
<cql>:not</cql>. In latter case negate the result of the sub-position list
match. The former case is conform with CQL standard of keyword <cql>:not</cql>,
the second form is an extension.
</p>

<p>
Examples:
</p>

<verbatim>
(match
  (position
    ; <comment>we are searching for either colors</comment>
    <cql>position:flipcolor</cql>
    <comment>; the mating position must match each criterion below</comment>
    <cql>position:and</cql> (
      <comment>; the black king is surrounded by empty squares and</comment>
      <comment>; is attacked once and is in mate</comment>
      (position
        <cql>position:attackcount</cql> &k; . 8
        <cql>position:attackcount</cql> &A; &k; 1
        <cql>position:mate</cql>
        <cql>position:btm</cql>)
      <comment>; check that no neighbor of the black king is</comment>
      <comment>; attacked more than once</comment>
      (position
        <keyword>position:not</keyword>
        <cql>position:attackcount</cql> &k; .e4 1
        <cql>position:attackcount</cql> &A; .e4 &gt;=2
        <cql>position:shift</cql>))))
</verbatim>

<p>
This finds all ideal mirror mates: studies in which the king is surrounded by
empty squares, is attacked once, such that if the king were to move to one of
its neighbors, it would be attacked exactly once.
</p>

<p>
The follwing position match
</p>

<verb>
(position &R;a3 <keyword>position:not</keyword>)
</verb>

<p>
is equivalent to
</p>

<verb>
(position [&a;&Q;&B;&N;&P;&K;.]a3)
</verb>

<p>
In this case the simpler form with <cql>:not</cql> is preferable.
</p>

<h3 id="position:or">:or</h3>

<p>
Takes a list of position lists and matches a position only if at least one of
them matches the position.
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position
    <keyword>position:or</keyword> (
      (position <cql>position:piececount</cql> &B;&L;? 2)
      (position <cql>position:piececount</cql> &b;&L;? 2)
      (position <cql>position:piececount</cql> &B;&D;? 2)
      (position <cql>position:piececount</cql> &b;&D;? 2))))
</verbatim>

<p>
Searching for games with one side has two bishops of same color.
</p>

<h3 id="position:xor">:xor</h3>

<p>
Expects a list of position lists and is matching a position if and
only if exactly one of the position lists is matching this position.
</p>

<p>
Example:
</p>

<verbatim>
(position <keyword>position:xor</keyword> ((position &B;&D;?) (position &B;&L;?)))
</verbatim>

<p>
Match all position where either White has a light-squared bishop or a
dark-squared bishop, but not both.
</p>

<h3 id="position:xor">:xor&emsp;<n>(Exklusives Oder)</n></h3>

<p>
Erwartet eine Liste von Positionslisten und filtert nur dann eine
Position, wenn genau eine von ihnen diese Position filtert.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position <keyword>position:xor</keyword> ((position &B;&D;?) (position &B;&L;?)))
</verbatim>

<p>
Findet Positionen auf, in denen Weiß entweder einen weißfeldrigen Läufer, oder
einen schwarzfeldrigen Läufer hat, aber nicht beides.
</p>

<!-- ############################################################################## -->
<h2 id="simple">Simple keywords</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr>
    <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:kingonthehill">:kingonthehill</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:losing">:losing</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:mate">:mate</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:mustcapture">:mustcapture</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:catureforced">:catureforced</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:threechecks">:threechecks</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:fivefoldrepetition">:fen</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:threefoldrepetition">:threechecks</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:halfmoveclock">:halfmoveclock</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
  </tr>
    <td>      &#x2022;</td><td><a href="#position:insidevariation">:insidevariation</a></td>
    <td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
  </tr>
  <tr>
    <td>      &#x2022;</td><td><a href="#position:ispromotedpiece">:ispromotedpiece</a></td>
  </tr>
</table>

<h3 id="position:blackcannotwin">:blackcannotwin<extension/></h3>

<p>
Match only if black cannot win in this position.
</p>

<p>
Normally this is equivalent to following query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; black king only</comment>
  (<cql>position:piececount</cql> &a; 1)
  <comment>; black king and black minor piece only</comment>
  (<cql>position:piececount</cql> &a; 2 <cql>position:piececount</cql> &i; 1))
</verbatim>

<p>
In chess variant %::mc::VariantName(ThreeCheck)% the query with
<cql>:blackcannotwin</cql> succeeds only if black has no more pieces than
the king, and in all other chess variants this query has no meaning and is
always failing.
</p>

<p>
In chess variant %::mc::VariantName(KingOfTheHill)% <cql>:blackcannotwin</cql>
cannot match any game.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:blackcannotwin</keyword>)
</verb>

<p>
Match all position where black (theoretically) still has winning chances.
</p>

<p>
See also: <cql>position:whitecannotwin</cql>
</p>

<h3 id="position:btm">:btm</h3>

<p>
Match only if black is to move.
</p>

<p>
See also: <cql>position:wtm</cql>.
</p>

<h3 id="position:check">:check</h3>

<p>
One side is in check.  This keyword can be used in a negated form; with
a preceding exclamation mark. Example:
</p>

<verb>
(position <keyword>!position:check</keyword>)
</verb>

<p>
Neither side is in check.
</p>

<p>
See also:
<cql>position:ischeck</cql>,
<cql>position:contactcheck</cql>,
<cql>position:doublecheck</cql>.
</p>

<h3 id="position:castling">:castling<extension/></h3>

<p>
This keyword specifies castling availabilities for either sides. It takes as an
argument a piecetype designator, letters of which have the following meanings:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">White has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&Q;</expr></td>
      <td class="r">White has queenside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Black has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&q;</expr></td>
      <td class="r">Black has queenside castling availability</td>
    </tr>
  </table>
</dir>

<p>
Examples:
</p>

<verb>
(position <keyword>position:castling</keyword> &K;)
</verb>

<p>
White has kingside castling availability.
</p>

<verb>
(position <keyword>position:castling</keyword> [&K;&Q;])
</verb>

<p>
White has either kingside or queenside castling availability
(but not both).
</p>

<verb>
(position <keyword>position:castling</keyword> &K; <keyword>position:castling</keyword> &Q;)
</verb>

<p>
White has either kingside and queenside castling availabilities.
</p>

<p>
See also: <cql>position:iscastling</cql>.
</p>

<h3 id="position:contactcheck">:contactcheck<extension/></h3>

<p>
One side is in check, and it is a contact check (it's not possible to place
a piece between the checker and the king, even not theoretical). This
includes knight checks and double checks.
</p>

<p>
This is equivalent to:
</p>

<verbatim>
(position
  <cql>position:check</cql> <comment>; exclude Antichess games</comment>
  <cql>position:or</cql> (
    (position <cql>position:doublecheck</cql>)
    (position <cql>position:attackcount</cql> [&N;&P;] &k; 1 <cql>position:flipcolor</cql>)
    (position [&Q;&R;]d4 &k;[c4,e4,d3,d5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)
    (position [&Q;&B;]d4 &k;[c3,c5,e3,e5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)))
</verbatim>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:contactcheck</keyword>)
</verb>

<p>
Neither side is in check, or it is not a contact check.
</p>

<p>
It is possible to restrict the pieces with an optional piece designator. Example:
</p>

<verb>
(position <keyword>position:contactcheck</keyword> &Q;)
</verb>

<p>
A white queen is adjacent to the opposing king (contact check).
</p>

<verb>
(position !<keyword>position:contactcheck</keyword> &Q;)
</verb>

<p>
The white queen is not adjacent to the opposing king.
</p>

<p>
<cql>position:iscontactcheck</cql>,
<cql>position:check</cql>,
<cql>position:doublecheck</cql>.
</p>

<h3 id="position:doublecheck">:doublecheck<extension/></h3>

<p>
One side is in check, and it is a double check.
</p>

<p>
In fact this is an abbreviation for:
</p>

<verb>
(position <cql>position:attackcount</cql> &A; &k; &gt;=2 <cql>position:flipcolor</cql>)
</verb>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:doublecheck</keyword>)
</verb>

<p>
Match all position where neither side is double checked.
</p>

<p>
See also:
<cql>position:isdoublecheck</cql>,
<cql>position:check</cql>,
<cql>position:contactcheck</cql>.
</p>

<h3 id="position:endgame">:endgame<extension/></h3>

<p>
The position is an endgame position. The keyword is equivalent to the following
query:
</p>

<verbatim>
  (position
    <cql>position:or</cql> (
      (position
        <cql>position:piececount</cql> [&Q;&q;] 0
        <cql>position:piececount</cql> [&R;&B;&N;] 0 3
        <cql>position:piececount</cql> [&r;&b;&n;] 0 3)
      (position
        <cql>position:piececount</cql> &Q; 1
        <cql>position:piececount</cql> &q; 1
        <cql>position:piececount</cql> [&R;&r;] 0
        <cql>position:piececount</cql> &I; 0 1
        <cql>position:piececount</cql> &i; 0 1)
      (position
        <cql>position:piececount</cql> &Q; 1
        <cql>position:piececount</cql> &R; 0
        <cql>position:piececount</cql> &I; 0 1
        <cql>position:piececount</cql> &q; 0
        <cql>position:power</cql> [&r;&b;&n;] 0 16
        <cql>position:flipcolor</cql>)))
</verbatim>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <cql>!position:endgame</cql>)
</verb>

<p>
Match all positions which are not an endgame position.
</p>

<h3 id="position:fen">:fen<extension/></h3>

<p>
The position is equal to the described position in given argument.
This argument must be a valid <a href="FEN.html">FEN (Forsyth-Edwards Notation)</a>.
</p>

<p>
Example:
</p>

<verbatim>
(position
  <keyword>position:fen</keyword> "rnbqkbnr/pppp1ppp/4p3/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2")
</verbatim>

<p>
This position denotes a basic position of the French line. Normally this
position will be achieved with the line 1.e4 e6 2.d4 d5.
</p>

<p>
See also: <cql>position:line*</cql>.
</p>

<h3 id="position:fivefoldrepetition">:fivefoldrepetition<extension/></h3>

<p>
Match first position of mainline which occurred the third time in this game,
with same player to move, and each player has the same castling and en-passant
capturing rights. The repeated positions need not occur in succession. This
accords with the new FIDE rules of fivefold repetition.
</p>

<p>
Inside of sub-variants this keyword has no effect and will always fail.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:fivefoldrepetition</keyword>)
</verb>

<p>
Match any position which is not occurring the fifth time. If it is
not wanted to match positions after a fivefold repetition has
occurred, then realize this with <cql>position:cut</cql>:
</p>

<verb>
(position <keyword>position:fivefoldrepetition</keyword> <cql>position:cut</cql>)
</verb>

<h3 id="position:gameisover">:gameisover<extension/></h3>

<p>
This is an abbreviation for:
</p>

<verbatim>
  <cql>position:or</cql> (
    (position <cql>position:mate</cql>)
    (position <cql>position:stalemate</cql>)
    (position <cql>position:losing</cql>)
    (position <cql>position:checkcount 3</cql>)
    (position <cql>position:nomatingmaterial</cql>))
</verbatim>

<p>
Note that this keyword may effect unwanted results if the search
includes sub-variations.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:gameisover</keyword>)
</verb>

<p>
Matches all games ending in a position which prevents continuing.
</p>

<verb>
(position <keyword>!position:gameisover</keyword>)
</verb>

<p>
Match all position which can be continued (according to the chess rules).
</p>

<h3 id="position:halfmoveclock">:halfmoveclock<extension/></h3>

<p>
This keyword is matching a position when the halfmove clock lies inside
the <a href="CQL-Range-Specifiers.html">range specifier</a>, given by the
first argument. Inside of sub-variations this keyword has no effect and
will always succeed.
</p>

<p>
Halfmove clock: This is the number of halfmoves since the last pawn
advance or capture. This is also used to determine if a draw can be
claimed under the fifty-move rule.
</p>

<p>
Example:
</p>

<verb>
(position <keyword>position:halfmoveclock</keyword> &lt;=30)
</verb>

<p>
Exclude all positions where no capture has been made and no pawn has been
moved since more than thirty halfmoves (15 moves by each side).
</p>

<verb>
(position <keyword>position:halfmoveclock</keyword> &gt;=100 !<cql>position:terminal</cql>)
</verb>

<p>
First position in game where no capture has been made and no pawn has been
moved in previous fifty consecutive moves, and the side to move didn't claim
a draw.
</p>

<h3 id="position:initial">:initial</h3>

<p>
This is the first position in the game (before first move). In fact this is
an alternative notation for:
</p>

<verb>
<cql>position:halfmovenumber</cql> 0
</verb>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:initial</keyword>)
</verb>

<p>
Match all positions except the first position in the game.
</p>

<p>
See also: <cql>position:halfmovenumber</cql>.
</p>

<h3 id="position:insidevariation">:insidevariation<extension/></h3>

<p>
This keyword matches if a position will be found inside a sub-variation. This cannot
happen as long as <cql>position:variations</cql> is not used to include sub-variations.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:insidevariation</keyword>)
</verb>

<p>
This position is not found inside a sub-variation.
</p>

<p>
See also: <cql>position:variations</cql>.
</p>

<h3 id="position:losing">:losing<extension/></h3>

<p>
Will match the final position if one side has lost all pieces.
This is possible only in Antichess games.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:losing</keyword>)
</verb>

<p>
Only match positions where neither side has lost all pieces.
</p>

<h3 id="position:mate">:mate</h3>

<p>
Match only if the position is a mate.
</p>

<annotation>
When searching for mate positions this keyword should always be used even if
this keyword might be superfluous because other conditions are ensuring a
mate position, it is accelerating the search (only testing final positions).
</annotation>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:mate</keyword>)
</verb>

<p>
Exclude all checkmate positions.
</p>

<p>
One more example:
</p>

<verb>
(position <keyword>position:mate</keyword> <cql>position:movenumber</cql> 1 20)
</verb>

<p>
Only matches if one side is mated in first 20 moves.
</p>

<p>
See also: <cql>position:ismate</cql>.
</p>

<h3 id="position:matingmaterial">:matingmaterial<extension/></h3>

<p>
Match a position if either player has mating material (<see/>
<cql>position:nomatingmaterial</cql>). In chess variant
%::mc::VariantName(ThreeCheck)% this search cannot match as
soon as only kings are on board. In all other chess variants
(except %::mc::VariantName(ThreeCheck)%, and %::mc::VariantName(Normal)%)
this keyword is meaningless and always successful.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:matingmaterial</keyword>)
</verb>

<p>
Match positions where neither player has mating material. Normally this
query is equivalent to:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; king versus king</comment>
  (position <cql>position:piececount</cql> &U; 2)
  <comment>; king and minor piece versus king</comment>
  (position <cql>position:piececount</cql> &U; 3 <cql>position:piececount</cql> [&I;&i;] 1)
  <comment>; king and bishop versus king and bishop,</comment>
  <comment>; both bishops are either light-squared, or dark-squared</comment>
  (position <cql>position:piececount</cql> &U; 4 <cql>position:piececount</cql> [&B;&b;]&L;? 2)
  (position <cql>position:piececount</cql> &U; 4 <cql>position:piececount</cql> [&B;&b;]&D;? 2))
</verbatim>

<p>
The negated form is always unsuccessful in all other chess variants than
%::mc::VariantName(ThreeCheck)%.
</p>

<h3 id="position:mustcapture">:mustcapture<extension/></h3>

<p>
In this position the side to move has the obligation to capture a piece
(this also means that a capture is possible). This keyword is provided
for chess variant %::mc::VariantName(Antichess)%, and cannot be successful
in all other chess variants.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:mustcapture</keyword>)
</verb>

<p>
In this position the side to move ist not obligated to capture a piece
(this also means that a capture is not possible at all). This condition
will be always fulfilled in other chess variants than
%::mc::VariantName(Antichess)%.
</p>

<p>
See also: <cql>position:mustcapture</cql>,
</p>

<h3 id="position:nocheck">:nocheck</h3>

<p>
This keyword is deprecated and should not be used anymore. It will be
supported only for compatibility reasons, ans has the same meaning as
the expression <cql>!position:check</cql>.
</p>

<h3 id="position:stalemate">:stalemate</h3>

<p>
Match only if the position is a stalemate.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:stalemate</keyword>)
</verb>

<p>
Match only if the position is not stalemate.
</p>

<p>
See also: <cql>position:isstalemate</cql>,
</p>

<h3 id="position:terminal">:terminal<extension/></h3>

<p>
This is the last position in the game (after last move). In fact this
is only an alternative form for:
</p>

<verb>
<cql>position:halfmovenumber</cql> end
</verb>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:terminal</keyword>)
</verb>

<p>
This is not the final position in the game.
</p>

<p>
See also: <cql>position:halfmovenumber</cql>.
</p>

<h3 id="position:threefoldrepetition">:threefoldrepetition<extension/></h3>

<p>
Match first position of mainline which occurred the third time in this game,
with same player to move, and each player has the same castling and en-passant
capturing rights. The repeated positions need not occur in succession. This
accords with the old
<!-- Note for translators: please replace with a localized web page -->
<a href="http://en.wikipedia.org/wiki/Threefold_repetition">threefold repetition rule</a>.
</p>

<p>
Inside of sub-variants this keyword has no effect and will always fail.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>

<verb>
(position <keyword>!position:threefoldrepetition</keyword>)
</verb>

<p>
Match any position which is not occurring the third time. If it is
not wanted to match positions after a threefold repetition has
occurred, then realize this with <cql>position:cut</cql>:
</p>

<verb>
(position <keyword>position:threefoldrepetition</keyword> <cql>position:cut</cql>)
</verb>

<h3 id="position:variations">:variations</h3>

<p>
Look in the variations to find matches. Without this keyword the variations
will be skipped.
</p>

<h3 id="position:variationsonly">:variationsonly</h3>

<p>
Look only in the variations to find matches, not in the main line.
</p>

<h3 id="position:whitecannotwin">:whitecannotwin<extension/></h3>

<p>
Match only if white cannot win in this position.
</p>

<p>
Normally this is equivalent to following query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; white king only</comment>
  (position <cql>position:piececount</cql> &A; 1)
  <comment>; white king and white minor piece only</comment>
  (position <cql>position:piececount</cql> &A; 2 <cql>position:piececount</cql> &I; 1))
</verbatim>

<p>
In chess variant %::mc::VariantName(ThreeCheck)% this query succeeds only if
white has no more pieces than the king, and in other chess variants this
query has no meaning and is always failing.
</p>

<p>
This keyword can be used in a negated form; with a preceding exclamation
mark. Example:
</p>
<verb>
(position <keyword>!position:whitecannotwin</keyword>)
</verb>

<p>
Match all positions where the white player still has the option to win
(even if only theoretical).
</p>

<p>
See also: <cql>position:blackcannotwin</cql>
</p>

<h3 id="position:wtm">:wtm</h3>

<p>
Match only if white is to move.
</p>

<!-- ############################################################################## -->
<h2 id="transform">Transformation keywords</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:flip">:flip</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:inside">:inside</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shift">:shift</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td></tr>
</table>

<h3 id="position:flip">:flip</h3>

<p>
Same as <cql>position:flipdihedral</cql> (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipcolor">:flipcolor</h3>

<p>
The color flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>
<p>
This color flip transformation will have two effects: on one hand a flip
about the vertical bisector of the board
(<see/> <a href="CQL-Transformations.html">Transformationen</a>)
and, on the other hand, a color flip: exchange white with black,
and black with white. This color flip transformation has no impact
to the match list <expr>(match</expr> <expr>...)</expr>
(<cql>match:eithercolor</cql> is designated for this).
</p>

<h3 id="position:flipdiagonal">:flipdiagonal</h3>

<p>
The diagonal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipdihedral">:flipdihedral</h3>

<p>
All dihedral transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:fliphorizontal">:fliphorizontal</h3>

<p>
The horizontal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipvertical">:flipvertical</h3>

<p>
The vertical flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:inside">:inside<extension/></h3>

<p>
This keyword filters shift transformations in order to some matching pieces
will stay inside a specified region of the board. It takes two arguments, a
piece designator and a square designator. Any shift transformation affects
only the first argument. A shift transformation match <cql>:inside</cql>
limitation if at least one piece matching the first argument (taking into
account the transformation) is placed on a square matching the second argument.
</p>

<p>
The following examples are only demonstrations for the usage of
<cql>position:pawncount</cql>. For the search of tripled pawns
the keyword <cql>position:pawncount</cql> is recommended.
</p>

<p>
We use the following query to find tripled pawns:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
To find one of tripled pawns placed on the main diagonal we design the query
</p>

<verbatim>
(position
  <keyword>position:inside</keyword> &P;[b2-7] [b2,c3,d4,e5,f6,g7]
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<h3 id="position:shift">:shift</h3>

<p>
The shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftdiagonal">:shiftdiagonal</h3>

<p>
The off-diagonal and main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shifthorizontal">:shifthorizontal</h3>

<p>
The horizontal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftmaindiagonal">:shiftmaindiagonal</h3>

<p>
The main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftoffdiagonal">:shiftoffdiagonal</h3>

<p>
The off-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftvertical">:shiftvertical</h3>

<p>
The vertical shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<!-- ############################################################################## -->
<h2 id="piece">Piece configuration keywords</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:goodbishop">:goodbishop</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:opposition">:opposition</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pawncount">:pawncount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pawncountdifference">:pawncountdifference</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:piececount">:piececount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:piececountdifference">:piececountdifference</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:power">:power</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ray">:ray</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td></tr>
</table>

<h3 id="position:attackcount">:attackcount</h3>

<p>
This keyword takes as arguments two piece designators followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. The first piece
designator is the attacker piece designator. The second piece designator
is the attacked piece designator. An attack by a piece to a square occurs
if the piece could move to that square were it empty and disregarding any
possible checks. A valid attack is an attack by a piece on a square that
matches the attacker piece designator to a square on which is a piece that
matches the attacking piece designator.
</p>

<p>
The <cql>:attackcount</cql> keyword matches a position if the total number
of valid attacks in the position lies with the range given by its range
specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; &k; 2)
</verb>

<p>
Will match any position in which white has a double attack on the black king
(note that the use of <cql>position:doublecheck</cql> combined with
<cql>position:btm</cql> should be preferred).
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; &k; 2 <cql>position:flipcolor</cql>)
</verb>

<p>
Will match any position in which a king is under double attack
(again the use of <cql>position:doublecheck</cql> should be preferred).
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; .h3 1)
</verb>

<p>
Will match a position in which exactly one white piece attacks an empty h3 square.
</p>

<verb>
(position <keyword>position:attackcount</keyword> [&R;&B;][a-c8] ??1 5 9
</verb>

<p>
Will match a position in which the number of times a white rook or white bishop
on a8, b8, or c8 attacks a square on the first rank is between 5 and 9
inclusive.
</p>

<verb>
(position <keyword>position:attackcount</keyword> &n; [&K;&R;&Q;] &gt;=3)
</verb>

<p>
Will match position for which the number of times a black knight attacks a white
King or white major piece is at least 3.
</p>

<verb>
(position <keyword>position:attackcount</keyword> [&K;&k;] . 0)
</verb>

<p>
Both kings cannot move in this position.
</p>

<verb>
(position <keyword>position:attackcount</keyword> &A; ??8 0)
</verb>

<p>
In this position no white piece can move onto the black back rank.
</p>

<verb>
(position <keyword>position:attackcount</keyword> &U; ? 1)
</verb>

<p>
Only one move is possible in this position.
</p>

<verb>
(position <keyword>position:attackcount</keyword> [&N;&n;][+] . 0)
</verb>

<p>
No knight can be dropped in this position
(%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%).
</p>

<h3 id="position:goodbishop">:goodbishop<extension/></h3>

<p>
Match positions with at least one bishop which is rated <i>good</i> or
<i>bad</i>. This keyword expects a piece designator as first argument,
containing only bishops. Then either two
<a href="CQL-Range-Specifiers.html">range specifiers</a>, or two
<a href="CQL-Percentage-Specifiers.html">percentage range specifiers</a>
will follow. The first one is denoting the count or the percentage of
the opposing pawns &ndash; the percentage refers to the total count
of opposing pawns &ndash; and the second range is the count or the
percentage of all own pawns which are not blockading the bishop
&ndash; in this case the percentage refers to the total count of
own pawns. Both ranges will be applied for each bishop individually.
The ranges must be separated by symbol <expr>:</expr>.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:goodbishop</keyword> &B;[&D;?] &gt;50% : &gt;50%)
</verb>

<p>
White has at least one <i>good</i> dark-squared bishop, because more than
50% of the opposing pawns are dark-squared (thus attackable), and more
than 50% of the own pawns are light-squared (thus not blocking the bishop).
</p>

<verb>
(position <keyword>position:goodbishop</keyword> &B; &gt;50% : &gt;50%)
</verb>

<p>
White has at least one <i>good</i> bishop.
</p>

<verb>
(position <keyword>position:goodbishop</keyword> [&B;&b;] &lt;=30% : &lt;=20%)
</verb>

<p>
One side has a <i>bad</i> bishop.
</p>

<h3 id="position:opposition">:opposition<extension/></h3>

<p>
This keyword is matching all positions where the specified king has the
opposition. It takes a piecetype designator as an optional argument, where
the piecetypes have the following meaning:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">White king has opposition to black king.</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Black king has opposition to white king.</td>
    </tr>
  </table>
</dir>

<p>
If no piecetype designator is given, the king of the side to move will
be investigated.
</p>

<p>
The use of this keyword is appropriate only in certain endgame situations,
to check whether the king is in opposition again, for example. Whether a king
has the opposition will be decided with a purely formal computation over
the distance of the kings, considering the side to move, but disregarding
all other pieces on the board, even possible checks will no be taken into
consideration. Hence the following example would match even the start
position:
</p>

<verb>
(position <keyword>position:opposition</keyword> &K;)
</verb>

<!-- ========================================================= -->
<h3 id="position:pawncount">:pawncount<extension/></h3>

<p>
<cql>:pawncount</cql> serves for counting pawn structures or pawn attributes.
The first argument is a piece designator, which contains only pawns, followed
by a hyphen-separated enumeration of attributes. The last argument is either
a <a href="CQL-Range-Specifiers.html">range specifier</a>, or a
<a href="CQL-Percentage-Specifiers.html">percentage range specifier</a>.
The percentage specification refers to the total count of pawns on the board
with the same color as specified in the piece designator. This keyword
is matching if the distribution of those pawns, fulfilling all the given
attributes, is inside the specified range.
</p>

<p>
The supported pawn structures and pawn attributes are:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>single</expr></td>
      <td class="r">Count one pawn if this is the sole pawn on a line
                    of this color.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>double</expr></td>
      <td class="r">Count two pawns if at least two pawns of the same color
                    are in the same line.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>double!</expr></td>
      <td class="r">Count two pawns if exact two pawns of the same color
                    are in the same line.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple</expr></td>
      <td class="r">Count three pawns if at least three pawns of the same color
                    are in the same line.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple!</expr></td>
      <td class="r">Count three pawns if exact three pawns of the same color
                    are in the same line.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple(n)</expr></td>
      <td class="r">Count n pawns if at least n pawns of the same color
                    are in the same line.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple!(n)</expr></td>
      <td class="r">Count n pawns if exact n pawns of the same color
                    are in the same line.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>uno</expr></td>
      <td class="r">Count one pawn if this is the sole pawn on a file
                    of this color.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>duo</expr></td>
      <td class="r">Count two pawns if at least two pawns of the same color
                    are in the same file.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>duo!</expr></td>
      <td class="r">Count two pawns if exact two pawns of the same color
                    are in the same file.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>trio</expr></td>
      <td class="r">Count three pawns if at least three pawns of the same color
                    are in the same file.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>trio!</expr></td>
      <td class="r">Count three pawns if exact three pawns of the same color
                    are in the same file.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart</expr></td>
      <td class="r">Count four pawns if at least four pawns of the same color
                    are in the same file.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart!</expr></td>
      <td class="r">Count four pawns if exact four pawns of the same color
                    are in the same file.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart(n)</expr></td>
      <td class="r">Bauern verbunden in einer Reihe: es werden alle verbundenen Bauern
                    auf einer Reihe gezählt, wenn mindestens n Bauern zu diesem Verbund
                    gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart!(n)</expr></td>
      <td class="r">Bauern verbunden in einer Reihe (exakt): es werden alle
                    verbundenen Bauern auf einer Reihe gezählt, wenn genau n
                    Bauern zu diesem Verbund gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>connected</expr></td>
      <td class="r">Verbundene Bauern: es werden alle Bauern gezählt, die einen
                    Bauern der gleichen Farbe auf einer benachbarten Linie haben.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>integrated</expr></td>
      <td class="r">Integrierte Bauern: es werden alle Bauern gezählt, die
                    auf allen Nachbarslinien Bauern der gleichen Farbe
                    haben.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>isolated</expr></td>
      <td class="r">Isolierte Bauern (Isolani): es werden alle Bauern gezählt,
                    die keinen Bauern gleicher Farbe auf einer benachbarten
                    Linie haben.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>halfisolated</expr></td>
      <td class="r">Halb-isolierte Bauern: es werden alle Bauern gezählt,
                    die auf einer benachbarten Linie mindstens einen
                    gleichfarbigen Bauern haben, aber keinen auf der anderen
                    benachbarten Linie. Ein Randbauer kann niemals
                    halb-isoliert sein.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>defended</expr></td>
      <td class="r">Verteidigte Bauern: es werden alle Bauern gezählt, die von
                    einem Bauern der gleichen Farbe gedeckt werden (auch wenn
                    sie nicht angegriffen sind).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>defender</expr></td>
      <td class="r">Verteidigende Bauern: es werden alle Bauern gezählt, die
                    einen Bauern der gleichen Farbe decken (auch wenn der
                    gedeckte Bauer nicht angegriffen ist).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained</expr></td>
      <td class="r">Bauernkette: es werden alle Bauern gezählt, die sich mit
                    gleichfarbigen Bauern auf einer Schräge befinden (sie
                    sind verbunden, und bis auf den hintersten sind alle
                    gedeckt).</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained(n)</expr></td>
      <td class="r">Bauernkette: es werden alle Bauern gezählt, die sich mit
                    gleichfarbigen Bauern auf einer Schräge befinden (sie
                    sind verbunden, und bis auf den hintersten sind alle
                    gedeckt), aber nur wenn sich in diesem Verbund mindestens
                    n Bauern befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained!(n)</expr></td>
      <td class="r">Bauernkette: es werden alle Bauern gezählt, die sich mit
                    gleichfarbigen Bauern auf einer Schräge befinden (sie
                    sind verbunden, und bis auf den hintersten sind alle
                    gedeckt), aber  nur wenn sich in diesem Verbund genau
                    n Bauern befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>passed</expr></td>
      <td class="r">Freibauern: es werden alle Bauern gezählt, die keinen
                    gegnerischen Bauer auf der gleichen Linie haben, und
                    von keinem gegnerischen Bauern auf einer benachbarten
                    Linie gestoppt werden können.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>candidate</expr></td>
      <td class="r">Kandidaten: es werden alle Bauern gezählt, die keinen
                    gegnerischen Bauer auf der gleichen Linie vor sich haben,
                    und wenn die Anzahl der gleichfarbigen Bauern seitlich
                    des Bauern bzw. hinter dem Bauern auf benachbarten Linien
                    mindestens so groß ist wie die Anzahl der andersfarbigen
                    Bauern auf den benachbarten Linien in der Vowärtsrichtung
                    (somit ein Kanditat für einen Freibauern). Freibauern
                    (d.h. Bauern die keinen andersfarbigen Bauern auf den
                    Nachbarslinien begegnen) werden auch als Kandidat gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>candidate!</expr></td>
      <td class="r">Kandidaten: Ein Kandidat für einen Freibauern, der jedoch
                    noch kein Freibauer ist.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>blocked</expr></td>
      <td class="r">Blockierte Bauern: zählt alle Bauern, denen auf der gleichen
                    Linie ein gegnerischer Bauer gegenübersteht.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>blocked!</expr></td>
      <td class="r">Blockierte Bauern (unmittelbar): zählt alle Bauern, denen
                    unmittelbar ein Bauer gegenübersteht.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>behind</expr></td>
      <td class="r">Bauern hinter dem Feind: zählt alle Bauern, die hinter
                    dem hintersten gegenerischen Bauer auf der gleichen Linie
                    stehen.  Z.B. kann ein weißer Bauer c7 hinter einem schwarzen
                    Bauer c5 stehen, wenn auch entfernt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>behind!</expr></td>
      <td class="r">Bauern unmittelbar hinter dem Feind: zählt alle Bauern, die
                    unmittelbar hinter dem hintersten gegenerischen Bauer auf der
                    gleichen Linie stehen. Z.B. kann ein weißer Bauer c7 unmittelbar
                    hinter einem schwarzen Bauer c6 stehen.</td>
    </tr>
    </tr>
      <td class="l" valign="top"><expr>stoppable</expr></td>
      <td class="r">Stoppbare Bauern: alle Bauern, die am Weiterrücken bis
                    zur gegnerischen Grundreihe von einem gegnerischen Bauern
                    in einer benachbarten Linie gehindert werden.</td>
    </tr>
    </tr>
      <td class="l" valign="top"><expr>stopped</expr></td>
      <td class="r">Gestoppte Bauern: alle Bauern, die am Weiterrücken von
                    einem gegnerischen Bauern, der in einer benachbarten Reihe
                    einer benachbarten Linie steht, gehindert werden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>backward</expr></td>
      <td class="r">Rückständige Bauern: alle Bauern, deren benachbarte Bauern
                    gleicher Farbe zu weit vorgerückt sind, um ihn decken zu
                    können. Isolierte Bauern sind niemals rückständig.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>advanced</expr></td>
      <td class="r">Vorgerückte Bauern: alle Bauern, die bereits in der gegnerischen
                    Hälfte stehen.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive</expr></td>
      <td class="r">Hintereinanderstehende Bauern: alle Bauern gleicher
                    Farbe, die auf einer Linie direkt hintereinander stehen,
                    werden gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive(n)</expr></td>
      <td class="r">Hintereinanderstehende Bauern: mindestens n Bauern gleicher
                    Farbe, die auf einer Linie direkt hintereinander stehen,
                    werden gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive!(n)</expr></td>
      <td class="r">Hintereinanderstehende Bauern: genau n Bauern gleicher
                    Farbe, die auf einer Linie direkt hintereinander stehen,
                    werden gezählt.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>inside</expr></td>
      <td class="r">Einholbare Bauern: zählt die Bauern, die sich noch innerhalb
                    der Reichweite des gegnerischen Königs befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>symmetrical</expr></td>
      <td class="r">Symmetrische Bauernstruktur: zählt die Bauern, auf deren Linie
                    sich die gleiche Anzahl gegnerischer Bauern befindet.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>mirrored</expr></td>
      <td class="r">Gespiegelte Bauernstruktur: zählt alle Bauern,
                    auf deren Linie alle gegnerischen Bauern auf horizontal
                    gespiegelten Feldern stehen.</td>
    </tr>
  </table>
</box>

<p>
Es muss mindestens eine dieser Bauerneigenschaften verwendet werden.
</p>

<p>
Alle Bauerneigenschaften können auch mit einem vorangestellten Ausrufungszeichen
negiert werden, dazu Beispiele:
</p>

<verb>
<keyword>position:pawncount</keyword> &P; !blocked &gt;50%
</verb>

<p>
Mehr als 50% der weißen Bauern stehen keine gegnerischen Bauern auf der gleichen Linie
gegenüber.
</p>

<verb>
<keyword>position:pawncount</keyword> &P; !blocked! &gt;50%
</verb>

<p>
Mehr als 50% der weißen Bauern stehen keine gegnerischen Bauern auf der gleichen Linie
unmittelbar gegenüber.
</p>

<verb>
<keyword>position:pawncount</keyword> &P; !inside-passed &gt;0
</verb>

<p>
Mindestens ein Freibauer ist nicht mehr innerhalb der Reichweite des gegnerischen
Königs.
</p>

<p>
Bemerkung: Das Attribut <expr>passed</expr> ist nur eine Kurzschreibweise:
</p>

<dir>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l"><expr>passed</expr></td>
      <td class="m">=</td>
      <td class="r"><expr>unblocked-unstoppable</expr></td>
    </tr>
  </table>
</dir>

<p>
Jedoch ist <expr>!passed</expr> keine Kurzschreibweise.
</p>

<p>
Bemerkung: Das Attribut <expr>candidate!</expr> ist nur eine Kurzschreibweise:
</p>

<dir>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l"><expr>candidate!</expr></td>
      <td class="m">=</td>
      <td class="r"><expr>candidate-!passed</expr></td>
    </tr>
  </table>
</dir>

<p>
Die folgenden Attribute, die ebenfalls mit einem vorangestellten Ausrufungszeichen
negiert werden können, schränken die Sichtweise auf die Bauern ein:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>forefront</expr></td>
      <td class="r">Vorhut: nur die vordersten Bauern auf einer Linie
                    werden untersucht.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>rear</expr></td>
      <td class="r">Nachhut: nur die hintersten Bauern auf einer Linie
                    werden untersucht.</td>
    </tr>
  </table>
</box>

<p>
Die Position von <expr>forefront</expr> bzw. <expr>rear</expr> innerhalb der
Liste der Eigenschaften beeinflußt, für welche Attribute die Sichtweise
eingeschränkt wird. Beispiel:
</p>

<verb>
(position <keyword>position:pawncount</keyword> double!-forefront-duo &gt;0)
</verb>

<p>
Dies findet nebeneinanderstehende Doppelbauern gleicher Farbe auf, wobei sie
auf den gleichen Reihen stehen müssen. <expr>forefront</expr> muß nach
<expr>double!</expr> verwendet werden, ansonsten ist kein Doppelbauer
auffindbar (tatsächlich meldet die Applikation dann einen Fehler). Die
Reihenfolge zu <expr>duo</expr> spielt hier keine Rolle.
</p>

<p>
Die unterstützen Attribute für die Modifikation der Zählweise sind:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>islands</expr></td>
      <td class="r">Bauerninseln: zähle alle Bauerninseln (nicht die Anzahl der
                    Bauern, die zu den Inseln gehören). Eine Bauerninsel besteht
                    aus einem Bauernverbund gleicher Farbe, die jeweils alle auf
                    benachbarten Linien stehen. Zwischen gleichfarbigen Inseln
                    kann sich also kein Bauer gleicher Farbe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>islands(n)</expr></td>
      <td class="r">Bauerninseln: zähle alle Bauerninseln (nicht die Anzahl der
                    Bauern, die zu den Inseln gehören). Eine Bauerninsel besteht
                    aus einem Bauernverbund gleicher Farbe, die jeweils alle auf
                    benachbarten Linien stehen. Zwischen gleichfarbigen Inseln
                    kann sich also kein Bauer gleicher Farbe befinden. Es werden
                    jedoch nur die Inseln gezählt, zu denen jeweils mindestens
                    n Bauern gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>islands!(n)</expr></td>
      <td class="r">Bauerninseln: zähle alle Bauerninseln (nicht die Anzahl der
                    Bauern, die zu den Inseln gehören). Eine Bauerninsel besteht
                    aus einem Bauernverbund gleicher Farbe, die jeweils alle auf
                    benachbarten Linien stehen. Zwischen gleichfarbigen Inseln
                    kann sich also kein Bauer gleicher Farbe befinden. Es werden
                    jedoch nur die Inseln gezählt, zu denen jeweils genau
                    n Bauern gehören.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>compounds</expr></td>
      <td class="r">Bauernverbünde: zähle alle Bauernverbünde (nicht die Anzahl der
                    Bauern, die zu dem Verbund gehören). Eine Bauernverbund besteht
                    aus Bauern gleicher Farbe, die jeweils alle auf benachbarten Reihen
                    stehen. Zwischen gleichfarbigen Verbünden kann sich also kein Bauer
                    gleicher Farbe befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>compounds(n)</expr></td>
      <td class="r">Bauernverbünde: zähle alle Bauernverbünde (nicht die Anzahl der
                    Bauern, die zu dem Verbund gehören). Eine Bauernverbund besteht
                    aus Bauern gleicher Farbe, die jeweils alle auf benachbarten Reihen
                    stehen. Zwischen gleichfarbigen Verbünden kann sich also kein Bauer
                    gleicher Farbe befinden. Es werden jedoch nur die Verbünde gezählt,
                    zu denen jeweils mindestens n Bauern gehören</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>compounds!(n)</expr></td>
      <td class="r">Bauernverbünde: zähle alle Bauernverbünde (nicht die Anzahl der
                    Bauern, die zu dem Verbund gehören). Eine Bauernverbund besteht
                    aus Bauern gleicher Farbe, die jeweils alle auf benachbarten Reihen
                    stehen. Zwischen gleichfarbigen Verbünden kann sich also kein Bauer
                    gleicher Farbe befinden. Es werden jedoch nur die Verbünde gezählt,
                    zu denen jeweils genau n Bauern gehören</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>files</expr></td>
      <td class="r">Bauer pro Linie: zähle alle Linien (nicht die Bauern auf den
                    Linien), auf denen sich Bauern mit den genannten Eigenschaften
                    befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>files(n)</expr></td>
      <td class="r">Bauer pro Linie: zähle alle Linien (nicht die Bauern auf den
                    Linien), auf denen sich mindestens n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>files!(n)</expr></td>
      <td class="r">Bauer pro Linie: zähle alle Linien (nicht die Bauern auf den
                    Linien), auf denen sich genau n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>ranks</expr></td>
      <td class="r">Bauer pro Reihe: zähle alle Reihen (nicht die Bauern auf den
                    Linien), auf denen sich Bauern mit den genannten Eigenschaften
                    befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>ranks(n)</expr></td>
      <td class="r">Bauer pro Reihe: zähle alle Reihen (nicht die Bauern auf den
                    Linien), auf denen sich mindestens n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>ranks!(n)</expr></td>
      <td class="r">Bauer pro Reihe: zähle alle Reihen (nicht die Bauern auf den
                    Linien), auf denen sich genau n Bauern mit den genannten
                    Eigenschaften befinden.</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>bothsides</expr></td>
      <td class="r">Beide Flügel: das Resultat der Zählung ist das Minimum der
                    Bauernzahl auf dem Damenflügel (a-d) und der Bauernzahl auf dem
                    Königsflügel <nobr>(e-h).</nobr></td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>oneside</expr></td>
      <td class="r">Ein Flügel: entweder wird Null gezählt, wenn kein Bauer vorhanden
                    ist, bzw. wenn mindestens ein Bauer sowohl auf dem Dameflügel
                    <nobr>(a-d)</nobr> als auch auf dem Königsflügel <nobr>(e-h)</nobr>
                    vorhanden ist, ansonsten wird die Gesamtzahl der Bauern gezählt.</td>
    </tr>
  </table>
</box>

<p>
Eine Zählung erfolgt immer am Schluß, nachdem aller Bauern mit den gewünschten
Eigenschaften aufgefunden wurden. Damit dies klarer beim Lesen des Ausdrucks
wird, dürfen Attribute für die Zählung nur am Ende einer Attributliste
verwendet werden.
</p>

<p>
Die Attribute für die Zählweise haben keinen Einfluß auf die Auswahl der gezählten
Bauern. Sobald beispielsweise <expr>islands</expr> in einer Verknüpfung verwendet wird,
werden immer die Anzahl der Insel gezählt. Dazu Beispiele:
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] trio-islands)
</verb>

<p>
Nun wird die Anzahl aller Bauerntrios gezählt, nicht mehr die Anzahl der beteiligten
Bauern.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] chained-islands)
</verb>

<p>
Die Anzahl der Bauernketten wird gezählt, nicht die Anzahl der beteiligten Bauern.
</p>

<p>
Manche dieser Attribute können ein Zähler als Argument haben. Der Zähler muß den
Wertebereich einhalten:
</p>

<box>
  <table style="margin-top:5px;margin-bottom:5px">
    <tr>
      <td class="l" valign="top"><expr>compounds, compounds!, ranks, ranks!</expr></td>
      <td class="r">1 &#x2264; n &#x2264; 6</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>islands, islands!, files, files!</expr></td>
      <td class="r">1 &#x2264; n &#x2264; 8</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>consecutive, consecutive!</expr></td>
      <td class="r">2 &#x2264; n &#x2264; 6</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>chained, chained!</expr></td>
      <td class="r">2 &#x2264; n &#x2264; 8</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>triple, triple!</expr></td>
      <td class="r">3 &#x2264; n &#x2264; 6</td>
    </tr>
    <tr>
      <td class="l" valign="top"><expr>quart, quart!</expr></td>
      <td class="r">4 &#x2264; n &#x2264; 8</td>
    </tr>
  </table>
</box>

<p>
Grundsätzlich können alle Attribute miteinander verknüpft werden,
jedoch sind nicht alle Verknüpfungen sinnvoll. Es erfolgt eine Fehlermeldung,
wenn sich in einer Verknüpfung Attribute widersprechen (wie z.B. bei
<expr>chained-isolated</expr>, oder <expr>mirrored-unblocked</expr>).
</p>

<p>
Die Attribute wirken als Filter, d.h. jedes Attribut filtert die Bauern mit
der spezifizierten Eigenschaft, und das nachfolgende Attribut filtert dann
die verbliebenen Bauern aus der vorhergehenden Zählung. Daraus resultiert,
daß die Reihenfolge der verknüpften Attribute generell eine Rolle spielt,
so sind die folgenden Beispiele nicht äquivalent:
</p>

<verb><keyword>position:pawncount</keyword> single-behind &gt;0</verb>
<verb><keyword>position:pawncount</keyword> behind-single &gt;0</verb>

<p>
Im ersten Fall können tatsächlich nur dann Bauern auf einer Linie gezählt
werden, wenn es keinen weiteren der gleichen Farbe auf dieser Linie gibt,
aber im zweiten Fall würde <expr>behind</expr> evt. nur Bauern zurücklassen
(filtern), die dann ganz alleine auf der Linie sind (gegnerische Bauern
werden nicht berücksichtigt), und diese werden dann alle als Einzelbauern
gezählt. Diese Methodik mit der Filterung erlaubt mehr Einflußmöglichkeiten
auf die Zählung als eine einfache Und-Verknüpfung.
</p>

<p>
Weitere Beispiele:
</p>

<verb>
(position <keyword>position:pawncount</keyword> &P; blocked 100%)
</verb>

<p>
Alle weißen Bauern sind blockiert, d.h. jedem weißen Bauern steht ein schwarzer
Bauer (möglicherweise entfernt) gegenüber.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;][a-d?] blocked 100%)
</verb>

<p>
Alle Bauern auf dem Damenflügel sind blockiert, d.h. jedem Bauern auf dem Damenflügel
steht ein gegnerischer Bauer (möglicherweise entfernt) gegenüber.
</p>

<verb>
(position <keyword>position:pawncount</keyword> &P;[a-d?] blocked! &gt;=50%)
</verb>

<p>
Mindestens der Hälfte der weißen Bauern auf dem Damenflügel steht ein schwarzer
Bauer direkt gegenüber (dies kann niemals zutreffen, wenn es keine weißen Bauern
auf dem Damenflügel gibt).
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <keyword>position:pawncount</keyword> &P; double-!advanced-compounds &gt;=2)
</verbatim>

<p>
Einer der Parteien hat mindestens zwei Doppelbauern, wobei keiner
der betroffenen Bauern in der gegnerischen Hälfte steht.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-consecutive(3) &gt;=3)
</verb>

<p>
Findet isolierte Trippelbauern auf verbundenen Feldern, wie in folgender
Stellung:
</p>

<div id="tooltip1" style="margin-top:-8px">
<a><expr>8/p4pk1/8/2R1P1N1/6P1/6P1/2P2KP1/1r5r w - - 0 1</expr><img
  src="../images/cql-examples-1.png" height="241" width="241" alt=""/></a>
</div>

<p>
Die Alternative
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-triple-consecutive &gt;=3)
</verb>

<p>
wäre hier nicht das gewünschte, denn in diesem Fall werden beispielsweise auch
Trippelbauern gezählt, die nicht allesamt miteinander verbunden sind,
beispielsweise zwei isolierte Doppelbauern auf einer Linie. Wird jedoch
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-triple!-consecutive &gt;=3)
</verb>

<p>
verwendet, dann werden zwar wieder hintereinanderstehende isolierte Trippelbauern
gefunden, aber keine Stellungen mit mehr als drei hintereinanderstehenden isolierten
Bauern. Aber in diesem speziellen Beispiel ist die folgende alternative Formulierung
äquivalent zu <expr>isolated-consecutive(3)</expr>:
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] isolated-triple-compounds(3) &gt;0)
</verb>

<p>
Hier ist das Attribut <expr>triple</expr> redundant, macht aber die Sache einfacher
lesbar.
</p>

<verb>
(position <keyword>position:pawncount</keyword> [&P;&p;] backward-stopped-!blocked &gt;0)
</verb>

<p>
Einer der Parteien hat mindestens einen rückständigen Bauern, der keinen gegnerischen
Bauern auf der gleichen Linie vor ihm hat, aber von einem gegnerischen Bauer auf einer
benachbarten Linie in direkter Weise am Vorücken gehindert wird.
</p>

<verb>
(position <keyword>position:pawncount</keyword> &P;?4 stoppable-!blocked-duo! &gt;0)
</verb>

<p>
Weiß hat hängende Bauern auf der vierten Reihe: ein Bauerduo (zwei Bauern nebeneinander
auf einer Reihe), die sich auf halboffenen Linien befinden (d.h. sie sind nicht
blockiert, aber auch keine Freibauern).
</p>

<verb>
(position <keyword>position:pawncount</keyword> &p; bothsides 0)
</verb>

<p>
Schwarz hat nicht mehr auf beiden Flügeln Bauern aufzuweisen.
</p>

<verb>
(position <keyword>position:pawncount</keyword> &p; oneside &gt;0)
</verb>

<p>
Schwarz hat alle seine Bauern entweder auf dem Damenflügel oder auf
dem Königsflügel, aber nicht auf beiden Flügeln.
</p>

<p>
Siehe bei <a href="CQL-Examples.html#pawnending">CQL-Beispiele</a> für weiter Beispiele.
</p>

<p>
See also:
<cql>position:piececount</cql>,
<cql>position:pawncountdifference</cql>,
<cql>position:piececountdifference</cql>.
</p>

<h3 id="position:pawncountdifference">:pawncountdifference<extension/></n></h3>

<p>
<cql>:pawncountdifference</cql> filtert Positionen, wenn die Differenz
der Zählung von Bauern mit den spezifizierten Eigenschaften oder Strukturen
innerhalb der gegebenen Bereichsangabe liegt. Dieses Schlüsselwort kann
ein oder zwei Figurenbezeichner, die nur Bauern enthalten dürfen, als Argumente
erhalten, gefolgt von einer bindestrich-separarierten Aufzählung von Eigenschaften,
und als letztes Argument wird eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> erwartet. Ist nur ein
Figurenbezeichner gegeben, dann wird die Differenz des Resultats der Zählung der
weißen Figuren im Figurenbezeichner minus dem Resultat der Zählung der schwarzen
Figuren im Figurenbezeichner ermittelt. Bei der Angabe von zwei Figurenbezeichnern
wird die Differenz des Resultats der Zählung des ersten Figurenbezeichners minus
dem Resultat der Zählung des zweiten Figurenbezeichners ermittelt. Diese Differenz
muß innerhalb der Bereichsangabe liegen, damit eine Position gefiltert wird.
</p>

<p>
Die unterstützen Bauerneigenschaften bzw. Bauernstruktureigenschaften sind
die gleichen wie unter <cql>position:pawncount</cql>.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <keyword>position:pawncountdifference</keyword> &P;[?5-7] &p;[?2-4] passed-lines &gt;0)
</verbatim>

<p>
Weiß hat mehr Freibauern, die in der gegnerischen Hälfte stehen, als Schwarz. Es
werden hier jedoch für jede Farbe nur ein Freibauer pro Linie gezählt (in diesem
speziellen Fall könnte statt <expr>lines</expr> auch <expr>forefront</expr>
verwendet werden).
</p>

<p>
See also:
<cql>position:pawncount</cql>,
<cql>position:piececount</cql>,
<cql>position:piececountdifference</cql>.
</p>

<h3 id="position:piececount">:piececount</h3>

<p>
This keyword takes a piece designator argument followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches the
position if and only if the number of occurrences of the piece designator
in the position is given by the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:piececount</keyword> &R; 2)
</verb>

<p>
This will match any position with exactly two white rooks - a position with
three white rooks would fail to match.
</p>

<verbatim>
(position
  &N;d4
  <keyword>position:piececount</keyword> [&R;&r;][a1-8] 1 3
  <keyword>position:piececount</keyword> [&Q;&q;][a-h8] 4)
</verbatim>

<p>
This will match any position with a white knight on d4, between one and three
rooks on the a file, and exactly four queens on the eight rank. Another way
to write this position list is:
</p>

<verbatim>
(position
  &N;d4
  <keyword>position:piececount</keyword> [&R;&r;][a?] 1 3
  <keyword>position:piececount</keyword> [&Q;&q;][?8] 4)
</verbatim>

<h3 id="position:power">:power</h3>

<p>
This keyword takes as argument a piece designator followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches positions
for which the total power of all pieces in the position matching the piece
designator lies within the range specifier. The power of a piece is their
chess material power, depending on the
<a href="Chess-Variants.html">chess variant</a>:
</p>

<dir>
INCLUDE ../Power-Values.txt
</dir>

<p>
Examples:
</p>

<verb>
(position <keyword>position:power</keyword> &a; 6)
</verb>

<p>
This will match positions in which the total power of the black pieces on the
board equals 6.
</p>

<verb>
(position <keyword>position:power</keyword> &A;[a-h1-4] 10 25)
</verb>

<p>
This will match positions in which the total power of the white pieces on the
white half of the board is between 10 and 25 inclusive.
</p>

<h3 id="position:powerdifference">:powerdifference</h3>

<p>
This keyword takes as argument a piece designator followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches positions
in which the difference in power (<see/> <cql>position:power</cql>) between the
white and black pieces matching the piece designator (that is, the numeric value
of the power of the matching black pieces subtracted from the power of the
matching white pieces) lies within the range specifier.
</p>

<p>
A color flip by <cql>position:flipcolor</cql> is negating the difference in
power.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:powerdifference</keyword> &U; 4)
</verb>

<p>
This matches positions in which the white pieces have power precisely 4
greater than the black pieces.
</p>

<verb>
(position <keyword>position:powerdifference</keyword> [&R;&r;] -5 10)
</verb>

<p>
This matches positions in which white has between one fewer and two more
rooks than black.
</p>

<verb>
(position <keyword>position:powerdifference</keyword> [&R;&r;&B;&b;&N;&n;] &lt;=-2)
</verb>

<p>
This matches positions in which black is up at least an exchange.
</p>

<verbatim>
(position
  <cql>position:flipcolor</cql>
  <keyword>position:powerdifference</keyword> [&R;&r;&B;&b;&N;&n;] &lt;=-2)
</verbatim>

<p>
This matches positions in which one side is up at least an exchange.
</p>

<div id="eithercolor:example">
<verbatim>
(match
  <cql>match:result</cql> 1-0
  (position
    <cql>position:sequence</cql> (
      (position
        <keyword>position:powerdifference</keyword> &U; -2 +2
        <keyword>position:powerdifference</keyword> &Q; &q; 0)
      (position
        <cql>position:repetitioncount</cql> &gt;=12
        <keyword>position:powerdifference</keyword> &Q; &q; &lt;=&#x2212;9))))
</verbatim>
</div>

<p>
This example shows a way how to search for queen sacrifices using
<code>:powerdifference</code>. One side sacrifices a queen, and remains at
least 9 pawns down in material for at least 12 moves, and finally wins.
</p>

<p>
See also: <cql>position:powerdifference*</cql>.
</p>

<h3 id="position:ray">:ray</h3>

<p>
A ray specifier is a list of piece designators. A ray is a contiguous set of
squares on a straight line on the chessboard parallel to an axis, the a1-h1
diagonal, or the a8-h8 diagonal.
</p>

<p>
Let R by a ray with ordered set of squares in a contiguous line
<nobr>S<sub>1</sub>,</nobr> <nobr>S<sub>2</sub>,</nobr> <nobr>...,</nobr>
<nobr>S<sub>n</sub>.</nobr> Suppose a given ray specifier
<nobr>(G<sub>1</sub>,</nobr> <nobr>G<sub>2</sub>,</nobr> <nobr>...,</nobr>
<nobr>G<sub>k</sub>)</nobr> where each G<sub>i</sub> is a piece designator.
The ray R is valid with respect to the ray specifier if <nobr>G<sub>1</sub></nobr>
matches the piece on <nobr>S<sub>1</sub>,</nobr> and if <nobr>G<sub>k</sub></nobr>
matches the piece on <nobr>S<sub>n</sub>,</nobr> and if the remaining
<nobr>G<sub>i</sub></nobr> can be paired to some subset of the squares in the
ray in an order-preserving way such that each <nobr>G<sub>i</sub></nobr>
matches the piece on its corresponding square and such that all unpaired
squares in the ray are empty.
</p>

<p>
The <cql>:ray</cql> keyword takes a ray specifier and an optional
<a href="CQL-Range-Specifiers.html">range specifier</a>. If the range specifier
is absent, it is taken to be <nobr><code>&gt;=1</code>.
Otherwise, <cql>:ray</cql> matches a position if
the number of rays in the position valid with respect to the ray specifier lies
within the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:ray</keyword> (&k; &Q;))
</verb>

<p>
Will match a position in which a white queen attacks the black king.
</p>

<verb>
(position <keyword>position:ray</keyword> (&Q;a? &n; &k;[?4-8]))
</verb>

<p>
Will match a position in which a white queen on the a file pins a black knight
to the black king on the last four ranks.
</p>

<verb>
(position <keyword>position:ray</keyword> (&Q;a? &Q;c? &Q;e? &k;g?))
</verb>

<p>
Will match a position in which either three white queens and the black king are
on the same rank, with exactly one empty square between them, and one of the
queens is on the a-file, or a position in which the three white queens and
black king form a diagonal with one empty squares between successive pieces,
and the queens on the a, c, and e files in either cases.
</p>

<verb>
(position <keyword>position:ray</keyword> (&Q; &n; &k;) 2 4)
</verb>

<p>
Between two and for black knights are pinned to the black king.
</p>

<p>
See also: <cql>position:rayattack</cql>.
</p>

<h3 id="position:rayattack">:rayattack</h3>

<p>
Has the same syntax as <cql>position:ray</cql>. It has the semantics of
<cql>position:ray</cql>, except that only orthogonal rays that start on
a square containing a rook or queen are included, and only diagonal rays
starting on a square containing a bishop or queen are included.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:rayattack</keyword> (&A; &a; &k;))
</verb>

<p>
Will match a position in which a black piece is pinned to the black king.
</p>

<verb>
(position <keyword>position:rayattack</keyword> (&A;d5 &a; [&r;&k;][a-h1-4]) 3)
</verb>

<p>
Will match positions in which there are three black pieces pinned by a white
piece on d5 against either a black rook or king in the first four ranks.
</p>

<verb>
(position <cql>position:stalemate</cql> <keyword>position:rayattack</keyword>
(&A; &a; &k;) 2 8 <cql>position:flipcolor</cql>)
</verb>

<p>
Finds multiple-pin stalemates.
</p>

<p>
See also: <cql>position:ray</cql>.
</p>

<h3 id="position:raydiagonal">:raydiagonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being diagonal. A diagonal ray is a ray that is not vertical
or horizontal.
</p>

<h3 id="position:rayhorizontal">:rayhorizontal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being horizontal. A horizontal ray is a ray that is horizontal.
</p>

<h3 id="position:rayorthogonal">:rayorthogonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being orthogonal. A orthogonal ray is a ray that is not
diagonal.
</p>

<h3 id="position:rayvertical">:rayvertical</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being vertical. A vertical ray is a ray that is vertical.
</p>

<!-- ############################################################################## -->
<h2 id="move">Move keywords</h2>
<!-- ############################################################################## -->

<p>
In a position, the next move is the move about to be played, if any. A move has
three characteristics: its origin square designator, its destination square
designator and its promotion designator. These refer respectivelyto the piece
and square from which the piece moves; to the piece and square to which it is
going to move (but before it actually moves there), and to the piece and square
to which it promotes, if any. In chess variants %::mc::VariantName(DropChess)%
and %::mc::VariantName(Bughouse)% there is a fourth characteristic: the
piecedrop designator. It refers to the piecetype which will be dropped, if any.
</p>

<p>
For example, the destination designation of a white rook on a4 capturing a black
knight on d4 is <expr>&n;d4</expr>, and its origin designation is
<expr>&R;a4</expr>. The destination designation of a move to e4 that is not a
capture is <expr>.e4</expr>.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:captureforced">:captureforced</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:forced">:forced</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:halfmovenumber">:halfmovenumber</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ischeck">:ischeck</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:iscontactcheck">:iscontactcheck</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isdoublecheck">:isdoublecheck</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isillegal">:isillegal</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isinvalid">:isinvalid</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ismate">:ismate</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isnull">:isnull</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isstalemate">:isstalemate</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:moveto">:moveto</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:promote">:promote</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:takeslastpiece">:takeslastpiece</a></td></tr>
</table>

<h3 id="position:captureforced">:captureforced<extension/>&emsp;<n>(Schlagen ist erzwungen)</n></h3>

<p>
Der nächste Zug ist verpflichtet eine Figur zu schlagen. Dieses Schlüsselwort
hat nur in der Schachform %::mc::VariantName(Antichess)% eine Bedeutung und wird in
anderen Schachformen niemals erfüllt.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:captureforced</keyword>)
</verb>

<p>
Der nächste Zug ist nicht verpflichtet eine Figur zu schlagen, dies
heißt das in dieser Stellung auch keine Figur geschlagen werden kann.
Dies gilt jedoch nur für die Schachform %::mc::VariantName(Antichess)%,
in allen anderen Schachformen wird diese Bedingung immer erfüllt.
</p>

<p>
Siehe auch: <cql>position:mustcapture</cql>.
</p>

<h3 id="position:forced">:forced<extension/>&emsp;<n>(Forciert)</n></h3>

<p>
Der nächste Zug ist erzwungen, kein anderer Zug ist möglich.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>(position <keyword>!position:forced</keyword>)
</verb>

<p>
Der nächste Zug ist nicht erzwungen, es gibt auch andere Züge (auch wenn sie nicht
gut sein sollten).
</p>

<h3 id="position:enpassant">:enpassant</h3>

<p>
The next move is an en-passant capture.
</p>

<p>
See also: <cql>position:noenpassant</cql>
</p>

<h3 id="position:halfmovenumber">:halfmovenumber<extension/></h3>

<p>
<cql>:halfmovenumber</cql> expects a <a href="CQL-Range-Specifiers.html">range specifier</a>
as argument, and is matching a position only if the actual half move number is
inside the given range. Inside of sub-variants this keyword has no effect and will
always fail.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> 0)
</verb>

<p>
This denotes the first position in the game (prior to first move). This is
identical to:
</p>

<verb>
(position <cql>position:initial</cql>)
</verb>

<p>
As an extension also <expr>end</expr>, or <nobr><expr>end</expr>&minus;N</nobr>
can be used as a range argument. Two examples:
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> end)
</verb>

<p>
This is matching the final position (after last move in game); see also
<cql>position:final</cql>.
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> end-3)
</verb>

<p>
Will match the third from last half move in the game, this means three
half move will follow.
</p>

<verb>
(position <keyword>position:halfmovenumber</keyword> end-1 <cql>position:moveto</cql> &U;)
</verb>

<p>
Match all games where a piece will be captured in the last move of the game.
This is simpler and more efficient than this equivalent notation:
</p>

<verbatim>
(position <cql>position:sequence</cql> (
  (position <cql>position:moveto</cql> &U;)
  (position <cql>position:final</cql>))
</verbatim>

<annotation>
The use of <cql>:halfmovenumber</cql> may reduce the search time considerably.
</annotation>

<p>
See also: <cql>position:initial</cql>, <cql>position:final</cql>,
<cql>position:movenumber</cql>.
</p>

<h3 id="position:iscastling">:iscastling<extension/></h3>

<p>
The next move is a castling move.
As an optional argument the piece designators &K;, &k;, &Q;, and &q; will
specify the castling more exactly.
</p>

<p>
Examples:
</p>

<verb>
  <keyword>position:iscastling</keyword> <comment>; side to move is castling</comment>
</verb>
<verb>
  <keyword>position:iscastling</keyword> &K; <comment>; White is castling short</comment>
</verb>
<verb>
  <keyword>position:iscastling</keyword> [&K;&Q;] <comment>; White is castling</comment>
</verb>
<verb>
  <keyword>position:iscastling</keyword> [&Q;&q;] <comment>; side to move is castling long</comment>
</verb>

<p>
See also: <cql>position:castling</cql>, <cql>position:nocastling</cql>.
</p>

<h3 id="position:ischeck">:ischeck<extension/>&emsp;<n>(Schachgebot?)</n></h3>

<p>
Filtert eine Position, wenn der nächste Zug ein Schachgebot ist. Ist als Argument
eine <a href="CQL-Range-Specifiers.html">Bereichsangabe</a> vorhanden, dann wird
eine Position gefiltert, wenn der nächste Zug ein Schachgebot ist, und die Anzahl
der Schachgebote, die die Seite am Zug dem Gegner bot, einschließlich des
nächsten Zugs, innerhalb dieser Bereichsangabe liegt. Die untere Schranke dieser
Bereichsangabe kann nicht kleiner als 1 sein.
</p>

<note>
<cql>:ischeck</cql> mit nachfolgender Bereichsangabe ist in erster Linie nützlich
in der Schachform %::mc::VariantName(ThreeCheck)%. Das nachfolgende Beispiel gilt
für diese Schachform.
</note>

<verb>
(position <keyword>position:ischeck</keyword> 3)
</verb>

<p>
Die Seite am Zug bietet nun zum dritten Mal in der Partie dem Gegner
Schach. Dies kann nur eine Endstellung sein (in %::mc::VariantName(ThreeCheck)%).
</p>

<verb>
(position
  <cql>position:matchcount</cql> 1
  <keyword>position:ischeck</keyword>)
</verb>

<p>
Das einzige Schachgebot in der Partie überhaupt.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:ischeck</keyword>)
</verb>

<p>
Der nächste Zug ist kein Schachgebot.
</p>

<p>
Siehe auch: <cql>position:checkcount</cql>,
</p>

<h3 id="position:iscontactcheck">:iscontactcheck<extension/>&emsp;<n>(Kontaktschachgebot?)</n></h3>

<p>
Der nächste Zug ist ein Kontaktschachgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:iscontactcheck</keyword>)
</verb>

<p>
Der nächste Zug ist kein Kontaktschachgebot (aber trotzdem möglicherweise
ein Schachgebot).
</p>

<p>
Siehe auch: <cql>position:contactcheck</cql>,
</p>

<h3 id="position:isdoublecheck">:isdoublecheck<extension/>&emsp;<n>(Doppelschachgebot?)</n></h3>

<p>
Der nächste Zug ist ein Doppelschachgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isdoublecheck</keyword>)
</verb>

<p>
Der nächste Zug ist kein Doppelschachgebot (aber trotzdem möglicherweise
ein Schachgebot).
</p>

<p>
Siehe auch: <cql>position:doublecheck</cql>,
</p>

<h3 id="position:isillegal">:isillegal<extension/>&emsp;<n>(Regelwidrig?)</n></h3>

<p>
Der nächste Zug ist ein regelwidriger Zug, beispielsweise eine Rochade, obwohl der
König im Schach steht.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isillegal</keyword>)
</verb>

<p>
Der nächste ZUg ist kein regelwidriger Zug.
</p>

<h3 id="position:isinvalid">:isinvalid<extension/>&emsp;<n>(Unerlaubt?)</n></h3>

<p>
Der nächste Zug ist ein unerlaubter Zug, beispielsweise ein Läuferzug, der auf einem
schwarzen Feld beginnt, aber auf einem weißen Feld endet (dies unterstützt den
Kinderschachmodus).
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isinvalid</keyword>)
</verb>

<p>
Der nächste ZUg ist kein unerlaubter Zug.
</p>

<h3 id="position:ismate">:ismate<extension/>&emsp;<n>(Mattgebot?)</n></h3>

<p>
Der nächste Zug ist ein Mattgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:ismate</keyword>)
</verb>

<p>
Der nächste Zug ist kein Mattgebot.
</p>

<p>
Siehe auch: <cql>position:mate</cql>,
</p>

<h3 id="position:isnull">:isnull<extension/>&emsp;<n>(Nullzug?)</n></h3>

<p>
Der nächste Zug ist ein Nullzug.
</p>

<verb>
(position <keyword>position:isnull</keyword>)
</verb>

<p>
Suche nach Partien die einen Nullzug enthalten.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isnull</keyword>)
</verb>

<p>
Filtere alle Positionen, in denen kein Nullzug erfolgt.
</p>

<h3 id="position:isstalemate">:isstalemate&emsp;<n>(Pattgebot?)</n></h3>

<p>
Der nächste Zug ist ein Pattgebot.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:isstalemate</keyword>)
</verb>

<p>
Der nächste Zug ist kein Pattgebot.
</p>

<p>
Siehe auch: <cql>position:stalemate</cql>,
</p>

<h3 id="position:movefrom">:movefrom</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose from
designator matches that piece designator.
</p>

<p>
Examples:
</p>

<verb>
<keyword>position:movefrom</keyword> &R;a3
</verb>

<p>
Will match a position in which the next move is of a white rook on a3.
</p>

<verb>
(position <keyword>position:movefrom</keyword> &U;?8)
</verb>

<p>
Will match a position in which the next move is of some piece on the 8th rank.
</p>

<verb>
(position <keyword>position:movefrom</keyword> &Q;[+] <cql>position:moveto</cql> .?8)
</verb>

<p>
A white queen will be dropped on Black's back rank.
(%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%).
</p>

<verb>
(position <keyword>position:movefrom</keyword> ???)
</verb>

<p>
This expression is useful in %::mc::VariantName(DropChess)%, and %::mc::VariantName(Bughouse)%:
in this position no piece (from backhand) will be dropped.
</p>

<verb>
(position <keyword>position:movefrom</keyword> .)
</verb>

<p>
This can never match, even a piece drop move
(%::mc::VariantName(DropChess)%, %::mc::VariantName(Bughouse)%)
will not match.
</p>

<p>
See also: <cql>position:line</cql>, <cql>position:moveto</cql>,
<cql>position:null</cql>, <cql>position:promote</cql>.
</p>

<h3 id="position:movenumber">:movenumber</h3>

<p>
<cql>:movenumber</cql> takes a
<a href="CQL-Range-Specifiers.html">range specifier</a> as parameter and
matches positions only if the current move number is within the specified
range. The move number computation assumes white moves first.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:movenumber</keyword> 10 20 <cql>position:check</cql>)
</verb>

<p>
Will match a position in which there is a check between moves 10 and 20.
</p>

<verb>
(position <keyword>position:movenumber</keyword> 35 <cql>position:mate</cql>)
</verb>

<p>
Will match a position in which move 35 is mate.
</p>

<p>
As an extension (to the CQL standard) also <expr>end</expr>, or
<nobr><expr>end</expr>&minus;N</nobr> can be used as an argument for
the range.
But the behaviour is undefined when the search inside sub-variations is
switched on (<see/> <cql>position:variations</cql>), this means that this
extension shouldn't be used in such cases.
Two examples:
</p>

<verb>
(position <keyword>position:movenumber</keyword> end)
</verb>

<p>
This denotes the final position (after last move in game); see also
<cql>position:final</cql>.
</p>

<verb>
(position <keyword>position:movenumber</keyword> end-3)
</verb>

<p>
This denotes the third to last move in the game (do not confuse this
with half moves; see siehe <cql>position:halfmovenumber</cql>).
</p>

<verb>
(position <keyword>position:movenumber</keyword> end-4 end-3)
</verb>

<p>
This denotes the range from fourth to last until third to last move
in the game.
</p>

<p>
See also: <cql>position:halfmovenumber</cql>, <cql>position:initial</cql>,
<cql>position:final</cql>.
</p>

<h3 id="position:moveto">:moveto</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose
destination designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:moveto</keyword> &U;)
</verb>

<p>
Is matching a position where next move is a capture move.
</p>

<verb>
(position <keyword>position:moveto</keyword> .)
</verb>

<p>
Is matching a position where next move is not a capture move.
</p>

<verb>
(position <keyword>position:moveto</keyword> &U;~)
</verb>

<p>
Next move is capturing a promotion piece.
</p>

<verb>
(position <keyword>position:moveto</keyword> &U;~~)
</verb>

<p>
Next move is capturing a piece which is not the result of a pawn promotion.
</p>

<verb>
(position <keyword>position:moveto</keyword> &R;[b1-8])
</verb>

<p>
Will match a position in which the next move is to capture a white rook on
the b file. Note that this is quite different from the natural
<a href="http://de.wikipedia.org/wiki/Portable_Game_Notation">PGN</a>
interpration of its being a move of a white rook to the b file. That
would be done via:
</p>

<verb>
(position <cql>position:movefrom</cql> &R; <keyword>position:moveto</keyword> ?b?)
</verb>

<p>
Will match a move of the white rook to the b file.
This excludes a rook from backhand (%::mc::VariantName(DropChess)%,
and %::mc::VariantName(Bughouse)%). If a piece from backhand should
be included, we need an extended definition:
</p>

<verb>
(position <cql>position:movefrom</cql> &R;[*] <keyword>position:moveto</keyword> ?b?)
</verb>

<verb>
(position <keyword>position:moveto</keyword> &R;[b1-8])
</verb>

<p>
In next case we will handle an en passant capture:
</p>

<verb>
(position <keyword>position:moveto</keyword> .e6 <cql>position:enpassant</cql>)
</verb>

<p>
A pawn on e5 will be captured en passant.
</p>

<p>
See also: <cql>position:line</cql>, <cql>position:movefrom</cql>,
<cql>position:null</cql>, <cql>position:promote</cql>.
</p>

<h3 id="position:noenpassant">:noenpassant</h3>

<p>
The next move is not an en-passant capture.
</p>

<p>
See also: <cql>position:enpassant</cql>.
</p>

<h3 id="position:promote">:promote</h3>

<p>
Takes a single parameter, a piece designator. It matches a move if that move
is a promotion whose promotion designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>position:promote</keyword> [&R;&B;&N;])
</verb>

<p>
Will match a position whose next move is a white underpromotion.
</p>

<verb>
(position <keyword>position:promote</keyword> [&B;&N;]a8)
</verb>

<p>
Will match a position whose next move is a white promotion to bishop or knight.
</p>

<verb>
(position <keyword>position:promote</keyword> &R;e8
<cql>position:movefrom</cql> &P;f7 <cql>position:moveto</cql> &q;)
</verb>

<p>
Will match a position in which the next move is of a pawn on f7 capturing a black
queen on e8 and promoting to a rook.
</p>

<verb>
(position <keyword>position:promote</keyword> [])
</verb>

<p>
Will match a position in which the next move is not a promotion (because the
piecetype designator is empty).
</p>

<p>
See also: <cql>position:line</cql>, <cql>position:movefrom</cql>,
<cql>position:moveto</cql>, <cql>position:null</cql>.
</p>

<h3 id="position:takeslastpiece">:takeslastpiece<extension/>&emsp;<n>(Schlägt die letzte Figur)</n></h3>

<p>
Dieses Schlüsselwort hat nur in der Schachform %::mc::VariantName(Antichess)% eine Bedeutung,
und kann in anderen Schachformen niemals erfüllt werden. Es wird erfüllt, wenn im nächsten
Zug die letzte gegnerische Figur geschlagen wird.
</p>

<p>
Dieses Schlüsselwort kann auch in negierter Form &ndash; mit einem vorangestellten
Ausrufungszeichen &ndash; verwendet werden. Beispiel:
</p>

<verb>
(position <keyword>!position:takeslastpiece</keyword>)
</verb>

<p>
In der Schachformen %::mc::VariantName(Antichess)% wird es erfüllt, wenn im nächsten
Zug nicht die letzte gegnerische Figur geschlagen wird. In anderen Schachformen
wird diese Bedingung immer erfüllt.
</p>

<p>
Siehe auch: <cql>position:losing</cql>,
</p>

<!-- ############################################################################## -->
<h2 id="sequence">Sequence keywords</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:line">:line</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:line_">:line*</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:match">:match</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:matchconsecutive">:matchconsecutive</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:sequence">:sequence</a></td></tr>
</table>

<h3 id="position:gappedsequence">:gappedsequence</h3>

<p>
Takes one argument, a list of position lists. A position list A is said to be
a refinement of a position list B if A may be formed from B by inserting zero or
more position lists of the form <expr>(position)</expr> into the top level of B.
For example:
</p>

<verb>
((position &N;a4) (position) (position &R;b2))
</verb>

<p>
refines
</p>

<verb>
((position &N;a4) (position &R;b2))
</verb>

<p>
because it was formed by inserting a single position list into the latter list.
</p>

<p>
A <cql>:gappedsequence</cql> with argument B will match a position if and only if
there is a refinement A of B such that a <cql>position:sequence</cql> with
argument A would match that position. That is, <cql>:gappedsequence</cql> is
like <cql>position:sequence</cql> except that the sequence of matching positions
may include intervening positions from the game.
</p>

<p>
Examples:
</p>

<verbatim>
(position
  <keyword>position:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
This will match any position for which the positions that occur successively
in the game starting with that position comprise zero or more positions,
followed by a position from which a white rook on a3 moves, followed by zero
or more positions, followed by a position from which a white rook on b4 moves.
</p>

<p>
Standard CQL has the following limitation:
The total number of <cql>position:sequence</cql> and <cql>:gappedsequence</cql>
position lists that can occur at the top level of a position list cannot exceed
one. To get the effect of either a <cql>:gappedequence</cql> and
<cql>position:sequence</cql> keywords in one position list, use <cql>position:and</cql>.
But CQL-S does not have any limitations with the use of <cql>position:sequence</cql>
and <cql>:gappedsequence</cql>.
</p>

<h3 id="position:line">:line<extension/></h3>

<p>
The argument is a string which contains a valid line. The long algebraic
notation has to be used. It is allowed to use piece and square designators.
Note that a pawn move will be assumed if the piece of the from square is
not specified. Furthermore check and mate signs can be used. Moreover
a pawn move may be designated as an en-passant move. Optional move numbers
will be considered when searching, the move numbers have to be strictly
ascending. Examples:
</p>

<table class="stripes" style="white-space: nowrap;">
  <tr valign="top" class="stripes">
    <td class="left">e2-e4</td>
    <td class="right">White pawn moves from e2 to e4.</td>
  </tr>
  <tr valign="top">
    <td class="left">1.e2-e4</td>
    <td class="right">In first move of the game a white pawn moves from e2 to e4.</td>
  </tr>
  <tr valign="top" class="stripes">
    <td class="left">1...e7-e5</td>
    <td class="right">In first move of the game a black pawn moves from e7 to e5.</td>
  </tr>
  <tr valign="top">
    <td class="left">e2-Ne4</td>
    <td class="right">This is an invalid move and will be rejected as an error.</td>
  </tr>
  <tr valign="top" class="stripes">
    <td class="left">d5xe6 e.p.</td>
    <td class="right">White pawn on d5 is capturing the pawn on e5 en-passant.</td>
  </tr>
  <tr valign="top">
    <td class="left">d5xe6</td>
    <td class="right">White pawn on d5 is capturing a pawn on e6<br/>
      (en-passant is precluded in this case).</td>
  </tr>
  <tr valign="top" class="stripes">
    <td class="left">&N;b1-[ac]3</td>
    <td class="right">White knight moves from b1 to a3 or to c3.</td>
  </tr>
  <tr valign="top">
    <td class="left">&B;[bg]7x&i;?8</td>
    <td class="right">White bishop on b7 oder g7 is capturing a black<br/>
      major piece on eighth rank.</td>
  </tr>
  <tr valign="top" class="stripes">
    <td class="left">&M;?[1-7]-?8+</td>
    <td class="right">White major piece moves to blacks back rank and
      gives check to black king.</td>
  </tr>
  <tr valign="top">
    <td class="left">&N;??-f7++</td>
    <td class="right">White knight moves to square f7 and gives double
      check to black king.</td>
  </tr>
  <tr valign="top" class="stripes">
    <td class="left">&N;??-f7#</td>
    <td class="right">White knight moves to square f7 and checkmates.</td>
  </tr>
</table>

<p>
This keywords serves for a simpler notation of move sequences. Therefore the
position list
</p>

<verbatim>
(position <keyword>position:line</keyword> "e2-e4 e7-e6 d2-d4 d7-d5")
</verbatim>

<p>
is identical to the following sequenc:
</p>

<verbatim>
(position <cql>position:sequence</cql> (
  (position <cql>position:movefrom</cql> Pe2 <cql>position:moveto</cql> e4)
  (position <cql>position:movefrom</cql> pe7 <cql>position:moveto</cql> e6)
  (position <cql>position:movefrom</cql> Pd2 <cql>position:moveto</cql> d4)
  (position <cql>position:movefrom</cql> pd7 <cql>position:moveto</cql> d5)))
</verbatim>

<p>
The special letter <code>*</code> at the end of the string is denoting
a transposition invariant search, and the search will start automatically
with the first move in the current start position. Moreover possible en passant
rights will be ignored. Example:
</p>

<verbatim>
(position <keyword>position:line</keyword> "e2-e4 e7-e6 d2-d4 d7-d5 *")
</verbatim>

<p>
Match all positions starting with French, inclusive move transpositions
like "d2-d4 d7-d5 e2-e4 e7-e6". In games with a normal start position
(position 518 in Chess960) this equivalent to the following query:
</p>

<verbatim>
(position
  <cql>position:fen</cql> "rnbqkbnr/pppp1ppp/4p3/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2")
</verbatim>

<p>
If the exact opening line "e2-e4 e7-e6 d2-d4 d7-d5" should be found, the
following query has to be used:
</p>

<verbatim>
(position <keyword>position:line</keyword> "1.e2-e4 e7-e6 2.d2-d4 d7-d5")
</verbatim>

<p>
See also: <cql>position:fen</cql>, <cql>position:sequence</cql>.
</p>

<h3 id="position:line_">:line*<extension/>&emsp;<n>(Transpositionsinvariante Zugfolge)</n></h3>

<p>
Diese Version von <cql>position:line</cql> prüft Zugsequenzen
transpositionsinvariant, und die Suche beginnt deshalb immer mit dem ersten
Zug in der vorliegenden Grundstellung. Es können optional Zugnummern verwendet
werden, sie sind jedoch hier nicht erforderlich.  Eine transpositionsinvariante
Suche ist jedoch nur möglich wenn alle Züge eindeutig bestimmt sind (eindeutiges
Herkunftsfeld, eindeutiges Zielfeld, eindeutige Figuren, eindeutige
Bauernumwandlung). Dies ist erforderlich damit beispielsweise auch
Schach-960-Positionen korrekt geprüft werden. Weiterhin wird bei der
transpositionsinvarianten Suche ein mögliches en-passant-Recht ignoriert.
Transformierende Schlüsselwörter (<cql>position:flip</cql>,
<cql>position:flipcolor</cql>, &hellip;) sind in Verbindung mit
Transpositionsinvarianz nicht erlaubt.
</p>

<p>
Auch sind bei einer transpositionsinvarianten Suche die Angaben von Schach,
Doppelschach und Kontaktschach nicht erlaubt, außer im letzten Halbzug.
Solche Angaben im letzten Zug schränken im allgemeinen die möglichen
Transpositionen ein.
</p>

<p>
Potentielle Zugfolgen wie bei <cql>:line</cql> sind hier nicht erlaubt.
</p>

<p>
Beispiele:
</p>

<box>
  <dl>
    <dt><expr>(e2-e4 d7-d5)</expr></dt>
    <dd>
      Dies ist eine fehlerhafter Ausdruck, die Figuren sind nicht eindeutig
      bestimmt.
    </dd>
    <dt style="margin-top:10px"><expr>(&P;e2-e4 &P;d7-d5)</expr></dt>
    <dd>
      Dies ist eine korrekter Ausdruck (die Figurenfarbe wird durch die
      Halbzugposition eindeutig bestimmt).
    </dd>
    <dt style="margin-top:10px"><expr>(&P;e2-e4 &p;d7-d5)</expr></dt>
    <dd>
      Ebenfalls ein korrekter Ausdruck.
    </dd>
    <dt style="margin-top:10px"><expr>(&P;e2-e4 &p;d7-d5 &P;e4xd5)</expr></dt>
    <dd>
      Inkorrekt, denn die geschlagene Figur ist nicht eindeutig.
    </dd>
    <dt style="margin-top:10px"><expr>(&P;e2-e4 &p;d7-d5 &P;e4x&P;d5)</expr></dt>
    <dd>
      Korrekt, alles ist eindeutig bestimmt.
    </dd>
    <dt style="margin-top:10px"><expr>(&P;e2-e?)</expr></dt>
    <dd>
      Inkorrekt, denn das Zielfeld ist nicht eindeutig.
    </dd>
    <dt style="margin-top:10px"><expr>(&P;e2-e4 &P;f7-f6 &Q;d1-h5+ &P;g7-g6)</expr></dt>
    <dd>
      Inkorrekt, denn ein Schachgebot darf hier nicht notiert werden.
    </dd>
    <dt style="margin-top:10px"><expr>(&P;e2-e4 &P;f7-f6 &Q;d1-h5+)</expr></dt>
    <dd>
      Korrekt, ein Schachgebot im letzten Halbzug ist zulässig,
    </dd>
  </dl>
</box>

<p>
Weitere Beispiele:
</p>

<verbatim>
(position <keyword>position:line*</keyword> (1.&P;e2-e4 &P;e7-e6 2.&P;d2-d4 &P;d7-d5))
</verbatim>

<p>
Filtere alle Stellungen die mit Französisch beginnen, inklusive Zugumstellungen
wie 1.d4 d5 2.e4 e6. Dies ist äquivalent zur folgenden
Abfrage:
</p>

<verbatim>
(position
  <cql>position:fen</cql> "rnbqkbnr/pppp1ppp/4p3/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2")
</verbatim>

<p>
Wird die exakte Eröffnungszugfolge 1.e4 e6 2.d4 d5 gesucht,
so geschieht dies mit:
</p>

<verbatim>
(position <cql>position:line</cql> (1.&P;e2-e4 &P;e7-e6 2.&P;d2-d4 &P;d7-d5))
</verbatim>

<p>
Siehe auch:
<cql>position:fen</cql>,
<cql>position:line</cql>,
</p>

<h3 id="position:match">:match<extension/>&emsp;<n>(Suchfolge)</n></h3>

<p>
Dies entspricht genau dem Verhalten der Suchliste <expr>(match</expr>
<expr>...)</expr>, nur daß hier ausnahmslos Positionslisten als Argumente
erwartet werden. Somit wird dieses Schlüsselwort normalerweise nicht
benötigt, es kann jedoch von Nutzen sein, wenn es als Argument für eines der
logischen Schlüsselwörter dient. Ein formales Beispiel:
</p>

<verbatim>
(match
  (position
    <cql>position:and</cql> (
      (position ...)
      (position <cql>position:match</cql> (
        (position ...)
        (position ...)
        ...
        (position ...))))))
</verbatim>

<h3 id="position:matchconsecutive">:matchconsecutive<extension/>&emsp;<n>(Sukzessive Suchfolge)</n></h3>

<p>
Diese Variante der Suchfolge filtert genau dann eine Partie, wenn alle Positionen
dieser Suchfolge nacheinander aufgefunden werden, jedoch unabhängig von der Reihenfolge.
</p>

<p>
Beispiel:
</p>

<verbatim>
(match
  (position
    <cql>position:flipcolor</cql>
    <keyword>position:matchconsecutive</keyword> (
      (position <cql>position:promote</cql> &B;)
      (position)
      (position <cql>position:promote</cql> &N;))))
</verbatim>

<p>
Filtert alle Partien, in denen nacheinander eine der Parteien eine
Bauernumwandlung in zwei verschiedene Leichtfiguren ausführt.
</p>

<h3 id="position:sequence">:sequence</h3>

<p>
Takes a single argument that is a list of position lists. It will match a given
position if and only successive occurring positions, beginning with the
current position, match each corresponding element in its argument.
</p>

<p>
Example:
</p>

<verbatim>
(position
  &R;e8
  <keyword>position:sequence</keyword> (
    (position &Q;f3 .g2)
    (position .f3 &Q;g2)))
</verbatim>

<p>
This position list will match exactly those positions with a white rook on e8
such that:
</p>

<ol>
  <li>In that position, white has a queen on f3 and g2 is empty, and</li>
  <li>After the next move, f3 is empty and there is a white queen on g2.</li>
</ol>

<p>
In consequence, this position list is identical in effect to
</p>

<verb>
(position &R;e8 <cql>position:movefrom</cql> &Q;f3 <cql>position:moveto</cql> .g2)
</verb>

<p>
Furthermore this is identical to:
</p>

<verb>
(position &R;e8 <cql>position:line</cql> "&Q;f3-g2")
</verb>

<p>
The following more typical usage of <cql>:sequence</cql> will search for all
queen staircase checking maneuvers by either side:
</p>

<verbatim>
(position
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <keyword>position:sequence</keyword> (
    (position <cql>position:movefrom</cql> &Q;a2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c4)
    (position <cql>position:check</cql>)))
</verbatim>

<p>
This position list will match any position with a white queen on a2 for which
there are successively moves by queens on the indicated squares giving check;
the <cql>position:shift</cql>, <cql>position:flip</cql>, and
<cql>position:flipcolor</cql> search for this variation reflected or
rotated anywhere on the board. But this can be expressed much simpler:
</p>

<verbatim>
(position
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <cql>position:line</cql> "&Q;a2-b2+ &Q;b2-b3+ &Q;b3-c3+ &Q;c3-c4+")
</verbatim>

<p>
See also: <cql>position:line</cql>.
</p>

<!-- ############################################################################## -->
<h2 id="game">Game related keywords</h2>
<!-- ############################################################################## -->

<p>
Several keywords relate to the game parameters and are not affected by the
contents of the position; they are included as position list keywords instead
of match list keywords so the <cql>position:flipcolor</cql> can be used with
them. these are:
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:elo">:elo</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:ischess960">:ischess960</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:isshufflechess">:isshufflechess</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:result">:result</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:startposition">:startposition</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:variant">:variant</a></td></tr>
</table>

<h3 id="position:blackelo">:blackelo</h3>

<p>
This keyword takes a <a href="CQL-Range-Specifiers.html">range specifier</a>;
the ELO of the black player must lie within its range. One special case:
</p>

<verb>
<keyword>match:blackelo</keyword> 0
</verb>

<p>
In this case all games will match whose black player does not have an ELO rating.
</p>

<p>
See also: <cql>position:whiteelo</cql>, <cql>position:blackrating</cql>,
<cql>position:whiterating</cql>.
</p>

<h3 id="position:elo">:elo</h3>

<p>
This keyword is supported only due to compatibility reasons with the CQL standard.
It is recommended to use instead the identically named keyword
<cql>match:elo</cql> in the match list. For a description also see
<cql>match:elo</cql>.
</p>

<h3 id="match:ischess960">:ischess960<extension/></h3>

<p>
Matches all games starting with a Chess960 Position. This includes the standard start
position 518.
</p>

<p>
See also: <cql>match:ischess960</cql>, <cql>position:isshufflechess</cql>.
</p>

<h3 id="match:isshufflechess">:isshufflechess<extension/></h3>

<p>
Matches all games starting with a Shuffle Chess Position. This includes all Chess960
positions.
</p>

<p>
See also: <cql>match:isshufflechess</cql>, <cql>position:ischess960</cql>.
</p>

<h3 id="position:result">:result</h3>

<p>
This keyword is deprecated and will be supported only for compatibility
reasons to CQL 1.0 (because <nobr>CQL-S</nobr> provides
<cql>match:eithercolor</cql> as an extension of <cql>position:flipcolor</cql>).
</p>

<p>
This keyword takes one argument, the same as the argument to
<cql>match:result (match)</cql> in a match list. Inside a position
list it will be affected by <cql>position:flipcolor</cql>.
</p>

<p>
Example:
</p>

<verbatim>
(match (
  (position
    <keyword>position:result</keyword> 1-0
    <cql>position:whiteelo</cql> 0 2300
    <cql>position:blackelo</cql> &gt;=2600
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
Searches for games in which a 2300 player or below defeated a 2600 player
or above.
</p>

<h3 id="match:startposition">:startposition<extension/></h3>

<p>
This will take a comma-separated list of start positions. A start
position is either a position number, or a FICS variant identifier.
For a detailed description see <cql>match:startposition</cql>.
</p>

<p>
See also: <cql>position:ischess960</cql>, <cql>position:isshufflechess</cql>.
</p>

<h3 id="position:variant">:variant</h3>

<p>
For a description see identically named keyword <cql>match:variant (match)</cql>
in match list. This keyword is added for the possibility to distinguish between
different <a href="Chess-Variants.html">chess variants</a> in each position list.
</p>

<h3 id="position:whiteelo">:whiteelo</h3>

<p>
This keyword takes a <a href="CQL-Range-Specifiers.html">range specifier</a>;
the ELO of the white player must lie within its range. One special case:
</p>

<verb>
<keyword>match:whiteelo</keyword> 0
</verb>

<p>
In this case all games will match whose white player does not have an ELO rating.
</p>

<p>
See also: <cql>position:blackelo</cql>, <cql>position:blackrating</cql>,
<cql>position:whiterating</cql>.
</p>

<!-- ############################################################################## -->
<h2 id="relation">Relation between positions</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:relation">:relation</a></td></tr>
</table>

<h3 id="position:relation">:relation</h3>

<p>
Takes one argument, a relation specification. is used to search for games with
pairs of positions P1 and P2 that satisfy certain properties. See
<a href="CQL-Relation-List.html">relation list</a> for a desription of
the relation specification keywords.
</p>

<!-- ############################################################################## -->
<h2 id="matching">Matching count keywords</h2>
<!-- ############################################################################## -->

<p>
Two keywords pertain to the number of positions which a position list matches.
These each take a <a href="CQL-Range-Specifiers.html">range specifier</a>
as parameter. They can only be used in a position list at the top level of a
match list.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:pretransformrepetitioncount">:pretransformrepetitioncount</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:repetitioncount">:repetitioncount</a></td></tr>
</table>

<h3 id="position:checkcount">:checkcount<extension/></h3>

<p>
If the parameter is a single number (not less that zero), it is
matching all positions where last move is giving n-th check to other side.
</p>

<p>
If the parameter has the form <expr>+&lt;n<sub>1</sub>&gt;+&lt;n<sub>2</sub>&gt;</expr>,
where <expr>&lt;n<sub>i</sub>&gt;</expr> is a number not less than zero,
it is matching first position where white has given n<sub>1</sub> times check
to black, and black has given n<sub>2</sub> times check to white.
</p>

<note>
This query is working only in chess variant %::mc::VariantName(ThreeCheck)%,
in other chess variants it fails always (except all values in given parameter
are zero).
</note>

<p>
Examples:
</p>

<verb>
(position <keyword>position:checkcount</keyword> 2)
</verb>

<p>
Match as soon as any side has given second check.
</p>

<verb>
(position <keyword>position:checkcount</keyword> +0+3)
</verb>

<p>
Match if black has given third check to white king. This must be a final
position.
</p>

<verb>
(position <cql>position:not</cql> <keyword>position:checkcount</keyword> +0+0)
</verb>

<p>
This is in fact a useful query. Assume that a game is starting with the
following position (described with
<a href="FEN.html">Forsyth-Edwards Notation</a>):
</p>

<dir><code>
rnb1k1nr/pppp1ppp/8/4p3/3PP2q/2N5/PP3PPP/R1BQKBNR w KQkq - 1 5 +0+2
</code></dir>

<p>
This game would match (note keyword <cql>:not</cql>), because black has already
given second check to white king. With other words, this query is searching for
games starting with an advanced position, where one side has already given a
check.
</p>

<h3 id="position:matchcount">:matchcount</h3>

<p>
Will match if and only if the number of times this position list matches a
position in the current game lies within the
<a href="CQL-Range-Specifiers.html">range specifier</a>.
</p>

<p>
Example:
</p>

<verb>
(position <cql>position:moveto</cql> [&Q;&q;] <keyword>position:matchcount</keyword> &gt;=4)
</verb>

<p>
Will match any game in which at least four queen captures have occurred.
</p>

<h3 id="position:pretransformmatchcount">:pretransformmatchcount</h3>

<p>
Has the same syntax as <cql>position:matchcount</cql>. For a description
of this keyword we will suppose the following general form of a position
list:
</p>

<verbatim>
(position
  T<sub>1</sub> T<sub>2</sub> ... T<sub>k</sub>
  X<sub>1</sub> X<sub>2</sub> ... X<sub>n</sub>
  <keyword>position:pretransformmatchcount</keyword> n<sub>1</sub> n<sub>2</sub>)
</verbatim>

<p>
All <expr>T<sub>i</sub></expr> are denoting the transformation keywords,
and all other elements (but no transformation keywords) are denoted with
<expr>X<sub>i</sub></expr>. <expr>n<sub>1</sub></expr>
<expr>n<sub>2</sub></expr> is the range specifier. Now we suppose that
<expr>Y<sub>i,j</sub></expr> is denoting an element formed by one
transformation step j applied to <expr>X<sub>i</sub></expr> (possibly
identical to <expr>X<sub>i</sub></expr> because it is
transformation-invariant). <expr>m</expr> denotes the total count of all
transformation steps. Now we will form a new position list:
</p>

<verbatim>
(position
  <cql>position:or</cql> (
    (position Y<sub>1,1</sub> Y<sub>2,1</sub> ... Y<sub>n,1</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    (position Y<sub>1,2</sub> Y<sub>2,2</sub> ... Y<sub>n,2</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    ...
    (position Y<sub>1,m</sub> Y<sub>2,m</sub> ... Y<sub>n,m</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)))
</verbatim>

<p>
The position list containing <cql>:pretransformmatchcount</cql> is matching
exactly those positions matched from our newly formed position list.
With other words: the match count will be performed for each individual
transformation step.
</p>

<p>
Example:
</p>

<verbatim>
(position
  <cql>position:moveto</cql> [Aa]d4
  <keyword>position:pretransformmatchcount</keyword> &gt;=12
  <cql>position:shift</cql>))
</verbatim>

<p>
This would match any game in which at least 12 captures occur on the same
square. Were the <cql>:pretransformmatchcount</cql> replaced by
<cql>position:matchcount</cql>, the position list would match games in which
at least 12 captures occurred anywhere on board.
</p>

<h3 id="position:pretransformrepetitioncount">:pretransformrepetitioncount<extension/>&emsp;<n>(Prä-Transformation-Wiederholungszähler)</n></h3>

<p>
Dieses Schlüsselwort hat die gleiche Syntax wie <cql>position:repetitioncount</cql>,
und ist so zu verstehen wie das ähnliche Schlüsselwort
<cql>position:pretransformmatchcount</cql>, nur daß <cql>:repetitioncount</cql>
aufeinanderfolgende Positionsmerkmale zählt.
</p>

<p>
Beispiel:
</p>

<verbatim>
(position
  <cql>position:moveto</cql> &U;d4
  <keyword>position:pretransformrepetitioncount</keyword> &gt;=6
  <cql>position:shift</cql>)
</verbatim>

<p>
Dies würde jede Partie finden in der mindestens sechs Figuren aufeinanderfolgend
auf dem gleichen Feld geschlagen wurden.
</p>

<h3 id="position:repetitioncount">:repetitioncount<extension/>&emsp;<n>(Wiederholungszähler)</n></h3>

<p>
Filtert eine Position, wenn sich die Positionsmerkmale aufeinanderfolgend wiederholen,
wobei die Anzahl der Wiederholungen durch eine
<a href="CQL-Range-Specifiers.html">Bereichsangabe</a> spezifiziert wird.
</p>

<p>
Beispiele:
</p>

<verb>
(position <cql>position:moveto</cql> &U; <keyword>position:repetitioncount</keyword> &gt;=10)
</verb>

<p>
Filtert jede Position, in der aufeinanderfolgend mindestens zehn Figuren geschlagen werden.
</p>

<verb>
(position <cql>position:moveto</cql> &U; <keyword>position:repetitioncount</keyword> 0)
</verb>

<p>
Filtert jede Partie, in der niemals eine Figur geschlagen wird. Jedoch ist es günstiger,
dies so zu formulieren:
</p>

<verb>
(position <cql>position:moveto</cql> &U; <cql>position:matchcount</cql> 0)
</verb>

<!-- ############################################################################## -->
<h2 id="evaluation">Analyzing keywords</h2>
<!-- ############################################################################## -->

<p>
The following keywords are analyzing positions. <cql>position:evaluation</cql> and
<cql>position:moveevaluation</cql> should be used with care, these are very slow
operations. In some cases the keywords <cql>position:exchangeevaluation</cql> and
<cql>position:maxswapevaluation</cql> might be an alternative, these functions are
quite faster, although fairly time consuming.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:endgameevaluation">:endgameevaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:endgameevaluation_">:endgameevaluation*</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td></tr>
</table>

<h3 id="position:endgameevaluation">:endgameevaluation<extension/>&emsp;<n>(Endspielbewertung)</n></h3>

<p>
Dieses Schlüsselwort bewertet die aktuelle Endspielposition mit Hilfe von
Endspieltabellen (Tablebases). Dieses Schlüsselwort kann nur dann erfüllt
werden, wenn die entsprechenden Endspieltabellen lokal vorliegen (es erfolgt
keine Online-Abfrage).
</p>

<p>
Als erstes Argument wird spezifiziert, welches Ergebnis laut Endspieltabellen
bei bestem Spiel erzielt wird:
</p>

<box>
  <table>
    <tr>
      <td class="l"><expr>remis</expr></td><td class="r">Das Endspiel ist remis.</td>
    </tr>
    <tr>
      <td class="l"><expr>mate</expr></td><td class="r">Die Seite am Zug kann gewinnen.</td>
    </tr>
    <tr>
      <td class="l"><expr>*mate</expr></td><td class="r">Einer der Parteien kann gewinnen.</td>
    </tr>
    <tr>
      <td class="l"><expr>+mate</expr></td><td class="r">Weiß kann gewinnen.</td>
    </tr>
    <tr>
      <td class="l"><expr>-mate</expr></td><td class="r">Schwarz kann gewinnen.</td>
    </tr>
  </table>
</box>

<p>
Das optionale zweite Argument gibt an, wieviele Halbzüge minimal und maximal
bei beidseitig bestem Spiel erforderlich sind, um Matt zu setzen.
</p>

<p>
Beispiele:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &U; 6
  <cql>position:piececount</cql> &P; 2
  <cql>position:piececount</cql> &p; 2
  <keyword>position:endgameevaluation</keyword> *mate)
</verbatim>

<p>
Filtert alle Positionen mit einem Endspiel <expr>&K;+&P;+&P;</expr> gegen
<expr>&K;+&P;+&P;</expr>, in dem einer der Parteien laut Endspieltabelle gewinnen kann.
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &U; 6
  <cql>position:piececount</cql> &P; 2
  <cql>position:piececount</cql> &p; 2
  <keyword>position:endgameevaluation</keyword> mate &gt;=40)
</verbatim>

<p>
Filtert alle Positionen mit einem Endspiel <expr>&K;+&P;+&P;</expr> gegen
<expr>&K;+&P;+&P;</expr>, in dem die Seite am Zug laut Endspieltabelle gewinnen
kann, aber dafür bei beidseitig bestem Spiel mindestens 40 Halbzüge zum Matt
benötigt.
</p>

<h3 id="position:endgameevaluation_">:endgameevaluation*<extension/>&emsp;<n>(Endspielbewertung)</n></h3>

<p>
Diese Version von <cql>position:endgameevaluation</cql> untersucht nur die Positionen,
in denen die spezifizierte Figurenkonstellation zum ersten Mal in der Partie erfüllt wird.
Somit ist diese Version unter Umständen erheblich schneller in der Suche.
</p>

<h3 id="position:evaluation">:evaluation<extension/></h3>

<annotation>
This is a very slow operation and should be used with restrictions.
</annotation>

<p>
This keyword is evaluating the current position with the help of an
external chess engine. The first two parameter are specifying the
computation mode:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>
  </table>
</dir>

<p>
Now you can either specify a search for mate, or a search for position
evaluation.
</p>

<p>
A search for mate expects one more parameter: namely the word <i>mate</i>.
A query is successful if a mate has been found.
</p>

<p>
The search for position evaluation is expecting three additional parameters.
The first one denotes the lower bound, the second one denotes the upper bound,
both scores are in pawn units. The query succeeds if the evaluation of the
position is within the specified bounds (inclusive the ranges). If the
lower-bound value is specified with <i>unlimited</i>, it means negative
unlimited. If the upper-bound value is specified with <i>unlimited</i>, it
means positive unlimited. The third parameter is either <i>sidetomove</i> or
<i>absolute</i>. <i>sidetomove</i> means that the evaluation value depends on
side to move, and <i>absolute</i> means that the evaluation value is
independent from side to move.
</p>

<note>
Please note that in mode <i>movetime</i> the specification of the milli-seconds
will be rounded up to centi-seconds if the engine is restricted to
<nobr>WinBoard</nobr>/<nobr>XBoard</nobr> protocol. If the UCI
protocol is available then the exact number of milli-seconds will be used.
</note>

<p>
Examples:
</p>

<verb>
<keyword>position:evaluation</keyword> depth 4 &gt;=2.5 sidetomove
</verb>

<p>
Side to move has (probably) a winning position, because he is
at least 2.5 pawn units ahead.
</p>

<verb>
<keyword>position:evaluation</keyword> depth 4 &lt;=-2.5 sidetomove
</verb>

<p>
Side to move has (probably) a losing position, because he is
at least 2.5 pawn units behind.
</p>

<verb>
<keyword>position:evaluation</keyword> movetime 3000 &lt;=-3.0 absolute
</verb>

<p>
Black is (probably) losing, because he is at least 3 pawn units behind.
</p>

<verb>
<keyword>position:evaluation</keyword> depth 6 mate
</verb>

<p>
Either side can be mated in maximal 3 moves (6 plies).
</p>

<h3 id="position:exchangeevaluation">:exchangeevaluation<extension/></h3>

<p>
This keyword is analyzing capture moves to see whether or not they appear
to be profitable.
</p>

<p>
The keyword will match the current move if this value is in the specified range,
a lower and an upper value in pawn units. Only capture moves will be evaluated.
If lower range is specified with <i>unlimited</i>, it means negative unlimited.
If the lower range is specified with <i>unlimited</i>, it means positive unlimited.
The evaluation function is taking into account that pieces may be pinned or
defended by other pieces. The value of the function does not depend on which
side is to move.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<p>
Example:
</p>

<verb>
<keyword>position:exchangeevaluation</keyword> &lt;=-3
</verb>

<p>
This capture move is (probably) a blunder.
</p>

<h3 id="position:maxswapevaluation">:maxswapevaluation<extension/></h3>

<p>
This keyword allows to estimate exchange values of possible moves. It takes
as arguments two piece designators followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. The first argument
specifies moving pieces, the second one specifies target squares. For each
possible moves we compute an integer value that is a material benefit of the
move (in pawns, like in case of the <cql>position:power</cql> keyword)
according to possible piece exchanges on the target square after the move.
After that the maximum of all computed values will be selected.
</p>

<p>
The keyword match the position if this value lies in the specified range
(a lower and an upper value). If lower range is specified with <i>unlimited</i>,
it means negative unlimited. If the lower range is specified with <i>unlimited</i>,
it means positive unlimited. The evaluation function is taking into account that
pieces may be pinned or defended by other pieces. The value of the function does
not depend on which side is to move.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<note>
This keyword is alike the keyword <cql>:maxswapvalue</cql> from Chess
Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
but quite different implemented.
</note>

<p>
Examples:
</p>

<verb>
(position <keyword>position:maxswapevaluation</keyword> &A; &a; &gt;=1)
</verb>

<p>
This query selects positions in which white threatens with
winning some material.
</p>

<verb>
(position <keyword>position:maxswapevaluation</keyword> &Q;?1-7 ??8 &gt;=0)
</verb>

<p>
This query selects positions in which a white queen can invade rank 8
without a material loss.
</p>

<h3 id="position:moveevaluation">:moveevaluation<extension/></h3>

<annotation>
This is a very slow operation and should be used with restrictions.
</annotation>

<p>
This keyword is matching the difference between the evaluation of the current
position and the evaluation of the preceding position. The evaluation will be
done with the help of an external chess engine. It takes seven parameters.
The first and second parameter are piece designators. The former is specifies
moving pieces, the second one specifies target squares. The third and fourth
are specifiying the computation mode:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>
  </table>
</dir>

<p>
The fifth parameter denotes the lower bound score, the sixth parameter denotes
the upper bound score, both scores are in pawns units. If the lower-bound value
is specified with <i>unlimited</i>, it means negative unlimited. If the upper-bound
value is specified with <i>unlimited</i>, it means positive unlimited. The query
succeeds if the scoring of preceding move is within the given bounds (inclusive the
ranges). The score of preceding move is the difference between the score of the
current position minus the score of the preceding position. In case of mating
positions the difference will be always greater than 10,000.
</p>

<p>
The seventh parameter is either <i>sidetomove</i> or <i>absolute</i>.
<i>sidetomove</i> means that the evaluation value depends on side to move, and
<i>absolute</i> means that the evaluation value is independent from side to move.
</p>

<note>
Please note that in mode <i>movetime</i> the specification of the milli-seconds
will be rounded up to centi-seconds if the engine is restricted to
<nobr>WinBoard</nobr>/<nobr>XBoard</nobr> protocol. If the UCI
protocol is available then the exact number of milli-seconds will be used.
</note>

<p>
Examples:
</p>

<verb>
<keyword>position:moveevaluation</keyword> &U; ? depth 4 &gt;=3.0 sidetomove
</verb>

<p>
Match first position were the score difference is at least 3.0 pawn units.
This means that last move was (probably) a blunder.
</p>

<verb>
<keyword>position:moveevaluation</keyword> &A; &a; depth 4 &lt;=-3.0 absolute
</verb>

<p>
Match first position were the evaluation difference is at least 3.0 pawn units
better for black. This means that last white move was (probably) a blunder.
Only capture moves were evaluated.
</p>

<verbatim>
(match
  (position <keyword>position:moveevaluation</keyword> [&P;&p;] ?[?1,?8]
             &lt;=0.0 movetime 5000 absolute)
  (position <cql>position:promotion</cql> &U; <cql>position:cut</cql>)))
  (position <cql>position:preceding</cql>)
</verbatim>

<p>
Search for positions where side to move is doing first promotion in game, but
without gaining a better score. We have ensured that only promoting moves will
be evaluated.
</p>

<!-- ############################################################################## -->
<h2 id="accumulator">Accumulator keywords</h2>
<!-- ############################################################################## -->

<p>
There are mainly two accumulator keywords, <cql>:accumulate</cql> and
<cql>:sumrange</cql>. These are used to accumulate and to test the number of
transforms of the enclosing position list that match the current position. Each
time a transform of a position list matches a position, the accumulator
associated with that position is incremented. Any position with a sum range can
then test if the accumulator is within a certain range.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:accumulate_">:accumulate*</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td></tr>
</table>

<h3 id="position:accumulate">:accumulate</h3>

<p>
This takes one parameter, the name of an accumulator. Each time the application
of some element of the transform set of the position list matches a position,
the accumulator associated with this name is incremented. The accumulator is
cleared when a new position is reached. In consequence <cql>:accumulate</cql>
should not be used inside of <cql>position:not</cql>, or
the <cql>position:sequence</cql> and <cql>position:gappedsequence</cql>
keywords). Note that <cql>position:flipcolor</cql> likely has unexpected
results when used with <cql>:accumulate</cql>, because the accumulator is not
cleared between color flips.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<p>
See also: <cql>position:accumulate*</cql>
</p>

<h3 id="position:accumulate_">:accumulate*<extension/></h3>

<p>
To use the accumulation combined with <cql>position:flipcolor</cql> CQL-S provides
an extension: in the case variant <cql>:accumulate*</cql> is used, each color will be
counted separately.
</p>

<p>
For an example see: <a href="CQL-Examples.html#accumulator#passed-pawn"
>Using accumulators to count passed pawns</a>.
</p>

<p>
See also: <cql>position:accumulate</cql>
</p>

EXCLUDE-BEGIN

<h3 id="position:reset">:reset<extension/></h3>

<p>
This keyword takes as a parameter the name of an accumulator. It clears the
accumulator associated with this name after applying a transformation. If variant
variant <cql>:accumulate*</cql> is used, color flips (by <cql>position:flipcolor</cql>)
will not be reseted.
</p>

<p>
Example:
</p>

<p>
Tripled pawns can be found by the query:
</p>

<verbatim>
(position
  <keyword>position:reset</keyword> acc
  &P;e2
  <cql>position:flipcolor</cql>
  <cql>position:accumulate*</cql> acc
  <cql>position:sumrange</cql> acc 3
  <cql>position:shiftvertical</cql>
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Note that this is only an example for the use of this keyword (taken from
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
it is not recommended to use this statement for triple pawn search.
A much better way is:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;d[2-7] 3 6
  <cql>position:shifthorizontal</cql>
  <cql>position:flipcolor</cql>))
</verbatim>

EXCLUDE-END

<h3 id="position:sumrange">:sumrange<extension/></h3>

<p>
This takes as parameter the name of an accumulator and a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches a position
if the value of the given accumulator lies within the range specifier.
If variant <cql>position:accumulate*</cql> is used, <cql>:sumrange</cql> will
distinguish between colors automatically.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<!-- ############################################################################## -->
<h2 id="tagging">Tagging keywords</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td></tr>
</table>

<h3 id="position:tagmatch">:tagmatch<extension/></h3>

<p>
The <cql>:tagmatch</cql> keyword takes two parameters, the name of a tag and
a piece designator. It matches only if the piece corresponding to the named tag
matches the given piece designator. For more information, see the section
on <a href="CQL-Tagging.html">tagging</a>.
</p>

<!-- ############################################################################## -->
<h2 id="control">Controlling keywords</h2>
<!-- ############################################################################## -->

<p>
With the help of controlling keywords the search flow or search result
will be affected. Actually none of these keywords is extending the capability
of CQL, each of them can be replaced, but the use of these keywords may
improve the search time considerably, and the expression may have a clearer
form.
</p>

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#position:cut">:cut</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:exclude">:exclude</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#position:skip">:skip</a></td></tr>
</table>

<h3 id="position:cut">:cut<extension/></h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
stop position search for this game as soon as the match of the containing position
list succeeds. In latter case: stop position search of this game as soon as the
match of the sub-position list succeeds. This keyword is never failing, with
other words: it is not influencing the result of all other matches.
</p>

<p>
The <cql>:cut</cql> position match has lower precedence than all other
position matches.  This means that a position is matching, if all other
position lists are matching this position, independent from the result of the
<cql>:cut</cql>. If the <cql>:cut</cql> position match should have highest
precedende, use keyword <cql>position:preceding</cql>. In this case the search
will stop with a negative result, independent from all other matches.
Consider the following examples:
</p>

<verb>
(match (position &lt;A&gt; <keyword>position:cut</keyword> (position &lt;B&gt;)))
</verb>

<p>
Suppose &lt;A&gt; and &lt;B&gt; is matching a position, either the first time. In
this case the match of this game succeeds.
</p>

<verb>
(match (position &lt;A&gt; <keyword>position:cut</keyword> (position <cql>position:preceding</cql>  &lt;B&gt;)))
</verb>

<p>
Suppose &lt;A&gt; and &lt;B&gt; is matching a position, either the first time. In
this case the match of this game fails.
</p>

<p>
Examples:
</p>

<verbatim>
(match
  (position
    <cql>position:mate</cql>
    <keyword>position:cut</keyword> (position <cql>position:check</cql>)))
</verbatim>

<p>
Search for games ending with mate, and neither side has ever given
a check before. Actually keyword <cql>:cut</cql> is not required for this
search criterion, see next example:
</p>

<verbatim>
(match
  (position <cql>position:mate</cql>)
  (position <cql>position:check</cql> <cql>position:matchcount</cql> 1))
</verbatim>

<p>
But this version has to search the whole game, and the former version with
<cql>:cut</cql> fails as soon as first check occurs. In complex searches the
use of keyword <cql>:cut</cql> may be much faster than the use of
<cql>:matchcount</cql>.
</p>

<h3 id="position:exclude">:exclude<extension/></h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
exclude this game if the match of the containing position list succeeds.
In latter case exclude this game if the match of the sub-position list
succeeds. This keyword is not influencing the result of the position
match (see example).
</p>

<p>
This keyword will exclude games even if one of the position matches will
succeed before the <cql>:exclude</cql> expression is succeeding. In short:
this keyword is excluding games completely under certain conditions.
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position
    &lt;A&gt;
    <keyword>position:exclude</keyword> (position &lt;B&gt;)))
</verbatim>

<p>
Search for games containg a position which is matching expression
<expr>&lt;A&gt;</expr>, but not if expression <expr>&lt;B&gt;</expr> is
matching any position in this game. Actually this match can be written
without the use of keyword <cql>:exclude</cql>, in the following way:
</p>

<verbatim>
(match
  (position
    <cql>position:and</cql> (
      (position &lt;A&gt;)
      (position &lt;B&gt; <cql>position:matchcount</cql> 0))))
</verbatim>

<p>
But the use of keyword <cql>:exclude</cql> is simpler and clearer.
</p>

<h3 id="position:skip">:skip<extension/></h3>

<p>
With the help of this keyword a matching position can be skipped. This could be
expressed without the use of this keyword, but the formulation of the position
list with the help of this keyword is sometimes less complicated, and this results
often in a faster search.
</p>

<!-- ############################################################################## -->
<h2 id="meaningless">Meaningless keywords</h2>
<!-- ############################################################################## -->

<table style="white-space:nowrap">
  <tr><td>&#x2022;</td><td><a href="#match:markall">:markall</a></td></tr>
  <tr><td>&#x2022;</td><td><a href="#match:noannotate">:noannotate</a></td></tr>
</table>

<h3 id="position:markall">:markall</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in CQL-S.
</p>

<h3 id="position:noannotate">:noannotate</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in CQL-S.
</p>

END

<!-- vi:set ts=2 sw=2 et filetype=html: -->
