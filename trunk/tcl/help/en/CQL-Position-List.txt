<!-- **********************************************************************
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
*********************************************************************** -->

<!-- **********************************************************************
* Copyright: (C) 2013 Gregor Cramer
*********************************************************************** -->

<!-- **********************************************************************
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*********************************************************************** -->

INDEX Position List (CQL)
INDEX CQL Position List

DEFINE <extension/> &ensp;<img src="../images/ft-scidb-tiny.png" />

TITLE CQL - The position list

<p>
The symbol <img src="../images/ft-scidb-tiny.png" /> in the title of a
keyword description denotes that this keyword is an extension, it is not
part of the CQL standard.
</p>

<p>
The keywords <cql>position:castling</cql>, <cql>position:endgame</cql>,
<cql>position:inside</cql>, and <cql>position:reset</cql> are borrowed from
Chess Assistant 9. The description of these keywords are taken from
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#index">Index</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#logical">Logical keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#simple">Simple keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#transform">Transformation keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#piece">Piece configuration keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#move">Move keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#sequence">Sequence keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#game">Game related keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#relation">Relation between positions</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#matching">Matching count keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#evaluation">Analyzing keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#accumulator">Accumulator keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#tagging">Tagging keywords</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#control">Controlling keywords</a></td></tr>
  </table>
</dir>

<h2 id="index">Index</h2>

<dir>
  <table>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:and">:and</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:inside">:inside</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:promote">:promote</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:ray">:ray</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:markall">:markall</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:relation">:relation</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:reset">:reset</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:cut">:cut</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:result">:result</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:moveto">:moveto</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sequence">:sequence</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shift">:shift</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:endmost">:endmost</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:exclude">:exclude</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nolosing">:nolosing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flip">:flip</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:variant">:variant</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:not">:not</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:or">:or</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piececount">:piececount</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:following">:following</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:power">:power</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
    <tr>
    	<td>      &#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:preceding">:preceding</a></td>
    </tr>
  </table>
</dir>

<h2 id="logical">Logical keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:and">:and</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:not">:not</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:or">:or</a></td></tr>
  </table>
</dir>

<h3 id="position:and">:and</h3>

<p>
Takes a list of position lists and matches a position only if each of them
match the position.
</p>

<p>
Example:
</p>

<verbatim>
(position
  <cql>position:wtm</cql>
  <cql>position:check</cql>
  <keyword>:and</keyword> (
    (position &K;e2 &k;g2 <cql>position:shift</cql> <cql>position:flip</cql>)
    (position &N;e2)))
</verbatim>

<p>
Matches positions in which the kings are in opposition, there is a white knight
on e2, and white is in check.
</p>

<h3 id="position:not">:not</h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
match if the containing match list would not match without the
<cql>:not</cql>. In latter case negate the result of the sub-position list
match. The former case is conform with CQL standard of keyword <cql>:not</cql>,
the second form is an extension.
</p>

<p>
Examples:
</p>

<verbatim>
(match
  (position
    ; <comment>we are searching for both colors</comment>
    <cql>position:flipcolor</cql>
    <comment>; the mating position must match each criterion below</comment>
    <cql>position:and</cql> (
      <comment>; the black king is surrounded by empty squares and</comment>
      <comment>; is attacked once and is in mate</comment>
      (position
        <cql>position:attackcount</cql> &k; . 8
        <cql>position:attackcount</cql> A &k; 1
        <cql>position:mate</cql>
        <cql>position:btm</cql>)
      <comment>; check that no neighbor of the black king is</comment>
      <comment>; attacked more than once</comment>
      (position
        <keyword>:not</keyword>
        <cql>position:attackcount</cql> &k; .e4 1
        <cql>position:attackcount</cql> A .e4 2 unlimited
        <cql>position:shift</cql>))))
</verbatim>

<p>
This finds all ideal mirror mates: studies in which the king is surrounded by
empty squares, is attacked once, such that if the king were to move to one of
its neighbors, it would be attacked exactly once.
</p>

<p>
The follwing position match
</p>

<verb>
(position &R;a3 <keyword>:not</keyword>)
</verb>

<p>
is equivalent to
</p>

<verb>
(position [a&Q;&B;&N;&P;&K;.]a3)
</verb>

<h3 id="position:or">:or</h3>

<p>
Takes a list of position lists and matches a position only if at least one of
them matches the position.
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position
    <keyword>:or</keyword> (
      (position <cql>position:piececount</cql>
        &B;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,
        e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2 9)
      (position <cql>position:piececount</cql>
        &b;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9)
      (position <cql>position:piececount</cql>
        &B;[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,
        e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2 9))))
</verbatim>

<p>
Searching for games with one side has two bishops of same color.
</p>

<h2 id="simple">Simple keywords</h2>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:blackcannotwin">:blackcannotwin</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:matingmaterial">:matingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:btm">:btm</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noannotate">:noannotate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:castling">:castling</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocheck">:nocheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:check">:check</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nocontactcheck">:nocontactcheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:checkcount">:checkcount</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nodoublecheck">:nodoublecheck</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:contactcheck">:contactcheck</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:noendgame">:noendgame</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:doublecheck">:doublecheck</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomate">:nomate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:endgame">:endgame</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:nomatingmaterial">:nomatingmaterial</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fen">:fen</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:nostalemate">:nostalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:fiftymoverule">:fiftymoverule</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:repetition">:repetition</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:gameisover">:gameisover</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:stalemate">:stalemate</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:halfmoveclocklimit">:halfmoveclocklimit</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:terminal">:terminal</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:initial">:initial</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variations">:variations</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:losing">:losing</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:variationsonly">:variationsonly</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:markall">:markall</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whitecannotwin">:whitecannotwin</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:mate">:mate</a></td>
    	<td>&emsp;&#x2022;</td><td><a href="#position:wtm">:wtm</a></td>
    </tr>
  </table>
</dir>

<h3 id="position:blackcannotwin">:blackcannotwin<extension/></h3>

<p>
Match only if black cannot win in this position.
</p>

<p>
Normally this is equivalent to following query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; black king only</comment>
  (<cql>position:piececount</cql> a 1)
  <comment>; black king and black minor piece only</comment>
  (<cql>position:piececount</cql> a 2 <cql>position:piececount</cql> i 1))
</verbatim>

<p>
In chess variant %::mc::VariantName(ThreeCheck)% the query with
<cql>:blackcannotwin</cql> succeeds only if black has no more pieces than
the king, and in all other chess variants this query has no meaning and is
always failing.
</p>

<p>
See also: <cql>position:whitecannotwin</cql>
</p>

<h3 id="position:btm">:btm</h3>

<p>
Match only if black is to move.
</p>

<p>
See also: <cql>position:wtm</cql>.
</p>

<h3 id="position:check">:check</h3>

<p>
One side is in check.
</p>

<p>
See also: <cql>position:nocheck</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:checkcount">:checkcount<extension/></h3>

<p>
If the parameter is a single number (between 0 and 3 is allowed), it is
matching all positions where last move is giving n-th check to other side.
</p>

<p>
If the parameter has the form <expr>+&lt;n<sub>1</sub>&gt;+&lt;n<sub>2</sub>&gt;</expr>,
where <expr>&lt;n<sub>i</sub>&gt;</expr> is a number between 0 and 3,
it is matching first position where white has given n<sub>1</sub> times check
to black, and black has given n<sub>2</sub> times check to white.
</p>

<note>
This query is working only in chess variant %::mc::VariantName(ThreeCheck)%,
in other chess variants it fails always (except all values in given parameter
are zero).
</note>

<p>
Examples:
</p>

<verb>
(position <keyword>:checkcount</keyword> 2)
</verb>

<p>
Match as soon as any side has given second check.
</p>

<verb>
(position <keyword>:checkcount</keyword> +0+3)
</verb>

<p>
Match if black has given third check to white king. This must be a final
position.
</p>

<verb>
(position <cql>position:not</cql> <keyword>:checkcount</keyword> +0+0)
</verb>

<p>
This is in fact a useful query. Assume that a game is starting with the
following position (described with
<a href="FEN.html">Forsyth-Edwards Notation</a>):
</p>

<dir><code>
rnb1k1nr/pppp1ppp/8/4p3/3PP2q/2N5/PP3PPP/R1BQKBNR w KQkq - 1 5 +0+2
</code></dir>

<p>
This game would match (note keyword <cql>:not</cql>), because black has already
given second check to white king. With other words, this query is searching for
games starting with an advanced position, where one side has already given a
check.
</p>

<h3 id="position:castling">:castling<extension/></h3>

<p>
This keyword specifies castling availabilities for both sides. It takes as an
argument a piecetype designator, letters of which have the following meanings:
</p>

<dir>
  <table>
    <tr>
      <td class="l"><expr>&K;</expr></td>
      <td class="r">White has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&Q;</expr></td>
      <td class="r">White has queenside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&k;</expr></td>
      <td class="r">Black has kingside castling availability</td>
    </tr>
    <tr>
      <td class="l"><expr>&q;</expr></td>
      <td class="r">Black has queenside castling availability</td>
    </tr>
  </table>
</dir>

<p>
Examples:
</p>

<verb>
(position <keyword>:castling</keyword> &K;)
</verb>

<p>
White has kingside castling availability.
</p>

<verb>
(position <keyword>:castling</keyword> [&K;&Q;])
</verb>

<p>
White has either kingside or queenside castling availability
(but not both).
</p>

<verb>
(position <keyword>:castling</keyword> &K; <keyword>:castling</keyword> &Q;)
</verb>

<p>
White has both kingside and queenside castling availabilities.
</p>

<h3 id="position:contactcheck">:contactcheck<extension/></h3>

<p>
One side is in check, and it is a contact check.
</p>

<p>
This is equivalent to:
</p>

<verbatim>
(position
  <cql>position:check</cql> <comment>; exclude Antichess games</comment>
  <cql>position:or</cql> (
    (position <cql>position:doublecheck</cql>)
    (position <cql>position:attackcount</cql> [&N;&P;] &k; 1 <cql>position:flipcolor</cql>)
    (position [&Q;&R;]d4 &k;[c4,e4,d3,d5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)
    (position [&Q;&B;]d4 &k;[c3,c5,e3,e5] <cql>position:flipcolor</cql> <cql>position:shift</cql>)))
</verbatim>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:doublecheck">:doublecheck<extension/></h3>

<p>
One side is in check, and it is a double check.
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:endgame">:endgame<extension/></h3>

<p>
The position is an endgame position. The keyword is equivalent to the following
query:
</p>

<verbatim>
  (position
    <cql>position:or</cql> (
      (position
      <cql>position:piececount</cql> [&Q;&q;] 0
      <cql>position:piececount</cql> [&R;&B;&N;] 0 3
      <cql>position:piececount</cql> [&r;&b;&n;] 0 3)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &q; 1
      <cql>position:piececount</cql> [&R;&r;] 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> i 0 1)
    (position
      <cql>position:piececount</cql> &Q; 1
      <cql>position:piececount</cql> &R; 0
      <cql>position:piececount</cql> I 0 1
      <cql>position:piececount</cql> &q; 0
      <cql>position:power</cql> [&r;&b;&n;] 0 16
      <cql>position:flipcolor</cql>)))
</verbatim>

<p>
See also: <cql>position:noendgame</cql>.
</p>

<h3 id="position:fen">:fen<extension/></h3>

<p>
The position is equal to the described position in given argument.
This argument must be a valid
<a href="FEN.html">FEN (Forsyth-Edwards Notation)</a>.
</p>

<h3 id="position:fiftymoverule">:fiftymoverule<extension/></h3>

<p>
First position in game where no capture has been made and no pawn has been
moved in previous fifty consecutive moves.
</p>

<p>
See also: <cql>position:halfmoveclocklimit</cql>.
</p>

<h3 id="position:gameisover">:gameisover<extension/></h3>

<p>
This is an abbreviation for:
</p>

<verbatim>
  <cql>position:or</cql> (
    (position <cql>position:mate</cql>)
    (position <cql>position:stalemate</cql>)
    (position <cql>position:losing</cql>)
    (position <cql>position:checkcount 3</cql>)
    (position <cql>position:nomatingmaterial</cql>))
</verbatim>

<h3 id="position:initial">:initial</h3>

<p>
This is the first position in the game (before first move).
</p>

<h3 id="position:halfmoveclocklimit">:halfmoveclocklimit<extension/></h3>

<p>
This keyword is matching a position where the halfmove clock is equal
or less given limit.
</p>

<p>
Halfmove clock: This is the number of halfmoves since the last pawn
advance or capture. This is also used to determine if a draw can be
claimed under the fifty-move rule (<see/> <cql>position:fiftymoverule</cql>).
</p>

<p>
Example:
</p>

<verb>
<keyword>:halfmoveclocklimit</keyword> 30
</verb>

<p>
Exclude all positions where no capture has been made and no pawn has been
moved since more than thirty halfmoves (15 moves by each side).
</p>

<p>
See also: <cql>position:fiftymoverule</cql>.
</p>

<h3 id="position:losing">:losing<extension/></h3>

<p>
Matches the final position if one side has lost all pieces.
This is possible only in Antichess games.
</p>

<p>
See also: <cql>position:nolosing</cql>.
</p>

<h3 id="position:markall">:markall</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in Scidb.
</p>

<h3 id="position:mate">:mate</h3>

<p>
Match only if the position is a mate.
</p>

<annotation>
If searching for mate positions this keyword should always be used even if
this keyword might be superfluous because other conditions are ensuring a
mate position, it is accelerating the search (only testing final positions).
</annotation>

<p>
Example:
</p>

<verb>
(position <keyword>:mate</keyword> <cql>position:movenumber</cql> 1 20)
</verb>

<p>
Only matches if one side is mated in first 20 moves.
</p>

<p>
See also: <cql>position:nomate</cql>.
</p>

<h3 id="position:matingmaterial">:matingmaterial<extension/></h3>

<p>
Match a position if either player has mating material (<see/>
<cql>position:nomatingmaterial</cql>).
</p>

<p>
See also: <cql>position:nomatingmaterial</cql>.
</p>

<h3 id="position:noannotate">:noannotate</h3>

<p>
This keyword is supported to be compatible with CQL standard, and does
not have any meaning in Scidb.
</p>

<h3 id="position:nocheck">:nocheck</h3>

<p>
Neither side is in check.
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:doublecheck</cql>,
<cql>position:nodoublecheck</cql>, <cql>position:contactcheck</cql>,
<cql>position:nocontactcheck</cql>.
</p>

<h3 id="position:nocontactcheck">:nocontactcheck<extension/></h3>

<p>
Neither side is in check, or it is not a contact check (<see/>
<cql>position:contactcheck</cql>).
</p>

<p>
See also: <cql>position:check</cql>, <cql>position:nocheck</cql>,
<cql>position:doublecheck</cql>, <cql>position:nodoublecheck</cql>,
<cql>position:contactcheck</cql>.
</p>

<h3 id="position:nodoublecheck">:nodoublecheck<extension/></h3>

<p>
Neither side is in check, or it is not a double check.
</p>

<h3 id="position:noendgame">:noendgame<extension/></h3>

<p>
The position is not an endgame position (<see/>
<cql>position:endgame</cql>).
</p>

<p>
See also: <cql>position:endgame</cql>.
</p>

<h3 id="position:nomate">:nomate<extension/></h3>

<p>
Match only if the position is not mate.
</p>

<p>
See also: <cql>position:mate</cql>.
</p>

<h3 id="position:nomatingmaterial">:nomatingmaterial<extension/></h3>

<p>
Match a position if neither player has mating material.
</p>

<p>
Normally this is equivalent to this query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; king versus king</comment>
  (<cql>position:piececount</cql> U 2)
  <comment>; king and minor piece versus king</comment>
  (<cql>position:piececount</cql> U 3 <cql>position:piececount</cql> [Ii] 1)
  <comment>; king and bishop versus king and bishop with the bishops on the same color</comment>
  (<cql>position:piececount</cql> U 4
   <cql>position:piececount</cql> [&B;&b;][a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,
     d6,d8,e1,e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8] 2)
  (<cql>position:piececount</cql> U 4
   <cql>position:piececount</cql> [&B;&b;][a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,
     d5,d7,e2,e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7] 2))
</verbatim>

<p>
In variant %::mc::VariantName(ThreeCheck)% this query only succeeds if only
kings are on board, and in all other chess variants this keyword has no
meaning and is always failing.
</p>

<p>
See also: <cql>position:matingmaterial</cql>.
</p>

<h3 id="position:nostalemate">:nostalemate<extension/></h3>

<p>
Match only if the position is not a stalemate.
</p>

<p>
See also: <cql>position:stalemate</cql>,
</p>

<h3 id="position:repetition">:repetition<extension/></h3>

<p>
Match first position of mainline which occurred the third time in this game,
with same player to move, and each player has the same castling and en passant
capturing rights. The repeated positions need not occur in succession. This
accords with the <a href="http://en.wikipedia.org/wiki/Threefold_repetition">
threefold repetition rule</a>.
</p>

<h3 id="position:stalemate">:stalemate</h3>

<p>
Match only if the position is a stalemate.
</p>

<p>
See also: <cql>position:nostalemate</cql>,
</p>

<h3 id="position:terminal">:terminal<extension/></h3>

<p>
This is the last position in the game.
</p>

<h3 id="position:variations">:variations</h3>

<p>
Look in the variations to find matches. Without this keyword the variations
will be skipped.
</p>

<h3 id="position:variationsonly">:variationsonly</h3>

<p>
Look only in the variations to find matches, not in the main line.
</p>

<h3 id="position:whitecannotwin">:whitecannotwin<extension/></h3>

<p>
Match only if white cannot win in this position.
</p>

<p>
Normally this is equivalent to following query:
</p>

<verbatim>
<cql>position:or</cql> (
  <comment>; white king only</comment>
  (<cql>position:piececount</cql> A 1)
  <comment>; white king and white minor piece only</comment>
  (<cql>position:piececount</cql> A 2 <cql>position:piececount</cql> I 1))
</verbatim>

<p>
In chess variant %::mc::VariantName(ThreeCheck)% this query succeeds only if
white has no more pieces than the king, and in all other chess variants this
query has no meaning and is always failing.
</p>

<p>
See also: <cql>position:blackcannotwin</cql>
</p>

<h3 id="position:wtm">:wtm</h3>

<p>
Match only if white is to move.
</p>

<h2 id="transform">Transformation keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:flip">:flip</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipcolor">:flipcolor</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdiagonal">:flipdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipdihedral">:flipdihedral</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:fliphorizontal">:fliphorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:flipvertical">:flipvertical</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:inside">:inside</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shift">:shift</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftdiagonal">:shiftdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shifthorizontal">:shifthorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftmaindiagonal">:shiftmaindiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftoffdiagonal">:shiftoffdiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:shiftvertical">:shiftvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:flip">:flip</h3>

<p>
Same as <cql>position:flipdihedral</cql> (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipcolor">:flipcolor</h3>

<p>
The color flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipdiagonal">:flipdiagonal</h3>

<p>
The diagonal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipdihedral">:flipdihedral</h3>

<p>
All dihedral transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:fliphorizontal">:fliphorizontal</h3>

<p>
The horizontal flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:flipvertical">:flipvertical</h3>

<p>
The vertical flip transformation (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:inside">:inside<extension/></h3>

<p>
This keyword filters shift transformations in order to some matching pieces
will stay inside a specified region of the board. It takes two arguments, a
piece designator and a square designator. Any shift transformation affects
only the first argument. A shift transformation match <cql>:inside</cql>
limitation if at least one piece matching the first argument (taking into
account the transformation) is placed on a square matching the second argument.
</p>

<p>
Example:
</p>

<p>
We use the following query to find tripled pawns:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
To find one of tripled pawns placed on the main diagonal we design the query
</p>

<verbatim>
(position
  <keyword>:inside</keyword> &P;[b2-7] [b2,c3,d4,e5,f6,g7]
  <cql>position:piececount</cql> &P;[b2-7] 3
  <cql>position:shifthorizontal</cql>)
</verbatim>

<h3 id="position:shift">:shift</h3>

<p>
The shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftdiagonal">:shiftdiagonal</h3>

<p>
The off-diagonal and main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shifthorizontal">:shifthorizontal</h3>

<p>
The horizontal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftmaindiagonal">:shiftmaindiagonal</h3>

<p>
The main-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftoffdiagonal">:shiftoffdiagonal</h3>

<p>
The off-diagonal shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h3 id="position:shiftvertical">:shiftvertical</h3>

<p>
The vertical shift transformations (<see/>
<a href="CQL-Transformations.html">Transformations</a>).
</p>

<h2 id="piece">Piece configuration keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:attackcount">:attackcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piececount">:piececount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:power">:power</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:powerdifference">:powerdifference</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:ray">:ray</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayattack">:rayattack</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:raydiagonal">:raydiagonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayhorizontal">:rayhorizontal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayorthogonal">:rayorthogonal</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:rayvertical">:rayvertical</a></td></tr>
  </table>
</dir>

<h3 id="position:attackcount">:attackcount</h3>

<p>
This keyword takes as arguments two piece designators followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. The first piece
designator is the attacker piece designator. The second piece designator
is the attacked piece designator. An attack by a piece to a square occurs
if the piece could move to that square were it empty and disregarding any
possible checks. A valid attack is an attack by a piece on a square that
matches the attacker piece designator to a square on which is a piece that
matches the attacking piece designator.
</p>

<p>
The <cql>:attackcount</cql> keyword matches a position if the total number
of valid attacks in the position lies with the range given by its range
specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2)
</verb>

<p>
Matches any position in which white has a double attack on the black king
(note that the use of <cql>position:doublecheck</cql> combined with
<cql>position:btm</cql> should be preferred).
</p>

<verb>
(position <keyword>:attackcount</keyword> A &k; 2 <cql>position:flipcolor</cql>)
</verb>

<p>
Matches any position in which a king is under double attack
(again the use of <cql>position:doublecheck</cql> should be preferred).
</p>

<verb>
(position <keyword>:attackcount</keyword> A .h3 1)
</verb>

<p>
Matches a position in which exactly one white piece attacks an empty h3 square.
</p>

<verb>
(position <keyword>:attackcount</keyword> [&R;&B;][a-c8] ??1 5 9
</verb>

<p>
Matches a position in which the number of times a white rook or white bishop
on a8, b8, or c8 attacks a square on the first rank is between 5 and 9
inclusive.
</p>

<verb>
(position <keyword>:attackcount</keyword> &n; [&K;&R;&Q;] 3 unlimited)
</verb>

<p>
Matches position for which the number of times a black knight attacks a white
King or white major piece is at least 3.
</p>

<h3 id="position:piececount">:piececount</h3>

<p>
This keyword takes a piece designator argument followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches the
position if and only if the number of occurrences of the piece designator
in the position is given by the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:piececount</keyword> &R; 2)
</verb>

<p>
This will match any position with exactly two white rooks - a position with
three white rooks would fail to match.
</p>

<verbatim>
(position
  &N;d4
  <keyword>:piececount</keyword> [&R;&r;][a1-8] 1 3
  <keyword>:piececount</keyword> [&Q;&q;][a-h8] 4)
</verbatim>

<p>
This will match any position with a white knight on d4, between one and three
rooks on the a file, and exactly four queens on the eight rank. Another way
to write this position list is:
</p>

<verbatim>
(position
  &N;d4
  <keyword>:piececount</keyword> [&R;&r;][a?] 1 3
  <keyword>:piececount</keyword> [&Q;&q;][?8] 4)
</verbatim>

<h3 id="position:power">:power</h3>

<p>
This keyword takes as argument a piece designator followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches positions
for which the total power of all pieces in the position matching the piece
designator lies within the range specifier. The power of a piece is their
chess material power, depending on the
<a href="Chess-Variants.html">chess variant</a>:
</p>

<dir>
  <table cellpadding="3">
    <tr>
      <td align="right"></td>
      <td align="right">&King;</td>
      <td align="right">&Queen;</td>
      <td align="right">&Rook;</td>
      <td align="right">&Bishop;</td>
      <td align="right">&Knight;</td>
      <td align="right">&Pawn;</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Normal)%, %::mc::VariantName(ThreeCheck)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Crazyhouse)%, %::mc::VariantName(Bughouse)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 3</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Losers)%&emsp;</td>
      <td align="right"> 0</td>
      <td align="right"> 5</td>
      <td align="right"> 4</td>
      <td align="right"> 3</td>
      <td align="right"> 4</td>
      <td align="right"> 1</td>
    </tr>
    <tr>
      <td>%::mc::VariantName(Suicide)%, %::mc::VariantName(Giveaway)%&emsp;</td>
      <td align="right">30</td>
      <td align="right"> 3</td>
      <td align="right"> 9</td>
      <td align="right"> 0</td>
      <td align="right"> 9</td>
      <td align="right"> 1</td>
    </tr>
  </table>
</dir>

<p>
Examples:
</p>

<verb>
(position <keyword>:power</keyword> a 6)
</verb>

<p>
This will match positions in which the total power of the black pieces on the
board equals 6.
</p>

<verb>
(position <keyword>:power</keyword> A[a-h1-4] 10 25)
</verb>

<p>
This will match positions in which the total power of the white pieces on the
white half of the board is between 10 and 25 inclusive.
</p>

<h3 id="position:powerdifference">:powerdifference</h3>

<p>
This keyword takes as argument a piece designator followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches positions
in which the difference in power (<see/> <cql>position:power</cql>) between the
white and black pieces matching the piece designator (that is, the numeric value
of the power of the matching black pieces subtracted from the power of the
matching white pieces) lies within the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:powerdifference</keyword> U 4)
</verb>

<p>
This matches positions in which the white pieces have power precisely 4
greater than the black pieces.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;] -5 10)
</verb>

<p>
This matches positions in which white has between one fewer and two more
rooks than black.
</p>

<verb>
(position <keyword>:powerdifference</keyword> [&R;&r;&B;&b;&N;&n;] unlimited -2)
</verb>

<p>
This matches positions in which black is up at least an exchange.
</p>

<verbatim>
(match
  (position
    <cql>match:result</cql> 1-0
    <cql>position:sequence</cql> (
      (position
        <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9
        <keyword>:powerdifference</keyword> U unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9)
      (position <keyword>:powerdifference</keyword> [&Q;&q;] unlimited -9))
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
This example shows a way how to search for queen sacrifices using
<code>:powerdifference</code>. One side sacrifices a queen, and remains at
least 9 pawns down in material for at least 12 moves, and finally wins.
</p>

<h3 id="position:ray">:ray</h3>

<p>
A ray specifier is a list of piece designators. A ray is a contiguous set of
squares on a straight line on the chessboard parallel to an axis, the a1-h1
diagonal, or the a8-h8 diagonal.
</p>

<p>
Let R by a ray with ordered set of squares in a contiguous line
<nobr>S<sub>1</sub>,</nobr> <nobr>S<sub>2</sub>,</nobr> <nobr>...,</nobr>
<nobr>S<sub>n</sub>.</nobr> Suppose a given ray specifier
<nobr>(G<sub>1</sub>,</nobr> <nobr>G<sub>2</sub>,</nobr> <nobr>...,</nobr>
<nobr>G<sub>k</sub>)</nobr> where each G is a piece designator. The ray R is
valid with respect to the ray specifier if <nobr>G<sub>1</sub></nobr> matches
the piece on <nobr>S<sub>1</sub>,</nobr> and if <nobr>G<sub>k</sub></nobr>
matches the piece on <nobr>S<sub>n</sub>,</nobr> and if the remaining
<nobr>G<sub>i</sub></nobr> can be paired to some subset of the squares in the
ray in an order-preserving way such that each <nobr>G<sub>i</sub></nobr>
matches the piece on its corresponding square and such that all unpaired
squares in the ray are empty.
</p>

<p>
The <cql>:ray</cql> keyword takes a ray specifier and an optional
<a href="CQL-Range-Specifiers.html">range specifier</a>. If the range specifier
is absent, it is taken to be <nobr><code>1</code>
<code>unlimited</code></nobr>. Otherwise, <cql>:ray</cql> matches a position if
the number of rays in the position valid with respect to the ray specifier lies
within the range specifier.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:ray</keyword> (&k; &Q;))
</verb>

<p>
Matches a position in which a white queen attacks the black king.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &n; &k;[?4-8]))
</verb>

<p>
Matches a position in which a white queen on the a file pins a black knight
to the black king on the last four ranks.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q;a? &Q;c? &Q;e? &k;g?))
</verb>

<p>
Matches a position in which either three white queens and the black king are
on the same rank, with exactly one empty square between them, and one of the
queens is on the a-file, or a position in which the three white queens and
black king form a diagonal with one empty squares between successive pieces,
and the queens on the a, c, and e files in both cases.
</p>

<verb>
(position <keyword>:ray</keyword> (&Q; &n; &k;) 2 4)
</verb>

<p>
Between two and for black knights are pinned to the black king.
</p>

<p>
See also: <cql>position:rayattack</cql>.
</p>

<h3 id="position:rayattack">:rayattack</h3>

<p>
Has the same syntax as <cql>position:ray</cql>. It has the semantics of
<cql>position:ray</cql>, except that only orthogonal rays that start on
a square containing a rook or queen are included, and only diagonal rays
starting on a square containing a bishop or queen are included.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:rayattack</keyword> (A a &k;))
</verb>

<p>
Matches a position in which a black piece is pinned to the black king.
</p>

<verb>
(position <keyword>:rayattack</keyword> (Ad5 a [&r;&k;][a-h1-4]) 3)
</verb>

<p>
Matches positions in which there are three black pieces pinned by a white
piece on d5 against either a black rook or king in the first four ranks.
</p>

<verb>
(position <cql>position:stalemate</cql> <keyword>:rayattack</keyword>
(A a &k;) 2 8 <cql>position:flipcolor</cql>)
</verb>

<p>
Finds multiple-pin stalemates.
</p>

<p>
See also: <cql>position:ray</cql>.
</p>

<h3 id="position:raydiagonal">:raydiagonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being diagonal. A diagonal ray is a ray that is not vertical
or horizontal.
</p>

<h3 id="position:rayhorizontal">:rayhorizontal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being horizontal. A horizontal ray is a ray that is horizontal.
</p>

<h3 id="position:rayorthogonal">:rayorthogonal</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being orthogonal. A orthogonal ray is a ray that is not
diagonal.
</p>

<h3 id="position:rayvertical">:rayvertical</h3>

<p>
This keyword function exactly like <cql>position:ray</cql> but the given rays
are restricted to being vertical. A vertical ray is a ray that is vertical.
</p>

<h2 id="move">Move keywords</h2>

<p>
In a position, the next move is the move about to be played, if any. A move has
three characteristics: its origin square designator, its destination square
designator and its promotion designator. These refer respectivelyto the piece
and square from which the piece moves; to the piece and square to which it is
going to move (but before it actually moves there), and to the piece and square
to which it promotes, if any. In chess variants %::mc::VariantName(Crazyhouse)%
and %::mc::VariantName(Bughouse)% there is a fourth characteristic: the
piecedrop designator. It refers to the piecetype which will be dropped, if any.
</p>

<p>
For example, the destination designation of a white rook on a4 capturing a black
knight on d4 is <expr>&n;d4</expr>, and its origin designation is
<expr>&R;a4</expr>. The destination designation of a move to e4 that is not a
capture is <expr>.e4</expr>.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:enpassant">:enpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:iscastling">:iscastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movefrom">:movefrom</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:movenumber">:movenumber</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveto">:moveto</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nocastling">:nocastling</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:noenpassant">:noenpassant</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:nopiecedrop">:nopiecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:piecedrop">:piecedrop</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:promote">:promote</a></td></tr>
  </table>
</dir>

<h3 id="position:enpassant">:enpassant</h3>

<p>
The next move is an en-passant capture.
</p>

<p>
See also: <cql>position:noenpassant</cql>
</p>

<h3 id="position:iscastling">:iscastling<extension/></h3>

<p>
The next move is a castling move.
</p>

<p>
See also: <cql>position:nocastling</cql>.
</p>

<h3 id="position:movefrom">:movefrom</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose from
designator matches that piece designator.
</p>

<p>
Examples:
</p>

<verb>
<keyword>:movefrom</keyword> &R;a3
</verb>

<p>
Matches a position in which the next move is of a white rook on a3.
</p>

<verb>
(position <keyword>:movefrom</keyword> U?8)
</verb>

<p>
Matches a position in which the next move is of some piece on the 8th rank.
</p>

<verb>
(position <keyword>:movefrom</keyword> .)
</verb>

<p>
This can never match, even a piece drop move
(%::mc::VariantName(Crazyhouse)%, %::mc::VariantName(Bughouse)%)
will not match. Use <cql>position:piecedrop</cql> for the detection
of piece drop moves.
</p>

<h3 id="position:movenumber">:movenumber</h3>

<p>
<cql>:movenumber</cql> takes a
<a href="CQL-Range-Specifiers.html">range specifier</a> as parameter and
matches positions only if the current move number is within the specified
range. The move number computation assumes white moves first.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:movenumber</keyword> 10 20 <cql>position:check</cql>)
</verb>

<p>
Matches a position in which there is a check between moves 10 and 20.
</p>

<verb>
(position <keyword>:movenumber</keyword> 35 <cql>position:mate</cql>)
</verb>

<p>
Matches a position in which move 35 is mate.
</p>

<h3 id="position:moveto">:moveto</h3>

<p>
Takes a single parameter, a piece designator. It matches a move whose
destination designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:moveto</keyword> U)
</verb>

<p>
Is matching a position where next move is a capture move.
</p>

<verb>
(position <keyword>:moveto</keyword> .)
</verb>

<p>
Is matching a position where next move is not a capture move.
</p>

<verb>
(position <keyword>:moveto</keyword> &R;[b1-8])
</verb>

<p>
Matches a position in which the next move is to capture a white rook on
the b file. Note that this is quite different from the natural
<a href="http://de.wikipedia.org/wiki/Portable_Game_Notation">PGN</a>
interpration of its being a move of a white rook to the b file. That
would be done via:
</p>

<verb>
(position <cql>position:movefrom</cql> &R; <keyword>:moveto</keyword> ?b?)
</verb>

<p>
Matches a move of the white rook to the b file.
But back to the previous example:
</p>

<verb>
(position <keyword>:moveto</keyword> &R;[b1-8])
</verb>

<p>
This can never match a piece drop (concerns the chess variants
%::mc::VariantName(Crazyhouse)% and %::mc::VariantName(Bughouse)%).
However, if this should match also a piece drop, we have to extend
the query:
</p>

<verbatim>
(position
  <cql>position:or</cql> (
    (<keyword>:moveto</keyword> &R;[b1-8])
    (<cql>position:piecedrop</cql> &R;[b1-8])))
</verbatim>

<h3 id="position:nocastling">:nocastling<extension/></h3>

<p>
The next move is not a castling move.
</p>

<p>
See also: <cql>position:iscastling</cql>.
</p>

<h3 id="position:noenpassant">:noenpassant</h3>

<p>
The next move is not an en-passant capture.
</p>

<p>
See also: <cql>position:enpassant</cql>.
</p>

<h3 id="position:piecedrop">:piecedrop<extension/></h3>

<p>
The next move is a piece drop, where the piecedrop designator is matching
the given piece designator. For a nonempty piece designator this is possible
only in chess variants %::mc::VariantName(Crazyhouse)%, and
%::mc::VariantName(Bughouse)%.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:piecedrop</keyword> [&N;&n;])
</verb>

<p>
The next move is a piece drop which is dropping a knight.
</p>

<verb>
(position <keyword>:piecedrop</keyword> [&Q;]f7)
</verb>

<p>
The next move is a piece drop which is dropping a white queen on f7.
</p>

<verb>
(position <keyword>:piecedrop</keyword> [])
</verb>

<p>
The next move is not a piece drop (because the piecetype designator
is empty).
</p>

<h3 id="position:promote">:promote</h3>

<p>
Takes a single parameter, a piece designator. It matches a move if that move
is a promotion whose promotion designator matches its parameter.
</p>

<p>
Examples:
</p>

<verb>
(position <keyword>:promote</keyword> [&R;&B;&N;])
</verb>

<p>
Matches a position whose next move is a white underpromotion.
</p>

<verb>
(position <keyword>:promote</keyword> [&B;&N;]a8)
</verb>

<p>
Matches a position whose next move is a white promotion to bishop or knight.
</p>

<verb>
(position <keyword>:promote</keyword> [&R;e8]
<cql>position:movefrom</cql> &P;f7 <cql>position:moveto</cql> &q;)
</verb>

<p>
Matches a position in which the next move is of a pawn on f7 capturing a black
queen on e8 and promoting to a rook.
</p>

<verb>
(position <keyword>:promote</keyword> [])
</verb>

<p>
Matches a position in which the next move is not a promotion (because the
piecetype designator is empty).
</p>

<h2 id="sequence">Sequence keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:gappedsequence">:gappedsequence</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sequence">:sequence</a></td></tr>
  </table>
</dir>

<h3 id="position:gappedsequence">:gappedsequence</h3>

<p>
Takes one argument, a list of position lists. A position list A is said to be
a refinement of a position list B if A may be formed from B by inserting zero or
more position lists of the form <expr>(position)</expr> into the top level of B.
For example:
</p>

<verb>
((position &N;a4) (position) (position &R;b2))
</verb>

<p>
refines
</p>

<verb>
((position &N;a4) (position &R;b2))
</verb>

<p>
because it was formed by inserting a single position list into the latter list.
</p>

<p>
A <cql>:gappedsequence</cql> with argument B matches a position if and only if
there is a refinement A of B such that a <cql>position:sequence</cql> with
argument A would match that position. That is, <cql>:gappedsequence</cql> is
like <cql>position:sequence</cql> except that the sequence of matching positions
may include intervening positions from the game.
</p>

<p>
Examples:
</p>

<verbatim>
(position
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
This will match any position for which the positions that occur successively
in the game starting with that position comprise zero or more positions,
followed by a position from which a white rook on a3 moves, followed by zero
or more positions, followed by a position from which a white rook on b4 moves.
In consequence the same effect can be obtained much more efficiently via:
</p>

<verbatim>
(position
  <cql>position:initial</cql>
  <keyword>:gappedsequence</keyword> (
    (position <cql>position:movefrom</cql> &R;a3)
    (position <cql>position:movefrom</cql> &R;b4)))
</verbatim>

<p>
The total number of <cql>position:sequence</cql> and <cql>:gappedsequence</cql>
position lists that can occur at the top level of a position list cannot exceed
one. To get the effect of both a <cql>:gappedequence</cql> and
<cql>position:sequence</cql> keywords in one position list, use <cql>position:and</cql>.
</p>

<h3 id="position:sequence">:sequence</h3>

<p>
Takes a single argument that is a list of position lists. It matches a given
position if and only successive occurring positions, beginning with the
current position, match each corresponding element in its argument.
</p>

<p>
Example:
</p>

<verbatim>
(position
  &R;e8
  <keyword>:sequence</keyword> (
    (position &Q;f3 .g2)
    (position .f3 &Q;g2)))
</verbatim>

<p>
This position list matches exactly those positions with a white rook on e8
such that:
</p>

<ol>
  <li>In that position, white has a queen on f3 and g2 is empty, and</li>
  <li>After the next move, f3 is empty and there is a white queen on g2.</li>
</ol>

<p>
In consequence, this position list is identical in effect to
</p>

<verb>
(position &R;e8 <cql>position:movefrom</cql> &Q;f3 <cql>position:moveto</cql> .g2)
</verb>

<p>
The following more typical usage of <cql>:sequence</cql> will search for all
queen staircase checking maneuvers by either side:
</p>

<verbatim>
(position
  <cql>position:shift</cql> <cql>position:flip</cql> <cql>position:flipcolor</cql>
  <keyword>:sequence</keyword> (
    (position <cql>position:movefrom</cql> &Q;a2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b2)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;b3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c3)
    (position <cql>position:check</cql>)
    (position <cql>position:movefrom</cql> &Q;c4)))
</verbatim>

<p>
This position list matches any position with a white queen on a2 for which
there are successively moves by queens on the indicated squares giving check;
the <cql>position:shift</cql>, <cql>position:flip</cql>, and
<cql>position:flipcolor</cql> search for this variation reflected or
rotated anywhere on the board.
</p>

<h2 id="game">Game related keywords</h2>

<p>
Several keywords relate to the game parameters and are not affected by the
contents of the position; they are included as position list keywords instead
of match list keywords so the <cql>position:flipcolor</cql> can be used with
them. these are:
</p>

<dir>
  <table>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:elo">:elo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiteelo">:whiteelo</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackelo">:blackelo</a></td>
    </tr>
    <tr>
      <td>              </td><td></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:whiterating">:whiterating</a></td>
      <td>&emsp;&#x2022;</td><td><a href="#position:blackrating">:blackrating</a></td>
    </tr>
    <tr>
      <td>      &#x2022;</td><td><a href="#position:result">:result</a></td>
    </tr>
  <tr>
      <td>      &#x2022;</td><td><a href="#position:variant">:variant</a></td>
  </tr>
  </table>
</dir>

<h3 id="position:blackelo">:blackelo</h3>

<p>
This keyword takes a <a href="CQL-Range-Specifiers.html">range specifier</a>;
the ELO of the black player must lie within its range.
</p>

<h3 id="position:blackrating">:blackrating<extension/></h3>

<p>
Match all games where the specified rating score of black player is between
given range. For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h3 id="position:elo">:elo</h3>

<p>
This parameter expects a <a href="CQL-Range-Specifiers.html">range specifier</a>;
the ELO of at least one of the players must lie within the specified range.
</p>

<p>
This keyword is supported only due to compatibility reasons with the CQL standard.
It is recommended to use instead the identically named keyword
<cql>match:elo</cql> in the match list.
</p>

<h3 id="position:result">:result</h3>

<p>
This keyword takes one argument, the same as the argument to
<cql>match:result (match)</cql> in a match list.
</p>

<p>
Example:
</p>

<verbatim>
(match (
  (position
    <keyword>:result</keyword> 1-0
    <cql>position:whiteelo</cql> 0 2300
    <cql>position:blackelo</cql> 2600 unlimited
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
Searches for games in which a 2300 player or below defeated a 2600 player
or above.
</p>

<h3 id="position:variant">:variant</h3>

<p>
for a description see identically named keyword <cql>match:variant (match)</cql>
in match list. This keyword is added for the possibility to distinguish between
different <a href="Chess-Variants.html">chess variants</a> in each position list.
</p>

<h3 id="position:whiteelo">:whiteelo</h3>

<p>
This keyword takes a <a href="CQL-Range-Specifiers.html">range specifier</a>;
the ELO of the white player must lie within its range.
</p>

<h3 id="position:whiterating">:whiterating<extension/></h3>

<p>
Match all games where the specified rating score of white player is between
given range. For a detailed description see <cql>match:rating (match)</cql>.
</p>

<h2 id="relation">Relation between positions</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:relation">:relation</a></td></tr>
  </table>
</dir>

<h3 id="position:relation">:relation</h3>

<p>
Takes one argument, a relation specification. is used to search for games with
pairs of positions P1 and P2 that satisfy certain properties. See
<a href="CQL-Relation-List.html">relation list</a> for a desription of
the relation specification keywords.
</p>

<h2 id="matching">Matching count keywords</h2>

<p>
Two keywords pertain to the number of positions which a position list matches.
These each take a <a href="CQL-Range-Specifiers.html">range specifier</a>
as parameter. They can only be used in a position list at the top level of a
match list.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:matchcount">:matchcount</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:pretransformmatchcount">:pretransformmatchcount</a></td></tr>
  </table>
</dir>

<h3 id="position:matchcount">:matchcount</h3>

<p>
Matches if and only if the number of times this position list matches a
position in the current game lies within the
<a href="CQL-Range-Specifiers.html">range specifier</a>.
</p>

<p>
Example:
</p>

<verb>
(position <cql>position:moveto</cql> [&Q;&q;] <keyword>:matchcount</keyword> 4 unlimited)
</verb>

<p>
Matches any game in which at least four queen captures have occurred.
</p>

<h3 id="position:pretransformmatchcount">:pretransformmatchcount</h3>

<p>
Has the same syntax as <cql>position:matchcount</cql>. For a description
of this keyword we will suppose the following general form of a position
list:
</p>

<verbatim>
(position
  T<sub>1</sub> T<sub>2</sub> ... T<sub>k</sub>
  X<sub>1</sub> X<sub>2</sub> ... X<sub>n</sub>
  <keyword>:pretransformmatchcount</keyword> n<sub>1</sub> n<sub>2</sub>)
</verbatim>

<p>
All <expr>T<sub>i</sub></expr> are denoting the transformation keywords,
and all other elements (but no transformation keywords) are denoted with
<expr>X<sub>i</sub></expr>. <expr>n<sub>1</sub></expr>
<expr>n<sub>2</sub></expr> is the range specifier. Now we suppose that
<expr>Y<sub>i,j</sub></expr> is denoting an element formed by one
transformation step j applied to <expr>X<sub>i</sub></expr> (possibly
identical to <expr>X<sub>i</sub></expr> because it is
transformation-invariant). m denotes the total count of all
transformation steps. Now we will form a new position list:
</p>

<verbatim>
(position
  <cql>position:or</cql> (
    Y<sub>1,1</sub> Y<sub>2,1</sub> ... Y<sub>n,1</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    Y<sub>1,2</sub> Y<sub>2,2</sub> ... Y<sub>n,2</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)
    ...
    Y<sub>1,m</sub> Y<sub>2,m</sub> ... Y<sub>n,m</sub> <cql>position:matchcount</cql> n<sub>1</sub> n<sub>2</sub>)))
</verbatim>

<p>
The position list containing <cql>:pretransformmatchcount</cql> is matching
exactly those positions matched from our newly formed position list.
With other words: the match count will be performed for each individual
transformation step.
</p>

<p>
Example:
</p>

<verbatim>
(position
  <cql>position:moveto</cql> [Aa]d4
  <keyword>:pretransformmatchcount</keyword> 12 unlimited
  <cql>position:shift</cql>))
</verbatim>

<p>
This would match any game in which at least 12 captures occur on the same
square. Were the <cql>:pretransformmatchcount</cql> replaced by
<cql>position:matchcount</cql>, the position list would match games in which
at least 12 captures occurred anywhere on board.
</p>

<h2 id="evaluation">Analyzing keywords</h2>

<p>
The following keywords are analyzing positions. <cql>position:evaluation</cql> and
<cql>position:moveevaluation</cql> should be used with care, these are very slow
operations. In some cases the keywords <cql>position:exchangeevaluation</cql> and
<cql>position:maxswapevaluation</cql> might be an alternative, these functions are
quite faster, although fairly time consuming.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:evaluation">:evaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exchangeevaluation">:exchangeevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:maxswapevaluation">:maxswapevaluation</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:moveevaluation">:moveevaluation</a></td></tr>
  </table>
</dir>

<h3 id="position:evaluation">:evaluation<extension/></h3>

<annotation>
This is a very slow operation and should be used with restrictions.
</annotation>

<p>
This keyword is evaluating the current position with the help of an
external chess engine. The first two parameter are specifying the
computation mode:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>
  </table>
</dir>

<p>
Now you can either specify a search for mate, or a search for position
evaluation.
</p>

<p>
A search for mate expects one more parameter: namely the word <i>mate</i>.
A query is successful if a mate has been found.
</p>

<p>
The search for position evaluation is expecting three additional parameters.
The first one denotes the lower bound, the second one denotes the upper bound,
both scores are in pawn units. The query succeeds if the evaluation of the
position is within the specified bounds (inclusive the ranges). If the
lower-bound value is specified with <i>unlimited</i>, it means negative
unlimited. If the upper-bound value is specified with <i>unlimited</i>, it
means positive unlimited. The third parameter is either <i>sidetomove</i> or
<i>absolute</i>. <i>sidetomove</i> means that the evaluation value depends on
side to move, and <i>absolute</i> means that the evaluation value is
independent from side to move.
</p>

<note>
Please note that in mode <i>movetime</i> the specification of the milli-seconds
will be rounded to centi-seconds if the engine is restricted to
<nobr>WinBoard</nobr>/<nobr>XBoard</nobr> protocol. If the UCI
protocol is available then the exact number of milli-seconds will be used.
</note>

<p>
Examples:
</p>

<verb>
<keyword>:evaluation</keyword> depth 4 2.5 unlimited sidetomove
</verb>

<p>
Side to move has (probably) a winning position, because he is
at least 2.5 pawn units ahead.
</p>

<verb>
<keyword>:evaluation</keyword> depth 4 unlimited -2.5 sidetomove
</verb>

<p>
Side to move has (probably) a losing position, because he is
at least 2.5 pawn units behind.
</p>

<verb>
<keyword>:evaluation</keyword> movetime 3000 unlimited -3.0 absolute
</verb>

<p>
Black is (probably) losing, because he is at least 3 pawn units behind.
</p>

<verb>
<keyword>:evaluation</keyword> depth 6 mate
</verb>

<p>
Either side can be mated in maximal 3 moves (6 plies).
</p>

<h3 id="position:exchangeevaluation">:exchangeevaluation<extension/></h3>

<p>
This keyword is analyzing capture moves to see whether or not they appear
to be profitable.
</p>

<p>
The keyword matches the current move if this value is in the specified range,
a lower and an upper value in pawn units. Only capture moves will be evaluated.
If lower range is specified with <i>unlimited</i>, it means negative unlimited.
If the lower range is specified with <i>unlimited</i>, it means positive unlimited.
The evaluation function is taking into account that pieces may be pinned or
defended by other pieces. The value of the function does not depend on which
side is to move.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<p>
Example:
</p>

<verb>
<keyword>:exchangeevaluation</keyword> unlimited -3
</verb>

<p>
This capture move is (probably) a blunder.
</p>

<h3 id="position:maxswapevaluation">:maxswapevaluation<extension/></h3>

<p>
This keyword allows to estimate exchange values of possible moves. It takes
as arguments two piece designators followed by a
<a href="CQL-Range-Specifiers.html">range specifier</a>. The first argument
specifies moving pieces, the second one specifies target squares. For each
possible moves we compute an integer value that is a material benefit of the
move (in pawns, like in case of the <cql>position:power</cql> keyword)
according to possible piece exchanges on the target square after the move.
After that the maximum of all computed values will be selected.
</p>

<p>
The keyword match the position if this value lies in the specified range
(a lower and an upper value). If lower range is specified with <i>unlimited</i>,
it means negative unlimited. If the lower range is specified with <i>unlimited</i>,
it means positive unlimited. The evaluation function is taking into account that
pieces may be pinned or defended by other pieces. The value of the function does
not depend on which side is to move.
</p>

<p>
Concerning the piece values see <cql>position:power</cql>.
</p>

<p>
Note that this function is not evaluating the position, instead it is
estimating the exchange values.
</p>

<note>
This keyword is alike the keyword <expr>:maxswapvalue</expr> from Chess
Assistant 9 (<see/>
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
but quite different implemented.
</note>

<p>
Examples:
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> A a 1 unlimited)
</verb>

<p>
This query selects positions in which white threatens with
winning some material.
</p>

<verb>
(position <keyword>:maxswapevaluation</keyword> &Q;?1-7 ??8 0 unlimited)
</verb>

<p>
This query selects positions in which a white queen can invade rank 8
without a material loss.
</p>

<h3 id="position:moveevaluation">:moveevaluation<extension/></h3>

<annotation>
This is a very slow operation and should be used with restrictions.
</annotation>

<p>
This keyword is matching the difference between the evaluation of the current
position and the evaluation of the preceding position. The evaluation will be
done with the help of an external chess engine. It takes seven parameters.
The first and second parameter are piece designators. The former is specifies
moving pieces, the second one specifies target squares. The third and fourth
are specifiying the computation mode:
</p>

<dir>
  <table>
    <!-- UCI:  "go depth <x>" -->
    <!-- WB:   "st <x>"       -->
    <tr>
      <td class="l"><expr>depth &lt;d&gt;</expr></td>
      <td class="r">search &lt;d&gt; plies only</td>
    </tr>

    <!-- UCI:  "go movetime <x>" -->
    <!-- WB:   "time <x/10>"     -->
    <tr>
      <td class="l"><expr>movetime &lt;ms&gt;</expr></td>
      <td class="r">search exactly &lt;ms&gt; milli-seconds per move</td>
    </tr>
  </table>
</dir>

<p>
The fifth parameter denotes the lower bound score, the sixth parameter denotes
the upper bound score, both scores are in pawns units. If the lower-bound value
is specified with <i>unlimited</i>, it means negative unlimited. If the upper-bound
value is specified with <i>unlimited</i>, it means positive unlimited. The query
succeeds if the scoring of preceding move is within the given bounds (inclusive the
ranges). The score of preceding move is the difference between the score of the
current position minus the score of the preceding position. In case of mating
positions the difference will be always greater than 10,000.
</p>

<p>
The seventh parameter is either <i>sidetomove</i> or <i>absolute</i>.
<i>sidetomove</i> means that the evaluation value depends on side to move, and
<i>absolute</i> means that the evaluation value is independent from side to move.
</p>

<note>
Please note that in mode <i>movetime</i> the specification of the milli-seconds
will be rounded to centi-seconds if the engine is restricted to
<nobr>WinBoard</nobr>/<nobr>XBoard</nobr> protocol. If the UCI
protocol is available then the exact number of milli-seconds will be used.
</note>

<p>
Examples:
</p>

<verb>
<keyword>:moveevaluation</keyword> U ? depth 4 3.0 unlimited sidetomove
</verb>

<p>
Match first position were the score difference is at least 3.0 pawn units.
This means that last move was (probably) a blunder.
</p>

<verb>
<keyword>:moveevaluation</keyword> A a depth 4 unlimited -3.0 absolute
</verb>

<p>
Match first position were the evaluation difference is at least 3.0 pawn units
better for black. This means that last white move was (probably) a blunder.
Only capture moves were evaluated.
</p>

<verbatim>
(match
  (position <keyword>:moveevaluation</keyword> [&P;&p;] ?[?1,?8]
             unlimited 0.0 movetime 5000 absolute)
  (position <cql>position:promotion</cql> U <cql>position:cut</cql>)))
  (position <cql>position:preceding</cql>)
</verbatim>

<p>
Search for positions where side to move is doing first promotion in game, but
without gaining a better score. We have ensured that only promoting moves will
be evaluated.
</p>

<h2 id="accumulator">Accumulator keywords</h2>

<p>
There are mainly two accumulator keywords, <cql>:accumulate</cql> and
<cql>:sumrange</cql>. These are used to accumulate and to test the number of
transforms of the enclosing position list that match the current position. Each
time a transform of a position list matches a position, the accumulator
associated with that position is incremented. Any position with a sum range can
then test if the accumulator is within a certain range.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:accumulate">:accumulate</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:reset">:reset</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:sumrange">:sumrange</a></td></tr>
  </table>
</dir>

<h3 id="position:accumulate">:accumulate</h3>

<p>
This takes one parameter, the name of an accumulator. Each time the application
of some element of the transform set of the position list matches a position,
the accumulator associated with this name is incremented. The accumulator is
cleared when a new position is reached. In consequence <cql>:accumulate</cql>
should not be used inside of <cql>position:not</cql>, or
the <cql>position:sequence</cql> and <cql>position:gappedsequence</cql>
keywords).  Note that <cql>position:flipcolor</cql> likely has unexpected
results when used with <cql>:accumulate</cql>, because the accumulator is not
cleared between color flips.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h3 id="position:reset">:reset<extension/></h3>

<p>
This keyword takes as a parameter the name of an accumulator. It clears the
accumulator associated with this name after applying a transformation.
</p>

<p>
Example:
</p>

<p>
Tripled pawns can be found by the query:
</p>

<verbatim>
(position
  <keyword>:reset</keyword> acc
  &P;e2
  <cql>position:accumulate</cql> acc
  <cql>position:sumrange</cql> acc 3
  <cql>position:shiftvertical</cql>
  <cql>position:shifthorizontal</cql>)
</verbatim>

<p>
Note that this is only an example for the use of this keyword (taken from
<a href="http://hornid.com/chess/docs/CQL-3GX.pdf">The CQL 3.GX Extension</a>),
it is not recommended to use this statement for triple pawn search.
A much better way is:
</p>

<verbatim>
(position
  <cql>position:piececount</cql> &P;d[2-7] 3 6
  <cql>position:shifthorizontal</cql>
  <cql>position:flipcolor</cql>))
</verbatim>

<h3 id="position:sumrange">:sumrange<extension/></h3>

<p>
This takes as parameter the name of an accumulator and a
<a href="CQL-Range-Specifiers.html">range specifier</a>. It matches a position
if the value of the given accumulator lies within the range specifier.
</p>

<p>
For examples see:
<a href="CQL-Examples.html#accumulator">Using accumulators to count passed pawns</a>.
</p>

<h2 id="tagging">Tagging keywords</h2>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:tagmatch">:tagmatch</a></td></tr>
  </table>
</dir>

<h3 id="position:tagmatch">:tagmatch<extension/></h3>

<p>
The <cql>:tagmatch</cql> keyword takes two parameters, the name of a tag and
a piece designator. It matches only if the piece corresponding to the named tag
matches the given piece designator. For more information, see the section
on <a href="CQL-Tagging.html">tagging</a>.
</p>

<h2 id="control">Controlling keywords</h2>

<p>
With the help of controlling keywords the search flow or search result
will be affected. Actually none of these keywords is extending the capability
of CQL, each of them can be replaced, but the use of these keywords may
improve the search time considerably, and the expression may have a clearer
form.
</p>

<dir>
  <table>
    <tr><td>&#x2022;</td><td><a href="#position:cut">:cut</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:exclude">:exclude</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:following">:following</a></td></tr>
    <tr><td>&#x2022;</td><td><a href="#position:preceding">:preceding</a></td></tr>
  </table>
</dir>

<h3 id="position:cut">:cut<extension/></h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
stop position search for this game as soon as the match of the containing position
list succeeds. In latter case stop position of this game search as soon as the
match of the sub-position list succeeds. This keyword is never failing, with
other words: it is not influencing the result of all other matches.
</p>

<p>
The <cql>:cut</cql> position match has lower precedence than all other
position matches.  This means that a position is matching, if all other
position lists are matching this position, independent from the result of the
<cql>:cut</cql>. If the <cql>:cut</cql> position match should have highest
precedende, use keyword <cql>position:preceding</cql>. In this case the search
will stop with a negative result, independent from all other matches.
Consider the following examples:
</p>

<verb>
(match (position &lt;A&gt; <keyword>:cut</keyword> (position &lt;B&gt;)))
</verb>

<p>
Suppose &lt;A&gt; and &lt;B&gt; is matching a position, both the first time. In
this case the match of this game succeeds.
</p>

<verb>
(match (position &lt;A&gt; <keyword>:cut</keyword> (position <cql>position:preceding</cql>  &lt;B&gt;)))
</verb>

<p>
Suppose &lt;A&gt; and &lt;B&gt; is matching a position, both the first time. In
this case the match of this game fails.
</p>

<p>
Examples:
</p>

<verbatim>
(match
  (position
    <cql>position:mate</cql>
    <keyword>:cut</keyword> (position <cql>position:check</cql>)))
</verbatim>

<p>
Search for games ending with mate, and neither side has ever given
a check before. Actually keyword <cql>:cut</cql> is not required for this
search criterion, see next example:
</p>

<verbatim>
(match
  (position <cql>position:mate</cql>)
  (position <cql>position:check</cql> <cql>position:matchcount</cql> 1))
</verbatim>

<p>
But this version has to search the whole game, and the former version with
<cql>:cut</cql> fails as soon as first check occurs. In complex searches the
use of keyword <cql>:cut</cql> may be much faster than the use of
<cql>:matchcount</cql>.
</p>

<h3 id="position:endmost">:endmost<extension/></h3>

<p>
This keyword gives the last occurrence of a matched position in a game.
This could be expressed in the following way:
</p>

<verbatim>
(position
  &lt;A&gt;
  <cql>position:not</cql> (
    <cql>position:gappedsequence</cql> (
      (position)
      (position &lt;A&gt;))))
</verbatim>

<p>
Where <expr>&lt;A&gt;</expr> represents the wanted position. The use of
<cql>:endmost</cql> offers a much clearer expression for this query:
</p>

<verb>
(position &lt;A&gt; <keyword>:endmost</keyword>)
</verb>

<h3 id="position:exclude">:exclude<extension/></h3>

<p>
This keyword can be used in two forms: either it is included in a position
match list, or it has a sub-position list as argument. In former case:
exclude this game if the match of the containing position list succeeds.
In latter case exclude this game if the match of the sub-position list
succeeds. This keyword is not influencing the result of the position
match (see example).
</p>

<p>
This keyword will exclude games even if one of the position matches will
succeed before the <cql>:exclude</cql> expression is succeeding. In short:
this keyword is excluding games completely under certain conditions.
</p>

<p>
Example:
</p>

<verbatim>
(match
  (position
    &lt;A&gt;
    <keyword>:exclude</keyword> (position &lt;B&gt;)))
</verbatim>

<p>
Search for games containg a position which is matching expression
<expr>&lt;A&gt;</expr>, but not if expression <expr>&lt;B&gt;</expr> is
matching any position in this game. Actually this match can be written
without the use of keyword <cql>:exclude</cql>, in the following way:
</p>

<verbatim>
(match
  (position
    <cql>position:and</cql> (
      (position &lt;A&gt;)
      (position &lt;B&gt; <cql>position:matchcount</cql> 0))))
</verbatim>

<p>
But the use of keyword <cql>:exclude</cql> is simpler and clearer.
</p>

<h3 id="position:following">:following<extension/></h3>

<p>
This keyword gives the following position of a match, if any. This means
that the final position of a game cannot be found anymore, because it has
no successor. The keyword <cql>:following</cql> can be used only on top
level.
</p>

<p>
Example:
</p>

<verb>
(position &N;d4 <keyword>:following</keyword>)
</verb>

<p>
If a position with a knight on d4 will befound, deliver the successing
position as a result.
</p>

<h3 id="position:preceding">:preceding<extension/></h3>

<p>
This keyword gives the preceding position of a match, if any. If the start
position is matching, the match of this position will be ignored, and the
search is continuing. The keyword <cql>:preceding</cql> can be used only on
top level.
</p>

<p>
This keyword has a special meaning if combined with keyword
<cql>position:cut</cql>.
</p>

<p>
Examples:
</p>

<verb>
position <cql>position:check</cql> <keyword>:preceding</keyword>
</verb>

<p>
The result of this match is the predecessor of first position where one
side has given a check. Of course this can be expressed without this keyword:
</p>

<verb>
position <cql>position:sequence</cql>
((position <cql>position:nocheck</cql>) (position <cql>position:check</cql>))
</verb>

<p>
But the usage of <cql>:preceding</cql> is easier and the search is faster.
</p>

END

<!-- vi:set ts=2 sw=2 et filetype=html: -->
