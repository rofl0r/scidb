<!-- **********************************************************************
* Author : $Author$
* Version: $Revision: 161 $
* Date   : $Date: 2011-12-17 12:31:23 +0100 (Sat, 17 Dec 2011) $
* Url    : $URL$
*********************************************************************** -->

<!-- **********************************************************************
* Copyright: (C) 2013 Gregor Cramer
*********************************************************************** -->

<!-- **********************************************************************
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*********************************************************************** -->

INDEX CQL Examples
TITLE CQL - Examples

<ul>
  <li><a href="#accumulator">Using accumulators to count passed pawns</a></li>
  <li><a href="#relation">Relation list example</a></li>
  <li><a href="#tagging">Examples for tagging</a></li>
  <li><a href="#more">More examples</a></li>
</ul>

<h2 id="accumulator">Using accumulators to count passed pawns</h2>

<p>
We will show how to use <cql>position:accumulate</cql> and
<cql>position:sumrange</cql> to look for games that have at least 3 white
passed pawns in a position. First, we give a position filter that will
match any position with a white passed pawn:
</p>

<verbatim>
<comment>; match a position with a white passed pawn</comment>
(position
  &P;d2
  <cql>position:piececount</cql> [&p;&P;][d3-7] 0
  <cql>position:piececount</cql> &p;[c3-7,e3-7] 0
  <cql>position:shift</cql>)
</verbatim>

<p>
Now, to find at least 3 white passed pawns, we add in some accumulation code:
</p>

<verbatim>
<comment>; match a position with at least three white passed pawns</comment>
(position
  &P;d2
  <cql>position:piececount</cql> [&p;&P;][d3-7] 0
  <cql>position:piececount</cql> &p;[c3-7,e3-7] 0
  <cql>position:shift</cql>
  <cql>position:accumulate</cql> white_passer_counter
  <cql>position:sumrange</cql> white_passer_counter 3 8)
</verbatim>

<p>
Now suppose we want to find positions with at least two black passed pawns.
We can use:
</p>

<verbatim>
<comment>;match a position with at least two black passed pawns</comment>
(position
  &p;d7 
  <cql>position:piececount</cql> [&p;&P;][d2-6] 0
  <cql>position:piececount</cql> &P;[c2-6,e2-6] 0
  <cql>position:shift</cql>
  <cql>position:accumulate</cql> black_passer_counter
  <cql>position:sumrange</cql> black_passer_counter 2 8)
</verbatim>

<p>
Finally, to find positions with at least two black passers and at least three
white passers, we combine these lists:
</p>

<verbatim>
<comment>; match a position with at least three white</comment>
<comment>; and at least two black passers</comment>
(position
  <cql>position:sumrange</cql> white_passer_counter 3 8 
  <cql>position:sumrange</cql> black_passer_counter 2 8
  <cql>position:and</cql> (
    (position
      &P;d2 
      <cql>position:piececount</cql> [&p;&P;][d3-7] 0
      <cql>position:piececount</cql> &p;[c3-7,e3-7] 0
      <cql>position:shift</cql>
      <cql>position:accumulate</cql> white_passer_counter)
    (position
      &p;d7 
      <cql>position:piececount</cql> [&p;&P;][d2-6] 0
      <cql>position:piececount</cql> &P;[c2-6,e2-6] 0
      <cql>position:shift</cql>
      <cql>position:accumulate</cql> black_passer_counter)))
</verbatim>

<h2 id="relation">Relation list example</h2>

<p>
The following position list searches for games in which the configuration
</p>

<dir><code>
&K;e6 &b;e7 &b;e4 &n;d5
</code></dir>

<p>
occurs shifted or flipped, but in which no pieces from the original position
are on the same square as the pattern:
</p>

<verbatim>
(position
  &K;e6 &b;e7 &b;e4 &n;d5
  <cql>position:shift</cql>
  <cql>position:flip</cql>
  <cql>position:relation</cql> (
    <cql>relation:pattern</cql>
    <cql>relation:shift</cql>
    <cql>relation:flip</cql>
    <cql>relation:originalsamecount</cql> 0
    <cql>relation:samesidetomove</cql>
    <cql>relation:variations</cql>))
</verbatim>

<p>
If one modified the <cql>relation:originalsamecount</cql> parameter to, say,
<expr>0 3</expr> from its current value of 0, then it would be allowed to
overlap with at most three squares of the pattern in the original position.
</p>

<h2 id="tagging">Examples for tagging</h2>

<p>
Consider the problem of recognizing all games in which the same rook visits all
four corners of the board:
</p>

<verbatim>
(match
  <cql>match:forany</cql> rook [&r;&R;] <comment>; loop over the possible rooks</comment>
  (position $rook[a1]) 
  (position $rook[h1])
  (position $rook[h8])
  (position $rook[a8]))
</verbatim>

<p>
Here, the <cql>position:forany</cql> keyword in the match list introduces a tag named
"rook" which is constrained to range over white or black rooks, or over pawns that
eventually promote to one of those.
</p>

<p>
The first position list matches games in which there is a position such that the
tag "rook" represents a rook on a1. The next position list matches games in which
there is a position such that the tag represents a rook on h1. The tag represents
the same mark, that is, the same piece, between the position lists. The
<cql>position:forany</cql> keyword will sequentially bind the tag to each allowed mark.
</p>

<p>
Since a match list matches a game only if all its constituent position filters
match it, the code does what we want here.
</p>

<p>
Second example, the excelsior theme: a pawn starts at the second rank and then
promotes.
</p>

<verbatim>
(match
  <cql>match:forany</cql> pawn [&P;&p;]
  (position
    <cql>position:initial</cql>
    <cql>position:tagmatch</cql> pawn &P;?2
    <cql>position:gappedsequence</cql> ((position <cql>position:movefrom</cql> $pawn <cql>position:promote</cql> U))
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
<cql>position:tagmatch</cql> is matching pawns on second rank, and
the position sequence of <cql>position:gappedsequence</cql> is matching if
the tagged "pawn" is promoting in any subsequent game position.
</p>

<p>
Third example: the same piece delivers at least 30 checks in the game.
</p>

<verbatim>
(match
  <cql>match:forany</cql> checker A
  (position
    <cql>position:btm</cql>
    <cql>position:attackcount</cql> $checker &k; 1
    <cql>position:matchcount</cql> 30 unlimited
    <cql>position:flipcolor</cql>))
</verbatim>

<p>
Fourth example: knight gives mate with its first move.
</p>

<verbatim>
(match
  <cql>match:forany</cql> knight &N;
  (position
    <cql>position:movefrom</cql> $knight
    <cql>position:matchcount</cql> 1)
  (position
    <cql>position:mate</cql>
    <cql>position:attackcount</cql> $knight &k; 1)) 
</verbatim>

<h2 id="more">More examples</h2>

<verbatim>
<comment>; Match isolated triple pawns on connected squares</comment>
<comment>; Example: 8/p4pk1/8/2R1P1N1/6P1/6P1/2P2KP1/1r5r w - - 0 1</comment>

(match
  (position
    &P;[c2-4]                <comment>; pawns on connected squares</comment>
    <cql>position:piececount</cql> &P;c? 3 6    <comment>; at least three pawns </comment>
    <cql>position:piececount</cql> &P;[b?,d?] 0 <comment>; the triple pawns are isolated</comment>
    <cql>position:shiftvertical</cql>         <comment>; any rank</comment>
    <cql>position:shifthorizontal</cql>       <comment>; any file</comment>
    <cql>position:flipcolor</cql>))           <comment>; any side</comment>
</verbatim>

<verbatim>
<comment>; Multiple consecutive rook checks followed by king moving to</comment>
<comment>; empty square; usually to avoid stalemate if rook is captured.</comment>

(match
  <cql>match:result</cql> 1/2
  (position 
    <cql>position:wtm</cql>
    <cql>position:sequence</cql> (  
      (position <cql>position:movefrom</cql> &R; <cql>position:moveto</cql> .)
      (position <cql>position:movefrom</cql> &k; <cql>position:check</cql>)
      (position <cql>position:movefrom</cql> &R; <cql>position:moveto</cql> .)
      (position <cql>position:movefrom</cql> &k; <cql>position:check</cql>)
      (position <cql>position:movefrom</cql> &R; <cql>position:moveto</cql> .)
      (position <cql>position:movefrom</cql> &k; <cql>position:check</cql>)
      (position <cql>position:movefrom</cql> &R; <cql>position:moveto</cql> .)
      (position <cql>position:movefrom</cql> &k; <cql>position:check</cql>)
      (position <cql>position:movefrom</cql> &R; <cql>position:moveto</cql> .)
      (position <cql>position:movefrom</cql> &k; <cql>position:check</cql>))))
</verbatim>

<verbatim>
<comment>; Smothered Mate</comment>

<comment>; A smothered mate is a checkmate delivered by a knight</comment>
<comment>; in which the mated king is unable to move because he is</comment>
<comment>; surrounded (or smothered) by his own pieces.</comment>

(match
  (position
    <cql>position:flipcolor</cql>            <comment>; either color</comment>
    <cql>position:attackcount</cql> k [A.] 0 <comment>; king is smothered by own pieces</comment>
    <cql>position:mate</cql>))               <comment>; and is mate</comment>
</verbatim>

END

<!-- vi:set ts=2 sw=2 et filetype=html: -->
